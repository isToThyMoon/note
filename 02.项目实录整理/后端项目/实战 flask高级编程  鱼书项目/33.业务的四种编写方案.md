---
title: 33.业务的四种编写方案
categories:
  - 项目实录整理
  - 后端项目
  - 实战 flask高级编程  鱼书项目
tags:
  - 后端
date:
---

```python

from flask import current_app

from app.models.base import db, Base
from sqlalchemy import Column, Integer, String, Boolean, ForeignKey
from sqlalchemy.orm import relationship


class Gift(Base):
    id = Column(Integer, primary_key=True)
    isbn = Column(String(15), nullable=False, unique=True)
    user = relationship('User')
    uid = Column(Integer, ForeignKey('user.id'))
    launched = Column(Boolean, default=False)

    # book = relationship('Book')
    # bid = Column(Integer, ForeignKey('book.id'))


    @classmethod
    def recent(cls):
        # 链式调用
        # 主体Query
        # 子函数
        # 触发条件
        recent_gift = Gift.query.filter_by(launched=False).group_by(
            Gift.isbn).order_by(
            Gift.create_time).limit(
            current_app.config['RECENT_BOOK_COUNT']).distinct().all()
        return recent_gift

```


如果把recent方法作为实例方法 是不合理的 一个实例代表数据库的一条记录
而这个实例方法又返回多条记录
所以不合理
把它作为类方法

# 对象代表一个礼物 是具体的
# 类代表了礼物这个事物的抽象 不是一个具体的“一个”



recent这个方法还可以写在哪？

------------------

它的实质是做了一次数据库的查询 可以写在视图函数里的 但不推荐的

如果你的业务是有具体的业务的意义的 写在model里  如果暂时没有  写在视图函数 也是可以的

model只负责返回原始数据  对数据的处理要在视图函数里写 这是封装的原则

------------------

也可以单独提取成一个模型
建立一个recent_gift的类

------------------

建立一个Gift服务层  都是一些静态的方法 没有任何意义 垃圾写法

------------------
