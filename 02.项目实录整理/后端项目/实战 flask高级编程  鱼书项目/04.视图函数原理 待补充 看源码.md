---
title: 13
categories:
  - 项目实录整理
  - 后端项目
  - 实战 flask高级编程  鱼书项目
---

``` python

flask 怎么实现视图函数 一个客户端发过来的url对应一个处理函数的呢？

可以容易想到用dict  key是url  value是视图函数 一一对应处理

app.add.url_rule('url', view_func=, endpoint=) 不传endpoint  它的默认值是view_func endpoint作为key
flask在url映射到视图函数时 中间还有endpoint  用于反向构建url

每个应用程序app都有一个view_functions，这是一个字典，存储endpoint-view_func键值对。
add_url_rule的第一个作用就是向view_functions中添加键值对(这件事在应用程序run之前就做好了)



通过蓝图注册的视图函数  endpoint就是: 蓝图名称.视图函数

url_map存储的是url与endpoint的映射!
回到flask接受用户请求地址并查询函数的问题。实际上，当请求传来一个url的时候，
会先通过rule找到endpoint(url_map)，然后再根据endpoint再找到对应的view_func(view_functions)。
通常，endpoint的名字都和视图函数名一样。
这时候，这个endpoint也就好理解了：

实际上这个endpoint就是一个Identifier，每个视图函数都有一个endpoint，
当有请求来到的时候，用它来知道到底使用哪一个视图函数


在实际应用中，当我们需要在一个视图中跳转到另一个视图中的时候，我们经常会使用url_for(endpoint)去查询视图，而不是把地址硬编码到函数中。
这个时候，我们就不能使用视图函数名当endpoint去查询了
我们举个例子来说明。比如：

app = Flask(__name__)
app.register_blueprint(user, url_prefix='user')
app.register_blueprint(file, url_prefix='file')
我们注册了2个蓝图。
在user中(省略初始化过程)：

@user.route('/article')
def article():
    pass
在file中(省略初始化过程)：

@file.route('/article')
def article():
    pass
这时候，我们发现，/article这个路由对应了两个函数名一样的函数，分别在两个蓝图中。当我们使用url_for(article)调用的时候(注意，url_for是通过endpoint查询url地址，然后找视图函数)，flask无法知道到底使用哪个蓝图下的endpoint，所以我们需要这样:

url_for('user.article')

```

