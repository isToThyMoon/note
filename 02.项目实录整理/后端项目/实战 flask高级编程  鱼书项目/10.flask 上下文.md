---
title: 10.flask 上下文
categories:
  - 项目实录整理
  - 后端项目
  - 实战 flask高级编程  鱼书项目
tags:
  - 后端
date:
---

```python

from flask import Flask, current_app

app = Flask(__name__)

a = current_app
d = current_app.config['DEBUG']


#显示报错 working outside of application context
#为什么？

#涉及flask的上下文

```



应用上下文和请求上下文  本质上都是   对象
Flask -> AppContext  附加了一些额外的参数
Request -> RequestContext
对核心对象（app）Flask 和 请求Request 的封装 把它们作为属性封装
为什么封装？
当核心对象需要一些外部的数据 方法 可以把他们一起组成一个新的对象 上下文
都有push pop  __enter__  __exit__方法

如果我们要使用核心对象或者Request 不会直接操作 而是通过上下文
flask给了localproxy的方法 来间接操作


当一个请求进入flask  flask首先实例化一个RequestContext封装了此次请求的相关信息
而后把请求上下文推入_request_ctx_stack栈中（此栈是localstack类的实例化）
在请求上下文入栈之前 flask会检查_app_ctx_stack 如果为空或者栈顶元素不是当前核心对象
会先把一个AppContext推入_app_ctx_stack中
再把请求上下文推入_request_ctx_stack栈中

current_app和request永远都指向栈顶元素也就是一个上下文 但是current_app返回
的是核心对象 不是上下文

如果没有请求 做离线应用  单元测试
需要自己手动推入上下文到栈中

    ctx = app.app_context()  #返回AppContext上下文
    ctx.push()
    a = current_app
    d = current_app.config['DEBUG']
    ctx.pop()

更简洁的写法：

``` python

with app.app_context():
    a = current_app
    d = current_app.config['DEBUG']

AppContext上下文 实现了__enter__  __exit__方法
#对实现了上下文协议的对象使用with语句
#实现了enter 和exit 方法的叫上下文管理器
#上下文管理器必须返回一个上下文管理器


with open(r'') as f:
    print(f.read())
执行完自动调用f.close()

```

------------------

    class A:
        def __enter__(self):
            a= 1
            return self
    #enter 方法返回的值赋给 with 语句 as 后的变量
        def __exit__(self, exc_type, exc_value, tb):
            b = 2
    #exit 返回的True和false  返回True 外部不会再抛出异常

------------------

with 先执行enter 再执行语句体内容 再执行exit  exit也可以实现对错误处理

``` python

#回到问题最初 db.init_app(app)之后 在create_all时找不到核心对象 因为此时应用上下文没有入栈
#三种解决方法
def create_app():
    app = Flask(__name__)
    app.config.from_object('app.secure')
    app.config.from_object('app.setting')
    register_blueprint(app)

    db.init_app(app)
    #init 方法没有保存核心对象 只作临时参数 所以create_all()方法还要传入核心对象
    db.create_all(app=app)
    #或者 让create_all 自己寻找current_app 传入
    #with app.app_context():
    #  db.create_all()
    #或者 一开始实例化db = SQLAlchemy() 时 把app 作为属性 参数传入
    return app
    
```


