---
title: 13
categories:
  - 项目实录整理
  - 后端项目
  - 实战 flask高级编程  鱼书项目
---

线程安全为前提：


flask面对多个请求时 （应用服务器）开启了多少个线程来处理请求

对应的 已经知道flask中通过request这个变量来取请求中的数据
request指向_request_ctx_stack这个localstack栈顶
多个请求发过来 如果是一个进程的多线程处理 线程共享进程资源
一个request变量到底指向哪一个发过来的请求 （实例化的Request） 或者说指向哪一个线程的请求

request 是一个字典 key是线程的唯一标识id ？

python用线程隔离解决这个问题
原理 ： 字典

werkzeug库  的local对象模块 封装了字典 实现线程隔离
它设置线程的id为字典的key



线程隔离的栈 localstack

我们知道 AppContext 和RequestContext 被推入 _app_ctx_stack 和_request_ctx_stack
这两个栈就是对local对象封装的栈 可以作线程隔离

local是用字典方式实现的线程隔离对象
localstack是线程隔离的栈结构

一切问题都可以用封装解决 一次不行 就两次

	s = LocalStack()
	s.push(1)
	print(s.top)

	def worker()
	  print(s.top)
	  s.push(2)
	  print(s.top)

	new_t = threading.Thread(target=worker, name='new_thread')
	new_t.start()
	time.sleep(1)

	#主线程
	print(s.top)


s = LocalStack() 也是线程隔离的

_app_ctx_stack 和_request_ctx_stack都是LocalStack
是为了隔离被推入栈中的对象

localproxy的对象 current_app和 request通过以线程id为key取字典中的value ：上下文


使用线程隔离的意义在于
使得当前线程能够正确引用到它自己创建的对象
而不是引用到其他线程创建的对象

对象是保存状态的地方


线程隔离对象 ：两个stack
被线程隔离对象： 两个上下文 上下文内部的核心对象和Request
区别在于 核心对象只在初始化时create了一次 而每来一个request 都会创建一次Request实例




总结:

	#以线程id号为key的字典 -> Local -> LocalStack

	#AppContext RequestContext  推入LocalStack  结束 pop出

	#Flask作为属性 ->AppContext     Request作为属性-> 和RequestContext

	#current_app ->(LocalStack.top = AppContext    返回的是top.app = Flask)

	#request -> (LocalStack.top = RequestContext   返回的是top.request = Request)
