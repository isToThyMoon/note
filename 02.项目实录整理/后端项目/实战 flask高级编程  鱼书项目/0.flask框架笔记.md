---
title: 13
categories:
  - 项目实录整理
  - 后端项目
  - 实战 flask高级编程  鱼书项目
---

所有 Flask 程序都必须创建一个程序实例。
Web 服务器使用一种名为 Web 服务器网关接口（Web Server Gateway Interface，WSGI）的协议，把接收自客户端的所有请求都转交给这个对象处理。
程序实例是 Flask 类的对象，经常使用下述代码创建：


-------


``` python

from flask import Flask
    app = Flask(__name__)# Flask 类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。在大多数程序中，Python的__name__变量就是所需的值。
（Flask 用这个参数决定程序的根目录，以便稍后能够找到相对于程序根目录的资源文件位置。）

from flask import (
  Flask,              #类
  request,            #对象
  render_template,    #函数
  redirect,           #函数
  url_for,            #函数
)

```


flask其实是一个web framework上跑了一个web application

------------------

1. app.py

``` python

#先要初始化一个 Flask 实例
app = Flask(__name__)             #都叫app 所以都这么写

#设置 secret_key 来使用 flask 自带的 session
#这个字符串随便你设置什么内容都可以 用来对称加密session 是md5算法等等的key
app.secret_key = 'random string'

#最后运行服务器时
if __name__ == '__main__':
        #debug 模式可以自动加载你对代码的变动, 所以不用重启程序
        #host 参数指定为 '0.0.0.0' 可以让别的机器访问你的代码
        config = dict(
            debug=True,
            host='0.0.0.0',      -指定什么ip的主机（客户端）可以访问自己（服务器）
            port=2000,
        )
app.run(**config)
#app.run() 开始运行服务器
#所以你访问下面的网址http://127.0.0.1:2000/就可以打开网站了

```

------------------

2.路由


``` python

#定义路由和路由处理函数
@app.route(’/‘, methods=[’GET‘])     # 装饰器函数定义路由参数path 和 可接受的 http方法（list）
def hello_world():                   # 定义路由函数
        return ’<h1>Hello Gua</h1>‘      # 这里返回的其实是http响应中的body
        
```


------------------

``` python

#管理路由  蓝图 blueprint
#首先在路由文件（写了路由处理函数的）中创建蓝图对象
#创建一个 蓝图对象
#第一个参数是蓝图的名字, 以后会有用(add函数里面就用到了)
#第二个参数是套路
main = Blueprint('todo', __name__)

#并且路由定义在蓝图对象中 如
@main.route('/')
def index():
    #查找所有的 todo 并返回
    todo_list = Todo.all”()
    #flask 已经配置好了 jinja2 模板引擎
    #并且可以直接使用 render_template 来生成响应数据(http_response)
    return render_template('todo_index.html', todos=todo_list)

#然后在 flask 主代码app中「注册蓝图」来使用
from routes.todo import main as todo_routes
app.register_blueprint(todo_routes, url_prefix='/todo') #有一个 url_prefix 可以用来给蓝图中的每个路由加一个前缀

```

------------------

``` python

#一般来说，我们会用 url_for 生成路由，如下
#return redirect(url_for('message_view'))
#注意, url_for 参数是路由函数的名字（格式为字符串） 解析出对应的路由  还可以添加参数作为此路由函数的传入参数参数
#/todo/add
@main.route('/add', methods=['POST'])
def add():
    form = request.form
    t = Todo.new(form)
    t.save()
    #蓝图中的 url_for 需要加上蓝图的名字，这里是 todo   .index 在蓝图里找方法 找方法对应的路由
    return redirect(url_for('todo.index'))    

```

------------------

``` python

路由
#/todo/delete/1
@main.route('/delete/<int:todo_id>/')
def delete(todo_id):
    """
    <int:todo_id> 的方式可以匹配一个 int 类型
    int 指定了它的类型，省略的话参数中的 todo_id 就是 str 类型

    这个概念叫做 动态路由
    意思是这个路由函数可以匹配一系列不同的路由

    动态路由是现在流行的路由设计方案
    """
    #通过 id 删除 todo
    t = Todo.delete(todo_id)
    #引用蓝图内部的路由函数的时候，可以省略名字只用 .
    #因为我们就在 todo 这个蓝图里面, 所以可以省略 todo
    #return redirect(url_for('todo.index'))
    return redire
#动态ct(url_for('.index'))   

```

------------------

3.request
 
    # request 是一个local变量 每次请求都会变  post来的数据在request.form  get来的方法在request.args

------------------

    # request.method 保存请求的方法
    # get请求的数据都会到路径里传输到后台
    # post请求的数据在http请求的body里传输到后台

------------------

    # request.args 是 flask 保存 URL 中的参数的属性
    # 访问 http://127.0.0.1:2000/message?a=1
    # 会打印如下输出
    # request ImmutableMultiDict([('a', '1')])
    # (ImmutableMultiDict 是 flask 的自定义类型, 意思是不可以改变的字典)
    # 但引用时和dict是一样的   request.args['a']就是'1'

------------------

    #request.form 是 flask 保存 POST 请求的表单数据的属性 也是一个immutablemutidict 但是可以当dic引用
     #把数据生成一个 dict 存到 message_list 中去
        msg = {
            'content': request.form.get('msg_post', ''),
        }
        message_list.append(msg)




------------------

4.渲染render

    #render_template 是一个 flask 内置函数
    #它的作用是读取并返回 templates 文件夹中的模板文件
    #messages 是传给模板的参数，这样就能在模板中使用这个变量了  用jinja2 渲染
    def xx():
        return render_template('message_index.html', messages=message_list)
    #flask的render_template和以前自己写的template不太一样 它甚至可以把局部作用域里的所有函数都传进模板message_index.html
    #比如在flask里定义了url_for函数 完全可以把它传入 在模板里调用

------------------

实现异步非阻塞 高并发

------------------

1.多线程或者多进程

``` python

if __name__ == '__main__':
    app.run(host=myaddr,port=myport,debug=False,threaded=True) --#threaded开启以后 不需要等队列 threaded=True
    -或者
    -app.run(host=myaddr,port=myport,debug=False,processes=3) --#processes=N 进程数量，默认为1个

```

------------------

2. gevent协程

``` python

#Flask
from flask import Flask, request, g
import os
import sys
reload(sys)
sys.setdefaultencoding('utf-8')

#gevent
from gevent import monkey
from gevent.pywsgi import WSGIServer
monkey.patch_all()
#gevent end

app = Flask(__name__)
app.config.update(DEBUG=True)

-获取本机电脑名
myname = socket.getfqdn(socket.gethostname(  ))

-获取本机ip
myaddr = socket.gethostbyname(myname)
myport = 8912


@app.route('/test1')
def the_test1():
    print "test1 print start"
    time.sleep(10)
    print "test1 print after sleep"
    return 'hello asyn'

@app.route('/test2')
def the_test2():
    print "test2 print!"
    return 'test2 return'




if __name__ == '__main__':
    http_server = WSGIServer((myaddr, myport), app)
    http_server.serve_forever()

```

------------------

3.通过gunicorn 搭配gevent
gunicorn运行配置文件：

``` python

import gevent.monkey
import multiprocessing

gevent.monkey.patch_all()

bind = '0.0.0.0:2001'
pid = '/tmp/bbs.pid'

workers = multiprocessing.cpu_count() * 2 + 1
threads = multiprocessing.cpu_count() * 2
worker_class = 'gevent'
proc_name = 'gunicorn.proc'

```



------------------
------------------
------------------
------------------

对flask session 的官方理解：


``` python

from flask import Flask, session, redirect, url_for, escape, request

app = Flask(__name__)

@app.route('/')
def index():
    if 'username' in session:
        return 'Logged in as %s' % escape(session['username'])
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''
        <form action="" method="post">
            <p><input type=text name=username>
            <p><input type=submit value=Login>
        </form>
    '''

@app.route('/logout')
def logout():
    #remove the username from the session if it's there
    session.pop('username', None)
    return redirect(url_for('index'))

#set the secret key.  keep this really secret:
app.secret_key = 'A0Zr98j/3yX R~XHH!jmN]LWX/,?RT'

if __name__ == '__main__':
    #debug 模式可以自动加载你对代码的变动, 所以不用重启程序
    #host 参数指定为 '0.0.0.0' 可以让别的机器访问你的代码
    config = dict(
        debug=True,
        host='0.0.0.0',
        port=2000,
    )
    app.run(**config)

```

