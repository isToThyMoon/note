---
title: 6.immutable
categories:
  - 项目实录整理
  - 前端项目
  - 03.实战 react 简书项目
tags:
  - react项目
date:
---
防止我们在reducer.js中直接更改state的内容
通过immutable.js把state变成一个不可变对象
那么 对他的操作都通过get 和set方法完成

	import * as constants from './constants.js';
	import { fromJS } from 'immutable';

	const defaultState = fromJS({
		focused: false
	});

	export default (state = defaultState, action) => {
		if (action.type === constants.SEARCH_FOCUS) {
			return state.set('focused', true);
		};
		if (action.type === constants.SEARCH_BLUR) {
			return state.set('focused', false);
		}
		return state;
	}


immutable对象的set方法，会结合之前immutable对象的值，和设置的值，返回一个全新的对象


那么在容器组件中

	const mapStateToProps = (state) => {
		return {
			focused: state.header.get('focused')
		}
	};

用.运算符和get方法获取到数据
这样获取数据的格式不统一 我们需要用redux—immutable统一格式 都变成immutable对象
那么不用redux自带的combineReducers 而是用redux-immutable这个库带的combineReducers创建总的reducer
那么取数据就可以：
focused: state.get('header').get('focused')
或者focused: state.getIn(['header', 'focused'])


fromJS() 把一个普通对象装为immutable对象
toJS() 把一个immutable对象转为普通对象
list() 把一个普通list 转为immutable list （不包含list内部的内容）

state是一个immutable对象

	const defaultState = fromJS({
		topicList: [],
		articleList: [],
		bandList: []
	});

	state.merge({
					topicList: fromJS(action.topicList),
					articleList: fromJS(action.articleList),
					bandList: fromJS(action.bandList)
	}); 返回一个修改后的state新对象

	state.set('', list) 返回一个修改后的state新对象

	state.get('articleList').concat(action.list) 先得到一个immutable list ， 之后追加内容 返回一个新的追加后的immutable list。
