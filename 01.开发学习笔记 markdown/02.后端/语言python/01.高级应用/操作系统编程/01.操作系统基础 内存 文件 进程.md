---
title: 01.操作系统基础 内存 文件 进程
categories:
  - 01.开发学习笔记 markdown
  - 05.语言python
  - 操作系统编程
---


2^2=4
2^3=8
2^4=16
2^5=32
2^6=64
2^7=128
2^8=256
2^9=512
2^10=1024      1024b = 1kb
2^32=4*1024^3


# 操作系统
1. 内存管理
2. 驱动管理
3. 进程线程协程
4. 文件系统

## 1. 内存
32位电脑 按字节寻址 一个存储单元一个字8bit=1B   2^32B=4GB
DOS时代 内存是程序自己控制
Windows 统一的内存空间 4G 每个程序看到的都是4G
虚拟存储器
1. CPU n核心  ALU加法器  从cpu寄存器中存取数据
2. 每个核心 L1 L2缓存   切换有cache miss 不命中
3. 整个CPU L3 3M
4. 内存 很大很大8G
5. 硬盘
6. 网络传输

虚拟存储器，统一的内存模型
一个程序 4G 是存储的总和 内存+硬盘
电脑4G
a 1G -> 内存中  页表
b 1G -> 内存中  页表

c 3G -> 把a存储，把c load进来

代价是一个切换io的时间

a => page fault=>page load=>运行


## 2. 驱动
    ps/2 usb bluetooth
    flopy disk
    linux: 统一成文件 read write seek

## 3. 文件系统
数组
[meta元信息 对应的文件位置（偏移量） 对应的文件大小]
格式化： 会把所有信息抹掉
快速格式化：meta清空

所有的文件，存在同一个file
/main/main.py -> file load -> execute

所有的文件系统抽象起来 就是 索引+ 具体的值

## 进程 线程
1. 进程 pid 时间片
2. 多线程
3. 线程和进程
    实现进程间通信的方法有:管道、信号量、共享内存、消息队列。
    进程间通信 pipe管道 file文件 socket网络传输
    线程通信 对n线程来说 我都可以看到进程中的全局数据

    对于一个进程来说，你持有了一个页表
    对于同一个进程内的线程，你共享同一张页表

4. 多线程同步问题

    数组 支持add
    1. 把数组size + 1
    2. 把add的这个数字放在 data[size]

    两个线程 同时add
    1. A线程 走了1
    2. B线程 也走了1
    3. A存了数据 data[size] = xxx
    4. B也存了数据 data[size] = xxx

核心在于
你的操作被拆分
解决方案呢？
1. atomic swap_and_cmp 原子操作
2. 加锁，mutex互斥锁，信号量，读写锁，自旋锁。

加锁以后，我对这个资源有所有权，
在我所有操作没有结束前，
其他操作这个数据的人，就要等待

数组 支持add
1. 加锁
2. 把数组size + 1
3. 把add的这个数字放在 data[size]
4. 解锁

两个线程 同时add
1. A线程 走了1
2. B线程 也走了1
3. A 2
4. A 3
5. A 解锁
4. b走2，3，4

同步会有问题？产生了死锁
哲学家进餐

1. 为什么死锁？获取资源的顺序不一样
对于底下哲学家 先1后2
对于上面哲学家 先2后1

所有的哲学家都是先1后2
1. 调整最后一个人的顺序（比如2个人就让第二个人拿右再拿左）
2. 如果我那不到右手，那我左手的也不要

线程安全的交换数据的函数
swap(a,b)
id(a) id(b)
a.lock()
b.lock()
exchange(a.data, b.data)
a.unlock()
b.unlock()

swap(a,b) ------ swap(b,a)

Python? GIL global interpreter lock
