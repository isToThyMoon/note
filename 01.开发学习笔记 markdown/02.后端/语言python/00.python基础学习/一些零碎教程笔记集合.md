---
title: 一些零碎教程笔记集合
categories:
  - 01.开发学习笔记 markdown
  - 05.语言python
  - 00.python基础学习
---

python基础：

# 类------实例化----->对象（实例化对象） 对象是类的一个实例

一个class定义内部 方法有实例方法和用@classmethod修饰的类方法  用来创建类实例的要用类方法

# 数据类型和变量：
这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：
int a = 123; // a是整数类型变量
a = "ABC"; // 错误：不能把字符串赋给整型变量

 
在Python中，通常用全部大写的变量名表示常量：PI = 3.14159265359
 但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。 

 
# 在Python中，有两种除法
一种除法是/：

`>>> 10 / 3`
3.3333333333333335
/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：
`>>> 9 / 3`
3.0
还有一种除法是//，称为地板除，两个整数的除法仍然是整数：
`>>> 10 // 3`
3
你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。
因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：
`>>> 10 % 3`
1

无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。

 
 
Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。
对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。
注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。
Python的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。

# 字符编码：
在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：
`>>> print('包含中文的str')`
包含中文的str

对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：
`>>> ord('A')`
65
`>>> ord('中')`
20013
`>>> chr(66)`
'B'
`>>> chr(25991)`
'文'


由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。 
`>>> 'ABC'.encode('ascii')`
b'ABC'
`>>> '中文'.encode('utf-8')`
b'\xe4\xb8\xad\xe6\x96\x87'

在bytes中，无法显示为ASCII字符的字节，用\x##显示。
反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
`>>> b'ABC'.decode('ascii')`
'ABC'

`>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')`
'中文'

如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节：
`>>> b'\xe4\xb8\xad\xff'.decode('utf-8', errors='ignore')`
'中'
要计算str包含多少个字符，可以用len()函数：
`>>> len('ABC')`
3
`>>> len('中文')`
2
len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：
`>>> len(b'ABC')`
3
`>>> len(b'\xe4\xb8\xad\xe6\x96\x87')`
6
`>>> len('中文'.encode('utf-8'))`
6



代码中字符串的默认编码与代码文件本身的编码一致。

如：s='中文'

如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。通常，在没有指定特定的编码方式时，都是使用的系统默认编码创建的代码文件。

如果字符串是这样定义：s=u'中文'

则该字符串的编码就被指定为unicode了，即python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。


python是个容易出现编码问题的语言。所以，我按照我的理解写下下面这些文字。
=首先，要了解几个概念。=
*字节：计算机数据的表示。8位二进制。可以表示无符号整数：0-255。下文，用“字节流”表示“字节”组成的串。
*字符：英文字符“abc”，或者中文字符“你我他”。字符本身不知道如何在计算机中保存。下文中，会避免使用“字符串”这个词，而用“文本”来表
示“字符”组成的串。
*编码（动词）：按照某种规则（这个规则称为：编码（名词））将“文本”转换为“字节流”。（在python中：unicode变成str）
*解码（动词）：将“字节流”按照某种规则转换成“文本”。（在python中：str变成unicode）
**实际上，任何东西在计算机中表示，都需要编码。例如，视频要编码然后保存在文件中，播放的时候需要解码才能观看。
unicode：unicode定义了，一个“字符”和一个“数字”的对应，但是并没有规定这个“数字”在计算机中怎么保存。（就像在C中，一个整数既
可以是int，也可以是short。unicode没有规定用int还是用short来表示一个“字符”）
utf8：unicode实现。它使用unicode定义的“字符”“数字”映射，进而规定了，如何在计算机中保存这个数字。其它的utf16等都是
unicode实现。
gbk：类似utf8这样的“编码”。但是它没有使用unicode定义的“字符”“数字”映射，而是使用了另一套的映射方法。而且，它还定义了如何在
计算机中保存。
=python中的encode，decode方法=
首先，要知道encode是 unicode转换成str。decode是str转换成unicode。
下文中，u代表unicode类型的变量，s代表str类型的变量。
u.encode('...')基本上总是能成功的，只要你填写了正确的编码。就像任何文件都可以压缩成zip文件。
s.decode('...')经常是会出错的，因为str是什么“编码”取决于上下文，当你解码的时候需要确保s是用什么编码的。就像，打开zip文
件的时候，你要确保它确实是zip文件，而不仅仅是伪造了扩展名的zip文件。
u.decode(),s.encode()不建议使用，s.encode相当于s.decode().encode()首先用默认编码（一般是
ascii）转换成unicode在进行encode。
=关于#coding=utf8=
当你在py文件的第一行中，写了这句话，并确实按照这个编码保存了文本的话，那么这句话有以下几个功能。
1.使得词法分析器能正常运作，对于注释中的中文不报错了。
2.对于u"中文"这样literal string能知道两个引号中的内容是utf8编码的，然后能正确转换成unicode
3."中文"对于这样的literalstring你会知道，这中间的内容是utf8编码，然后就可以正确转换成其它编码或unicode了。


"最后，对于str变量，file文件读取的内容，urllib得到的网络上的内容，都是以“字节”形式的。"
虽然文件或者网页是文本的,但是在保存或者传输时已经被编码成bytes了,所以用"rb"打开的file和从socket读取的流是基于字节的.
"它们如果确实是一段“文本”，比如你想print出来看看。那么你必须知道它们的编码。然后decode成unicode。"
这里的加引号的"文本",其实还是字节流(bytes),而不是真正的文本(unicode),只是说明我们知道他是可以解码成文本的.
在解码的时候,如果是基于约定的,那就可以直接从指定地方读取如BOM或者python文件的指定coding或者网页的meta,就可以正确解码,
但是现在很多文件/网页虽然指定了编码,但是文件格式实际却使用了其他的编码(比如py文件指定了coding=utf8,但是你还是可以保存成ansi--记事本的默认编码),这种情况下真实的编码就需要去猜了






# 格式化
在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：
`>>> 'Hello, %s' % 'world'`
'Hello, world'

`>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)`
'Hi, Michael, you have $1000000.'
你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。

format()
另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：
`>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)`

'Hello, 小明, 成绩提升了 17.1%'


input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：
	
	s = input('birth: ')
	birth = int(s)
	if birth < 2000:
	    print('00前')
	else:
	    print('00后')

 Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 

 
用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：
`>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}`
`>>> d['Michael']`
95

 
把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
`>>> d['Adam'] = 67`
`>>> d['Adam']`
67

要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
`>>> 'Thomas' in d`
False

二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
`>>> d.get('Thomas')`
`>>> d.get('Thomas', -1)`
-1

注意：返回None的时候Python的交互环境不显示结果。
要删除一个key，用pop(key)方法，对应的value也会从dict中删除：
`>>> d.pop('Bob')`
75
`>>> d`
{'Michael': 95, 'Tracy': 85}
set
set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。
要创建一个set，需要提供一个list作为输入集合：
`>>> s = set([1, 2, 3])`
`>>> s`
{1, 2, 3}

通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：
`>>> s.add(4)`
`>>> s`
{1, 2, 3, 4}
`>>> s.add(4)`
`>> s`
{1, 2, 3, 4}
通过remove(key)方法可以删除元素：
`>>> s.remove(4)`
`>>> s`
{1, 2, 3}
`>>> x, y = move(100, 100, 60, math.pi / 6)`
`>>> print(x, y)`
151.96152422706632 70.0
但其实这只是一种假象，Python函数返回的仍然是单一值：
`>>> r = move(100, 100, 60, math.pi / 6)`
`>>> print(r)`
(151.96152422706632, 70.0)
原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。

函数参数：
我们可以把年龄和城市设为默认参数：

``` python

def enroll(name, gender, age=6, city='Beijing'):
    print('name:', name)
    print('gender:', gender)
    print('age:', age)
    print('city:', city)
    
```

这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：
`>>> enroll('Sarah', 'F')`
name: Sarah
gender: F
age: 6
city: Beijing

只有与默认参数不符的学生才需要提供额外的信息：

``` python

enroll('Bob', 'M', 7)
enroll('Adam', 'M', city='Tianjin')

```

可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。
有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。
也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值。

定义默认参数要牢记一点：默认参数必须指向不变对象