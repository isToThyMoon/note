---
title: 变量的作用域
categories:
  - 01.开发学习笔记 markdown
  - 05.语言python
date:
---

# L –> E –> G –>B 的规则查找，
即：局部 -> 局部外的局部找（例如闭包）-> 全局 -> 内建。

# L(local)局部作用域
局部变量：包含在def关键字定义的语句块中，即在函数中定义的变量。每当函数被调用时都会创建一个新的局部作用域。Python中也有递归，即自己调用自己，每次调用都会创建一个新的局部命名空间。在函数内部的变量声明，除非特别的声明为全局变量，否则均默认为局部变量。有些情况需要在函数内部定义全局变量，这时可以使用global关键字来声明变量的作用域为全局。局部变量域就像一个 栈，仅仅是暂时的存在，依赖创建该局部作用域的函数是否处于活动的状态。所以，一般建议尽量少定义全局变量，因为全局变量在模块文件运行的过程中会一直存在，占用内存空间。
注意：如果需要在函数内部对全局变量赋值，需要在函数内部通过global语句声明该变量为全局变量。

#E(enclosing)嵌套作用域
E也包含在def关键字中，E和L是相对的，E相对于更上层的函数而言也是L。与L的区别在于，对一个函数而言，L是定义在此函数内部的局部作用域，而E是定义在此函数的上一层父级函数的局部作用域。主要是为了实现Python的闭包，而增加的实现。

# G(global)全局作用域
即在模块层次中定义的变量，每一个模块都是一个全局作用域。也就是说，在模块文件顶层声明的变量具有全局作用域，从外部开来，模块的全局变量就是一个模块对象的属性。
注意：全局作用域的作用范围仅限于单个模块文件内

# B(built-in)内置作用域
系统内固定模块里定义的变量，如预定义在builtin 模块内的变量。



局部作用域会覆盖全局作用域，但不会影响全局作用域

在局部空间（如def）的global声明 可以在局部空间使用全局定义的变量
在局部空间的nonlocal声明 可以在局部空间使用外层闭包空间（enclosing）的变量


闭包Closure（局部外的局部）(python闭包是实现装饰器的基础)
闭包的定义：如果在一个内部函数里，对外部作用域（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure)




# Python函数嵌套
``` python

def outer():  
    x = 1  
    def inner():  
        print x # 1  
    inner() # 2  
  
outer()  
```

1.#1的地方，python寻找名为x的local变量，在inner作用域内的locals中寻找不到，python就在外层作用域中寻找，其外层是outer函数。x是定义在outer作用域范围内的local变量。
2.#2的地方，调用了inner函数。这里需要特别注意：inner也只是一个变量名，是遵循python的变量查找规则的（Python先在outer函数的作用域中寻找名为inner的local变量）

# 例子

``` python

variable = 300
def test_scopt():
    print variable   #variable是test_scopt()的局部变量，但是在打印时并没有绑定内存对象。
    variable = 200

test_scopt()
print variable

```

上面的例子会报出错误，因为在执行程序时的预编译能够在test_scopt()中找到局部变量variable(对variable进行了赋值)。在局部作用域找到了变量名，所以不会升级到嵌套作用域去寻找。但是在使用print语句将变量variable打印时，局部变量variable并有没绑定到一个内存对象(没有定义和初始化，即没有赋值)。本质上还是Python调用变量时遵循的LEGB法则和Python解析器的编译原理，决定了这个错误的发生。所以，在调用一个变量之前，需要为该变量赋值(绑定一个内存对象)。
注意：为什么在这个例子中触发的错误是UnboundLocalError而不是NameError：name ‘variable’ is not defined。因为变量variable不在全局作用域。Python中的模块代码在执行之前，并不会经过预编译，但是模块内的函数体代码在运行前会经过预编译，因此不管变量名的绑定发生在作用域的那个位置，都能被编译器知道。Python虽然是一个静态作用域语言，但变量名查找是动态发生的，直到在程序运行时，才会发现作用域方面的问题。
这里涉及到了Python编译运行的原理

``` python

variable = 300
def test_scopt():
    print variable   #没有在局部作用域找到变量名，会升级到嵌套作用域寻找，并引入一个新的变量到局部作用域(将局部变量variable赋值为300)。
#    variable = 200

test_scopt()
print variable

```
这是可以运行的。 输出300 300 
