一些参考文章：
https://juejin.cn/post/6990186384778756109

https://heptaluan.github.io/2019/07/07/JavaScript/37/

理解异步模型、事件循环首先要懂浏览器进程和线程调度的知识，至少了解基本规则和调度顺序。

文章列举了一些浏览器内核，浏览器内核各家都不一样，一般就指渲染引擎和js引擎的结合。

主要就是webkit（chrome Safari等都在用），

chrome对webkit内核的js引擎不满，自己写了个V8引擎，这后来变成node.js的支柱实现。

了解这个内核的渲染机制就可以了。


# 浏览器的主要进程
进程是 CPU 资源分配的最小单位（是能拥有资源和独立运行的最小单位）
线程是 CPU 调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
同进程内的线程可以轻易跨线程通信
不同进程之间也可以通信，不过代价较大
单线程与多线程，都是指在一个进程内的单和多。进程是车间，那么线程就是车间内的不同条流水线，完成不同功能。

对于计算机来说，每一个应用程序都是一个进程，而每一个应用程序都会分别有很多的功能模块，这些功能模块实际上是通过子进程来实现的，对于这种子进程的扩展方式，我们可以称这个应用程序是多进程的。

而对于浏览器来说，浏览器就是多进程的，比如我们在 Chrome 浏览器中打开了多个 TAB，然后打开控制管理器是可以看到一个 Chrome 浏览器启动了好多个进程，那么浏览器又是具体包含了哪些进程呢？可以参考下面这个图片。

![](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/37-15.png)

可以归纳为以下这些

* 主进程（Browser Process）
    打开浏览器就会开启一个浏览器主进程，主进程开启一些辅助进程，如网络服务，GPU，渲染等
    协调控制其他子进程（创建、销毁）
    浏览器界面显示，用户交互，前进、后退、收藏
    将渲染进程得到的内存中的 Bitmap，交给GPU进程绘制到用户界面上
    处理不可见操作，网络请求，文件访问等
* 第三方插件进程（Plugin Process）
    每种类型的插件对应一个进程，仅当使用该插件时才创建
* GPU 进程（GPU Process）
    最多只有一个，用于 3D 绘制等
* 渲染进程（Renderer Process）
    也称为浏览器渲染进程或浏览器内核，内部是多线程的
    主要负责页面渲染，脚本执行，事件处理等
    **每个 TAB 页一个渲染进程**

其实上面的有些进程我们不需要太过理解，在这里我们只需要重点关心渲染进程，也就是我们常说的浏览器内核（主要就是webkit）。

# 渲染进程（浏览器内核）
一个tab就是一个渲染进程控制一个页面，一个渲染进程中会开启多个线程负责不同功能模块维护该页面。

渲染进程（浏览器内核）：
    GUI渲染线程（渲染引擎）
    JS线程（js引擎 v8）
    浏览器事件触发线程
    定时触发器线程
    异步http请求线程

其中对前端开发者来说最重要的就是GUI渲染线程和JS线程之间的一些协调工作关系。因为我们不是在解决页面渲染工作，就是在写JS代码。

GUI 渲染线程：
    负责渲染浏览器界面：解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等
    当界面需要重绘（Repaint）或由于某种操作引发回流（reflow）时，该线程也会执行
    注意，GUI 渲染线程与 JavaScript 引擎线程是互斥的，当 JavaScript 引擎执行时 GUI 线程会被挂起（相当于被冻结了），GUI 更新会被保存在一个队列中等到 JavaScript 引擎空闲时立即被执行

JavaScript 引擎线程
    该线程也称为 JavaScript 内核（例如 V8 引擎）），负责处理 JavaScript 脚本程序
    Javascript 引擎线程理所当然是负责解析 Javascript 脚本，运行代码。浏览器无论什么时候都只有一个 JS 线程在运行 JS 程序。
    JavaScript 引擎一直等待着任务队列中任务的到来，然后加以处理，一个 Tab 页（renderer进程）中无论什么时候都只有一个 JavaScript 线程在运行 JavaScript 程序
    注意，GUI 渲染线程与 JavaScript 引擎线程是互斥的，所以如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
    但js线程执行过程中，渲染线程也不是什么事情都不做，js执行时布局、重排和解析html（不包括dom生成）也可能会同时执行，这是浏览器的优化策略，做一些计算布局和解析html的工作，尽可能快的加载页面。但页面的绘制一定是与js线程互斥的。
    
浏览器事件触发线程：
    归属于浏览器而不是 JavaScript 引擎，用来控制事件循环（可以理解，JavaScript 引擎自己都忙不过来，需要浏览器另开线程协助）
    当 JavaScript 引擎执行代码块如 setTimeout 时（也可来自浏览器内核的其他线程，如鼠标点击、Ajax 异步请求等），会将对应任务添加到事件线程中
    当对应的事件符合触发条件被触发时，该线程会把结果回调事件添加到待处理队列的队尾，等待 JavaScript 引擎的处理
    注意，由于 JavaScript 的单线程关系，所以这些待处理队列中的事件都得排队等待 JavaScript 引擎处理（当 JavaScript 引擎空闲时才会去执行）

定时触发器线程：
    传说中的 setInterval 与 setTimeout 所在线程
    浏览器定时计数器并不是由 JavaScript 引擎计数的，（因为 JavaScript 引擎是单线程的， 如果处于阻塞线程状态就会影响记计时的准确）
    因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JavaScript 引擎空闲后执行）是更为合理的方案。
    注意，W3C 在 HTML 标准中规定，规定要求 setTimeout 中低于 4ms 的时间间隔算为 4ms，所以最短间隔就是4ms。

异步 HTTP 请求线程
    XMLHttpRequest 在连接后是通过浏览器新开一个线程请求
    将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中再由 JavaScript 引擎执行
    异步事件其实都有专门的线程去处理，和js线程分开，这样就很好理解同步任务和异步任务结合的代码是如何处理的。

# 实际渲染流程

先纵览下：
* 解析 HTML 文件（网络进程加载了多少数据，HTML解析器便解析多少数据，并不是等HTML文件全下载完），构建 DOM 树，同时扫描到需加载资源（发起 JavaScript 文件的下载 request，并不需要 DOM 处理到那个 script 节点。），浏览器主进程（内部下载进程）负责下载资源文件（css js 图片）
* CSS 文件下载完成，解析 CSS 文件成树形的数据结构，然后结合 DOM 树合并成 RenderObject 树
* 布局 RenderObject 树（Layout/reflow），负责 RenderObject 树中的元素的尺寸，位置等计算
* 绘制 RenderObject 树（paint），绘制页面的像素信息
* 浏览器主进程将默认的图层和复合图层交给 GPU 进程，GPU 进程再将各个图层合成（composite），最后显示出页面

## 1. 解析 HTML 标签，构建 DOM 树
DOM 提供了对 HTML 文档结构化的表述。

在渲染引擎中，DOM 有三个层面的作用：
1、从页面的视角来看，DOM 是生成页面的基础数据结构。 
2、从 JavaScript脚本视角来看，DOM提供给 JavaScript脚本操作的接口，通过这套接口，JavaScript可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。 
3、从安全视角来看，DOM是一道安全防护线，一些不安全的内容在DOM解析阶段就被拒之门外了。

这个阶段对应着 Create/Update DOM And request CSS/Images/JavaScript 的过程，也就是说浏览器请求到 HTML 代码后，在生成 DOM 的最开始阶段（应该是 Bytes → characters 后），并行发起 CSS、Images、JavaScript 的请求，无论他们是否在 HEAD 里

不过需要注意的是，发起 JavaScript 文件的下载 request，并不需要 DOM 处理到那个 script 节点。

dom树具体是如何构建的？

渲染引擎内部，有一个叫HTML解析器（HTMLParser）的模块，它的职责就是负责将HTML 字节流转换为DOM结构。

HTML解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML解析器便解析多少数据。

那详细的流程是怎样的呢？网络进程接收到响应头之后，会根据请求头中的 content-type字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为DOM。

## 2. 解析 CSS 标签，构建 CSSOM 树

这个阶段对应着 Create/Update Render CSSOM 的过程，即 CSS 文件下载完成，开始构建 CSSOM，其中的 CSSOM 即 CSS Object Model，是浏览器将 CSS 代码解析成树形的数据结构。

其中 DOM 和 CSSOM 都是以下图当中所示的流程，也就是依次经过 Bytes（字节数据），Characters（字符串），Tokens，Nodes 最后到 Object Model 这样的方式生成最终的数据，也就是如下几个步骤

* 转码，浏览器将接收到的二进制数据按照指定编码格式转化为 HTML 字符串
* 生成 Tokens，之后开始 parser，浏览器会将 HTML 字符串解析成 Tokens
* 构建 Nodes，对 Node 添加特定的属性，通过指针确定 Node 的父、子、兄弟关系和所属 treeScope
* 生成 DOM Tree，通过 Node 包含的指针确定的关系构建出 DOM Tree

在这里我们需要注意的是，DOM 树的构建过程是一个深度遍历过程，当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点

![](https://raw.githubusercontent.com/heptaluan/blog-backups/master/cdn/js/37-02.png)

CSSOM 会阻塞渲染，只有当 CSSOM 构建完毕后才会进入下一个阶段构建渲染树。

通常情况下 DOM 和 CSSOM 是并行构建的，
但是当浏览器遇到一个不带 defer 或 async 属性的默认 `<script>` 资源标签时，DOM 构建将暂停，等待js资源下载和运行，如果此时又恰巧浏览器尚未完成 CSSOM 的下载和构建，由于 JavaScript 可以修改 CSSOM，那么需要等 CSSOM 构建完毕后再执行 JavaScript，最后才重启继续 DOM 构建。

## 3. 把 DOM 和 CSSOM 组合成渲染树

![](https://raw.githubusercontent.com/heptaluan/blog-backups/master/cdn/js/37-03.png)

这个阶段对应着 Create/Update Render Tree 的过程，所有 CSS 文件下载完成，CSSOM 构建结束后，和 DOM 一起生成 Render Tree


-------

前三步据实际测试，各部分的dom元素构建dom树和cssom树，合并成渲染树，是以script标签为各部分分隔的，
也就是说一段dom1之后有script1，script1之后是dom2等等，会先构建dom1的渲染树，但不会走立即下面的4.5步骤，
因为有script标签，它有修改dom和样式的可能性，而浏览器在加载script并执行完之前是不知道的，
所以js引擎（js线程里）一定会阻塞渲染引擎（渲染线程里），
这时渲染线程会先挂起，等待这段script1被js线程加载执行完毕后工作（但是它不会等待script2的执行完再绘制，即使script2也修改了dom1，这是一种浏览器一种分布渲染的策略，确保用户不会等太久，不然你一个超大的html文件，很多个的script执行，用户必须要等到所有script执行完再看到最终页面是不合理的。），执行以下4.5步骤绘制到屏幕。
注意此时script1下面的dom2不要说4.5步骤还没开始，它还没解析dom，连123步骤都没开始。
要等dom1绘制完毕后才会继续解析dom2，构建dom树cssom树，合并成渲染树，然后会同样判断dom2下有没有script阻塞绘制，
没有的话就会立即layout计算并绘制到屏幕。
有的话重复以上步骤。

-------


## 4. 在渲染树的基础上进行布局，计算每个节点的几何结构

这个阶段对应着 Layout 的过程，有了 Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的 CSS 定义以及他们的从属关系，这一步操作之所以称为 Layout，顾名思义就是计算出每个节点在屏幕中的位置

## 5. 把每个节点绘制到屏幕上

这个阶段对应着 Painting 的过程，Layout 后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的 CSS 属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry），就进入了最后一步 Painting，按照算出来的规则，通过显卡，把内容画到屏幕上

Render Tree 和 DOM 一样，以多叉树的形式保存了每个节点的 CSS 属性、节点本身属性、以及节点的孩子节点

这里有一个比较特殊的情况，就是 display: none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以如果某个节点最开始是不显示的，设为 display: none 是更优的

以上五个步骤前三个步骤之所有使用 Create/Update 是因为 DOM、CSSOM、Render Tree 都可能在第一次 Painting 后又被更新多次，比如 JavaScript 修改了 DOM 或者 CSS 属性，Layout 和 Painting 也会被重复执行，除了 DOM、CSSOM 更新的原因外，图片下载完成后也需要调用 Layout 和 Painting 来更新网页。


# 渲染流程拆解（重排和重绘）
上面提到的渲染5步流程可能比较抽象，下面拆解成经常遇到的一些实际案例操作，简单归纳下步骤。 

通常来说我们在编写 Web 页面时，我们需要理解我们所写的页面代码是如何被转换成屏幕上显示的像素的，这个转换过程我们可以归纳为这样的一个流水线，包含五个关键步骤：

javascript style layout paint composite

JavaScript：
    一般来说，我们会使用 JavaScript 来实现一些视觉变化的效果，比如用 jQuery 的 animate 函数做一个动画、对一个数据集进行排序、或者往页面里添加一些 DOM 元素等，当然除了JavaScript 还有其他一些常用方法也可以实现视觉变化效果，比如 CSS Animations，Transitions 和 Web Animation API
    
Style calculations（计算样式）：
    这个过程是根据 CSS 选择器，比如 .headline 或 .nav > .nav_item，对每个 DOM 元素匹配对应的 CSS 样式，这一步结束之后，就确定了每个 DOM 元素上该应用什么 CSS 样式规则

Layout（布局）：
    上一步确定了每个 DOM 元素的样式规则，这一步就是具体计算每个 DOM 元素最终在屏幕上显示的大小和位置，Web 页面中元素的布局是相对的，因此一个元素的布局发生变化，会联动地引发其他元素的布局发生变化，比如 <body> 元素的宽度的变化会影响其子元素的宽度，其子元素宽度的变化也会继续对其孙子元素产生影响，因此对于浏览器来说，布局过程是经常发生的

Paint（绘制）：
    本质上就是填充像素的过程，包括绘制文字、颜色、图像、边框和阴影等，也就是一个 DOM 元素所有的可视效果，一般来说，这个绘制过程是在多个图层上完成的
    
Compositing（组合 合并图层）：
    由上一步可知，对页面中 DOM 元素的绘制是在多个层上进行的，在每个层上完成绘制过程之后，浏览器会将所有层按照合理的顺序合并成一个图层，然后显示在屏幕上，对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常


上述过程的每一步中都有产生掉帧的问题，因此一定要弄清楚我们的代码将会运行在哪一步，有时我们可能会听到栅格化（rasterize）与绘制一起使用，这是因为绘制这个动作实际是包含两步：

* 产生系列的格子
* 往格子中填充像素

这个过程后来被称之为栅格化（rasterization），所以我们在 DevTools 中看到的绘制记录，应该要知道其中已经包含了栅格化这一过程，但是我们不需要了解所有帧画面渲染流程上的所有流程。

实际上，当我们修改视图的时候，有三种方式会重新生成一个帧画面，无论是修改 JavaScript，CSS 还是 Web Animations，这里我们重点关注这三种方式：

1. JavaScript/CSS > Style > layout > Paint > Composite

如果我们修改布局属性（元素的几何形状），比如宽度，高度以及位置，那么浏览器会检查哪些元素需要重新布局，然后对页面激发一个 reflow 过程完成重新布局，被 reflow 的元素，接下来也会激发绘制过程，最后激发渲染层合并过程，生成最后的画面。

这种方式会造成完整的重排和重绘，是最耗费页面资源的。

2. JavaScript/CSS > Style > Paint > Composite

如果我们只是修改了绘制属性，比如说背景图片，字体颜色，阴影等，这些属性不属于页面布局，因此浏览器会在完成样式计算之后，跳过布局过程，只做绘制和渲染层合并过程。

这种方式不涉及布局和尺寸，没有重排只有重绘，比较理想。

3. JavaScript/CSS > Style > Composite

如果我们修改的属性既不属于布局，也不属于绘制，那么浏览器会在完成样式计算之后，跳过布局和绘制的过程，直接做渲染层合并，第三种方式在性能上是最理想的，对于动画和滚动这种负荷很重的渲染，我们要争取使用第三种渲染流程。

如果想知道哪些 CSS 属性会触发这三种方式，可以参考 [CSS Triggers](https://csstriggers.com/)
，而对于高性能动画方面则可以参考“[使用渲染层合并属性](https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count)”。

-------

## reflow repaint

以上小章其实就是讲解了重排和重绘。javascript style layout paint composite这五个步骤其实就对应了**实际渲染流程**第三步：**把 DOM 和 CSSOM 组合成渲染树**之后解析到script标签的处理流程。只不过在页面初始化阶段，js执行之前dom虽然解析但并没有绘制，js执行之后，dom元素才会第一次绘制到屏幕上。

我们都知道 HTML 默认是流式布局的，但 CSS 和 JS 会打破这种布局，改变 DOM 的外观样式以及大小和位置。因此我们就需要知道两个概念：

reflow（回流）: 当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来，这个过程就是回流（也叫重排，中文翻译问题，其实就是reflow能理解就好了），常见的 reflow 是一些会影响页面布局的操作，诸如 Tab，隐藏等。reflow 会从 HTML 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置，以确认是渲染树的一部分发生变化还是整个渲染树。reflow 几乎是无法避免的，因为只要用户进行交互操作，就势必会发生页面的一部分的重新渲染，且通常我们也无法预估浏览器到底会 reflow 哪一部分的代码，因为他们会相互影响。

repaint（重绘）: repaint 当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）

我们知道，当网页生成的时候，至少会渲染一次，在用户访问的过程中，还会不断重新渲染，重新渲染会重复 回流 + 重绘，或者只有重绘，回流必定会发生重绘，重绘不一定会引发回流，重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能，回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。

需要注意的是，display:none 会触发 reflow，而 visibility: hidden 属性则并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，它会被渲染成一个空框，这在我们上面有提到过。所以 visibility:hidden 只会触发 repaint，因为没有发生位置变化。我们不能避免 reflow，但还是能通过一些操作来减少回流：
1.用transform做形变和位移.
2.通过绝对位移来脱离当前层叠上下文，形成新的Render Layer。

另外有些情况下，比如修改了元素的样式，浏览器并不会立刻 reflow 或 repaint 一次，而是会把这样的操作积攒一批（帧的概念），然后做一次 reflow，这又叫异步 reflow 或增量异步 reflow。但是在有些情况下，比如 resize 窗口，改变了页面默认的字体等。对于这些操作，浏览器会马上进行 reflow。

其他什么情况下会造成reflow repaint不多提，例子非常多，只要操作切合两种特性就行。
唯一要注意 计算 offsetWidth 和 offsetHeight 属性也会导致回流。

-------

### 如何减少回流、重绘
使用 transform 替代 top
使用 visibility 替换 display: none，因为前者只会引起重绘，后者会引发回流（改变了布局）
不要把节点的属性值放在一个循环里当成循环里的变量

```
for (let i = 0; i < 1000; i++) {
  // 获取 offsetTop 会导致回流，因为需要去获取正确的值
  console.log(document.querySelector('.test').style.offsetTop)
}
```

不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
CSS 选择符从右往左匹配查找，避免节点层级过多
将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，比如对于 video 标签来说，浏览器会自动将该节点变为图层
集中改变样式，即通过改变 class 的方式来集中改变样式
使用 DocumentFragment，我们可以通过 createDocumentFragment 创建一个游离于 DOM 树之外的节点，然后在此节点上批量操作，最后插入 DOM 树中，因此只触发一次重排

```js
var fragment = document.createDocumentFragment()

for (let i = 0; i < 10; i++) {
  let node = document.createElement('p')
  node.innerHTML = i
  fragment.appendChild(node)
}

document.body.appendChild(fragment)
```

提升为合成层（关于合成层我们会在下面进行介绍），将元素提升为合成层有以下优点
    合成层的位图，会交由 GPU 合成，比 CPU 处理要快
    当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
    对于 transform 和 opacity 效果，不会触发 layout 和 paint
    通常来说，提升合成层的最好方式是使用 CSS 的 will-change 属性
    更多关于合成层的相关内容可以参考[无线性能优化：Composite](https://fed.taobao.org/blog/taofed/do71ct/performance-composite/)

```css
#target {
  will-change: transform;
}
```


## 渲染层合并（Composite）
渲染层合并，对于页面中 DOM 元素的绘制（Paint）是在多个层上进行的，在每个层上完成绘制过程之后，浏览器会将绘制的位图发送给 GPU 绘制到屏幕上，将所有层按照合理的顺序合并成一个图层，然后在屏幕上呈现，对于有位置重叠的元素的页面，这个过程尤其重要，因为一旦图层的合并顺序出错，将会导致元素显示异常。

![](https://raw.githubusercontent.com/heptaluan/blog-backups/master/cdn/js/37-17.png)

* RenderLayers 渲染层，这是负责对应 DOM 子树
* GraphicsLayers 图形层，这是负责对应 RenderLayers 子树
* RenderObjects 保持了树结构，一个 RenderObjects 知道如何绘制一个 Node 的内容，通过向一个绘图上下文（GraphicsContext）发出必要的绘制调用来绘制 Nodes

每个 GraphicsLayer 都有一个 GraphicsContext，GraphicsContext 会负责输出该层的位图，位图是存储在共享内存中，作为纹理上传到 GPU 中，最后由 GPU 将多个位图进行合成，然后画到屏幕上，此时我们的页面也就展现到了屏幕上

GraphicsContext 绘图上下文的责任就是向屏幕进行像素绘制（这个过程是先把像素级的数据写入位图中，然后再显示到显示器），在 Chrome 里，绘图上下文是包裹了的 Skia（Chrome 自己的 2D 图形绘制库）

某些特殊的渲染层会被认为是合成层（Compositing Layers），合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 父层公用一个

### 合成层的优点
一旦 renderLayer 提升为了合成层就会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升

合成层的位图，会交由 GPU 合成，比 CPU 处理要快，也就是说，提升到合成层后合成层的位图会交 GPU 处理，但请注意，仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到 GPU，生成合成层的位图处理（绘图上下文的工作）是需要 CPU
当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层，当需要 repaint 的时候可以只 repaint 本身，不影响其他层，但是 paint 之前还有 style，layout 那就意味着即使合成层只是 repaint 了自己，但 style 和 layout 本身就很占用时间
对于 transform 和 opacity 效果，不会触发 layout 和 paint，仅仅是 transform 和 opacity 不会引发 layout 和 paint，其他的属性不确定
一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能

注意不能滥用 GPU 加速，一定要分析其实际性能表现，因为 GPU 加速创建渲染层是有代价的，每创建一个新的渲染层，就意味着新的内存分配和更复杂的层的管理，并且在移动端 GPU 和 CPU 的带宽有限制，创建的渲染层过多时，合成也会消耗跟多的时间，随之而来的就是耗电更多，内存占用更多，过多的渲染层来带的开销而对页面渲染性能产生的影响，甚至远远超过了它在性能改善上带来的好处

更多详细内容可以参考下面几个链接。

[Accelerated Rendering in Chrome](https://www.html5rocks.com/zh/tutorials/speed/layers/)
[CSS GPU Animation: Doing It Right](https://www.smashingmagazine.com/2016/12/gpu-animation-doing-it-right/)
[无线性能优化：Composite](https://fed.taobao.org/blog/taofed/do71ct/performance-composite/?spm=taofed.blogs.blog-list.10.67bd5ac8fHy0LS)

-------


