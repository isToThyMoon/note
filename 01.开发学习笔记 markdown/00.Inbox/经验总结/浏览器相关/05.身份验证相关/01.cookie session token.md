---
title: 18.cookie session
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 00.浏览器相关
---

brief：

cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时在header中被携带并发送到服务器上。

cookie用于身份验证，但无法解决身份伪造，因为所有数据都在header里。

session：服务端对象映射存储session key 和key对应的用户信息，浏览器cookie只存储随机字符串生成的key。

# cookie：
在网站中，http请求是无状态的（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息）。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。
cookie的出现就是为了解决这个问题。
第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的cookie数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。cookie存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过4KB。因此使用cookie只能存储一些小量的数据。

## Cookie 的特点
1. 服务器通过 Set-Cookie 响应头设置浏览器某域名的 Cookie，浏览器得到 Cookie 之后，浏览器解析时，下次再发送http请求就会在请求头增加一个Cookie：字段标识身份。
2. 服务器读取 Cookie 就知道登录用户的信息（email等等）
3. cookie实际保存在浏览器如c盘的一个文件里，客户端在一段时间内保存这个cookie，默认有效期20分钟左右，不同浏览器策略不同，但默认在用户关闭页面后就失效。后台代码可以任意设置cookie的过期时间。
4. 可被篡改
5. 存储在客户端
6. 不可跨域（一级域名和二级域名之间是允许共享使用的（靠的是 domain））
7. Cookie 遵守同源策略，不过跟 AJAX 的同源策略稍微有些不同。
8. 单个 Cookie 保存的数据不能超过 4KB

当请求 qq.com 下的资源时，浏览器会默认带上 qq.com 对应的 Cookie，不会带上 baidu.com 对应的 Cookie
当请求 v.qq.com 下的资源时，浏览器不仅会带上 v.qq.com 的Cookie，还会带上 qq.com 的Cookie


cookie虽然就是一段字符串，但默认约定了一些重要属性。
name=value; 键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型

domain; 指定 cookie 所属域名，默认是当前域名

path; 指定 cookie 在哪个路径（路由）下生效，默认是 '/'。如果设置为 /abc，则只有 /abc 下的路由可以访问到该 cookie，如：/abc/read。

maxAge; cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。- 比 expires 好用。

expires; 过期时间，在设置的某个时间点后该 cookie 就会失效。一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除


在 JavaScript 中，你可以使用 document.cookie 来设置、读取和删除 Cookie。以下是使用 JavaScript 实现 Cookie 的设置、读取和删除的示例：

设置 Cookie：
```
function setCookie(name, value, days) {
  const expires = new Date();
  expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);
  document.cookie = `${name}=${value};expires=${expires.toUTCString()};domain=a.xxx.com;path=/`;
}

setCookie("username", "john", 7); // 设置名为 "username" 的 Cookie，有效期为 7 天
```


读取 Cookie：
```
function getCookie(name) {
  const cookieValue = document.cookie.match(`(^|;) ?${name}=([^;]*)(;|$)`);
  return cookieValue ? cookieValue[2] : null;
}

const username = getCookie("username"); // 读取名为 "username" 的 Cookie
console.log(username); // 输出 Cookie 的值，如果不存在则为 null
```
删除 Cookie：
```
function deleteCookie(name) {
  document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;`;
}

deleteCookie("username"); // 删除名为 "username" 的 Cookie
```

在这些示例中，setCookie 函数用于设置 Cookie，它接受名称、值和过期天数作为参数。getCookie 函数用于读取 Cookie，它接受名称作为参数，并返回相应的值。deleteCookie 函数用于删除 Cookie，它接受名称作为参数，然后将 Cookie 的过期时间设置为过去的时间，从而将其删除。

请注意，使用 document.cookie 进行 Cookie 操作时，需要注意 Cookie 的路径和域名等设置，以确保操作正确生效。另外，由于 Cookie 在客户端存储，安全性可能会受到一些限制，如跨站脚本攻击（XSS）。在实际应用中，可能需要进一步的安全性和细致的设置。


-------

# session:

session和cookie的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie是存储在浏览器所在的本地，而session存储在服务器。存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，但现在服务器已经发展至今，一些session信息还是绰绰有余的。

session 可以是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中。

也可以不基于cookie实现，前后端分离时代非常容易实现。

其实也很简单，前端登录时，发送请求，后台直接返回一个json格式的session_id,这是后端存储的对应映射的key，是一串随机字符串，上面有说明。
前端解析json后，在下次发送请求时直接将这个session_id放到请求地址的query里发送，后端解析请求地址时的query就能取到session_id，知道这是哪一个用户了。
实质思想是一样的，只不过cookie帮我们做了上面的事情。

## cookie和session结合使用：
web开发发展至今，cookie和session的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式：

1、存储在服务端：通过cookie存储一个session_id，然后具体的数据则是保存在session中。如果用户已经登录，则服务器会在cookie中保存一个session_id，下次再次请求的时候，会把该session_id携带上来，服务器根据session_id在session库中获取用户的session数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做server side session。

2、将session数据加密，然后存储在cookie中。这种专业术语叫做client side session。flask采用的就是这种方式（其实就是cookie），但flask也给了选择可以替换成其他形式。

## 为什么采用session？
cookie 解决了身份验证 但是无法解决身份伪造 需要使用session技术
``` python
session= {
            'session_id': username
         }
```
存一个随机的字符串，字符串和用户的关联对应关系在服务器中。
session_id是一个随机字符串，作为key对应存储 value是username。
服务器返回增加Set-Cookie: user=session_id 这样的http头给浏览器。
下次浏览器发送http请求时自动发送Cookie: user=session_id 字段的http头，服务器取字符串即可以验证身份。
但是，因为http是无状态协议，经过的每一个路由其实都可以查看请求和返回信息，仅凭cookie是不能用来进行高风险操作的比如改密码，所以现在网站改密码都必须输入旧密码或者手机验证。

怎么实现session在服务器端的过期功能：

```
session= {
    'session_id': {
         'username': 'dadada',
         '过期时间': '1.22 21:00:00'
    }
}
```

## session 持久化（持久化就是重启后仍然可以使用）
保存到文件
对称加密

## session 共享
一台session服务器在所有服务器（视频 qq 音乐） 存储所有的session 所有服务器都去询问session服务器是不是有登录信息 实现session共享 用户规模扩大 为了实现负载 有多台session服务器在背后 而只提供一个借口在外面供给应用服务器查询


# Token

什么是 Token（令牌）

## Acesss Token
访问资源接口（API）时所需要的资源凭证
简单 token 的组成： uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）
特点：

服务端无状态化、可扩展性好
支持移动端设备
安全
支持跨程序调用

请求步骤：
客户端使用用户名跟密码请求登录
服务端收到请求，去验证用户名与密码
验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端
客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里
客户端每次向服务端请求资源的时候需要带着服务端签发的 token
服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据


* 每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里
* 基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库
* token 完全由应用管理，所以它可以避开同源策略

有点像是所谓client side的cookie，区别是acess token的传输验证可以通过cookie中，也可以通过在其他自定义header中，独特性在于token如果不通过cookie实现，可以避开同源策略。


## Refresh Token
另外一种 token——refresh token
refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。

Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。
Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。

过程：

浏览器通过usename password请求服务器
服务器将登陆凭证数字签名加密后得到的字符串作为token返回
access token一周有效期，refresh token一个月有效期
浏览器拿到token保存本地

下一次请求，access token没过期就顺利正常返回数据。
access token过期，返回错误
拿refresh token请求请求服务器，
若refresh token没过期，返回新access token和refresh token
如果refresh token也过期，那么需要重新登录返回新token


## Token 和 Session 的区别
Session 是一种记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息。而 Token 是令牌，访问资源接口（API）时所需要的资源凭证。Token 使服务端无状态化，不会存储会话信息。

Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。

所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。


# JWT

JSON Web Token是目前最流行的跨域认证解决方案。它是一种token的加密和认证授权的规范。

有啥区别呢？

Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。