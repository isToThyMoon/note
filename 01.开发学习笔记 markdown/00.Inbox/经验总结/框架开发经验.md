# 

模版或者jsx写入太长太复杂逻辑判断

改为计算属性或者useMemo

大量重复节点

改为列表渲染


# 后端参数处理

```
handleParams() {
    const params = {};
    params.id = this.formItem.id;
    params.startDate = this.formItem.startDate.format("YYYY-MM-DD");
    params.endDate = this.formItem.endDate.format("YYYY-MM-DD");
    params.price = this.formItem.price.toString();
    params.type = this.formItem.type;
    params.total = this.formItem.total;
    params.name = this.formItem.name;
    params.comment = this.formItem.comment;
    // ... 此处省略一万行代码
}
```

看到这样的代码内心是崩溃的，明显只有几个字段需要处理一下却把所有字段都赋值了一遍，可以这样简化：
```
handleParams() {
	const { startDate, endDate, price, ...params } = this.formItem;
  params.startDate = startDate.format("YYYY-MM-DD");
  params.endDate = endDate.format("YYYY-MM-DD");
  params.price = price.toString();
	// ... 此处省掉一万行代码
}
```

# 硬编码

```js
computed: {
  isGood() {
    return this.type === 1;
  },
  isBad() {
    return this.type === 0;
  }
}
```
看上面的例子，这种硬编码基本随处可见，作者在写这段代码的时候肯定是觉得这个type只会在这里用到，没有必要单独定义一个常量来管理，后面接收的同学来了他也不会去关注之前的逻辑，他只要用到了type又会去重新判断一下是good还是bad，就这样最后代码中充斥着0,1,2,3这样的数字，后来新人接到一个需求并且涉及到这些数字背后的含义这个时候就不得不去一个一个地询问原作者了，好的做法就是写成常量配置文件，单独写一个文件config.js，然后组件去引用这个常量:
```js
// 货物的品质枚举值exportconst GOODS_TYPE = {
  good: 1,// 质量好bad: 0// 质量差
};
```

# Mixins屎山

容易造成变量覆盖以及来路不明等问题，如果必须使用vue2的话这种情况是避免不了的，只能尽量减少组件对mixins中data的耦合度。