# 动态规划

动态规划背后的基本思想非常简单。就是将⼀个问题拆分为⼦问题，⼀般来说这些⼦问题都是非常相似的，
⼀旦得出每个⼦问题的解，就存储该结果以便下次使用。
那么我们可以通过只解决⼀次每个⼦问题来达到减少计算量的目的。

最简单的动态规划

## 如何优化斐波那契数列？

斐波那契数列就是从 0 和 1 开始，后面的数都是前两个数之和。
一般来说，这个数列通过递归非常容易实现。

```js
function fib(n) {
  if (n < 2 && n >= 0) return n;
  return fib(n - 1) + fib(n - 2);
}
```

递归实现的斐波那契数列在性能上存在问题主要是因为它存在大量的重复计算。每次计算第 n 个斐波那契数时，都会递归计算第 n-1 和第 n-2 个斐波那契数，而这两个子问题中可能包含大量相同的子问题，导致指数级别的重复计算。

具体来说，递归实现的斐波那契数列的时间复杂度是 O(2^n)，其中 n 是要计算的斐波那契数的索引。这是因为每个递归调用会产生两个子问题，导致指数级别的调用树。这使得算法在处理较大的 n 时变得非常慢。

为了提高性能，可以使用其他方法来优化斐波那契数列的计算，例如动态规划、矩阵乘法、记忆化递归等。这些方法可以避免重复计算，将指数级别的时间复杂度降低为多项式级别或者线性级别，从而显著提高性能。

### 用动态规划优化

```js
function fib(n) {
  const cache = Array.apply(null, { length: n + 1 });
  cache[0] = 0;
  cache[1] = 1;
  for (let index = 2; index <= n; index++) {
    cache[index] = cache[index - 1] + cache[index - 2];
  }
  return cache[n];
}
```

甚至可以用闭包继续优化重复调用 fib(n)，小于之前调用的 n 的时候，直接命中缓存值。
