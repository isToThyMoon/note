
# 卡顿
检测fps情况
1.在浏览器的DevTools -> Sources -> Ctrl+Shift+P -> 输入FPS，观察网页的fps帧数，是否会有大幅度帧数变化
2.在浏览器的DevTools -> Performance -> 点击中间的圆点开始记录

代码层面以requestAnimationFrame执行时间戳来确定fps间隔，波动很大，说明卡顿。

卡顿更严重进一步就是崩溃。

# 
卡顿：页面严重的掉帧现象。


前端页面卡顿的原因有很多，从渲染机制和运行上可以分为两大类：
渲染不及时，页面掉帧（js线程长时间占用 页面回流和重绘较多 资源加载阻塞）
网页内存占用过高，运行卡顿（内存泄漏直接爆掉就是页面崩溃）

# 渲染问题
渲染不及时的原因：
浏览器的渲染频率一般是60HZ，即要求1帧的时间为1s / 60 = 16.67ms，浏览器显示页面的时候，要处理js逻辑，还要做渲染，每个执行片段不能超过16.67ms。实际上，浏览器内核自身支撑体系运行也需要消耗一些时间，所以留给我们的时间差不多只有10ms。
常见的优化方式：
采用requestIdleCallback和requestAnimationFrame，任务分片

页面回流和重绘较多：
尽量减少layout
获取scrollTop、clentWidth等维度属性时都会触发layout以获取实时的值，所以在for循环里面应该把这些值缓存一下
资源加载阻塞：
js资源放在body之前
行内script阻塞
css加载会阻塞DOM树渲染（css并不会阻塞DOM树的解析）
资源过大阻塞

# 内存问题
意外的全局变量引起的内存泄漏
闭包引起的内存泄漏
被遗忘的定时器
循环引用
DOM删除时没有解绑事件
没有清理的DOM元素引用

    
# 监控卡顿
Performance
定位一个页面的运行是否有卡顿，最简单又直接的方式是录制 Performance。Performance 会把耗时长的任务直接标记为红色，我们可以根据这些任务，查找和分析具体产生耗时的脚本是哪些，然后去做优化。

但是，Performance 仅对开发者来说比较方便，在真实用户的使用场景里，未必有条件能提供 Performance 的录制。更多的时候，我们只能粗略地监控用户的卡顿情况，发现这样的场景，并尝试去解决。

requestAnimationFrame
一般来说我们监控卡顿，可以考虑使用window.requestAnimationFrame方法。该方法会在绘制下一帧绘制前被调用，这意味着当前的同步计算任务即将结束。

前面也有说到，卡顿大多数是因为长耗时的计算任务导致的。那么，我们就可以考虑在某个函数执行之前记下时间戳，而在window.requestAnimationFrame的时候再取其中的时间差，判断当前函数的执行耗时是否合理。

当然，该方案并不是完全准确，因为我们常常会在一个函数中间调用另外一个函数，还可能会同步抛出事件通知，执行其他的计算任务。

不过，考虑到真实的线上用户里无法直接使用 Performance，这也算是一个能做卡顿监控的方案。我们可以配合日志、其他不同的监控和上报等，来做更多的问题定位。