
# 白屏问题分析

首先定义什么是白屏，一般来说和first paint time(FP)和FCP FMP有关，从url请求开始，到第一次出现有意义画面（字符或元素）前那段空白的时间一般就是白屏。

白屏：
1.dom本身渲染构建时间过长，导致短期白屏。
2.js执行中，js执行耗时任务，阻塞后续页面dom的解析,渲染线程得不到控制权无法渲染。
长期耗时脚本执行，阻塞了渲染线程，dom渲染会被阻塞，虽然浏览器是分步渲染策略，但js有可能修改上面的dom，所以也不执行页面渲染。在耗时脚本执行过程中上部下部的dom都不会被页面渲染。
3.尤其是手机端，首屏加载前的网络延迟或者传输数据过大，导致关键js文件，静态资源css等加载时间过长，甚至失败，阻塞页面dom构建，导致白屏。

4.js语法不当如1.使用了es6的语法（如 let ），但是本身代码没有做es5的自动适配。2.引入了三方外部插件，外部插件语法存在兼容性问题

读取 undefined null 的属性，null.a;
对普通对象进行函数调用，const o = {}; o();
将 null undefined 传递给 Object.keys，Object.keys(null);
JSON 反序列化接受到非法值，JSON.parse({});

这些Uncaught SyntaxError出现后，同一个script下以后的代码都不会执行了。（不同script标签下的代码还是会执行）

js的error一般不会导致严重的dom渲染问题，但如果是react vue这样spa框架的bundle.js发生加载失败或者代码错误，会导致严重的白屏。

如react中：白屏时间内发生了什么？
用户按下回车，浏览器解析网址，DNS查询，通过IP发生HTTP请求。
服务端返回HTML，浏览器解析HTML，并在此过程中加载css和js。
执行js，创建各种DOM并渲染到根节点，直到第一个可视元素出现。所以要特别小心网站在使用react这类大型 JavaScript 包时可能对 LCP 产生的影响。如果您没有通过优化来加以阻止，那么在所有关键 JavaScript 完成下载和执行前，用户可能都无法看到页面上的任何内容或与之交互。

或者react中，代码执行异常报错导致页面代码崩溃，以后的代码不执行，导致相关dom操作未执行（react挂载dom）导致页面不可用的白屏。（React: By default, if your application throws an error during rendering, React will remove its UI from the screen。 ）

当 `<script>` 内的 JavaScript 代码出现错误时，页面的 DOM 通常仍然能正常展示。这是因为 JavaScript 是一种弱化耦合的语言，即使某个脚本出现错误，它通常不会对整个页面的渲染和 DOM 结构产生严重影响。浏览器会尽力保持页面的稳定性，使得用户能够继续与页面进行交互。
如异步代码错误，取不存在的变量值。
浏览器在渲染页面时通常会使用渐进渲染，这意味着它会尽快渲染页面的可见部分，而不会等待所有脚本执行完成。因此，即使某个脚本出现错误，已经渲染的部分仍然会显示在页面上。但如果页面就是由js动态渲染的，如react这些框架，js中有error，页面当然也不会有有效的渲染。

一个白屏例子：
react项目，html中html标签内首个元素是两个script标签，标签内js语法错误。
结尾body前给一个错误链接的script。
dev环境会把react相关bundle.js注入到head标签中
打开网页，两个script报错error会首先弹出到控制台。
但react相关bundle js的逻辑会正常走完。
走到错误链接script,请求一直pending中，也无法执行这个script，所以走不到构建render树渲染引擎绘制页面这一步，页面一直白屏。
一段时间后，这个script由pending状态变成failed，页面绘制出react动态构建的页面（包括写在react内的那些console才在控制台显示。）
但如果react代码内出现null.a这样的严重错误，后面的代码也都不会执行，页面白屏很正常。

从以下维度去优化：
过大的文件会拖慢加载速度。对应的解决方案就是压缩、拆包、treeshaking、差异化加载（es6+和es5双份资源，动态polyfill）、缓存等。
Chrome的并发限制数量为6，所以关键资源的数量过多也会加剧白屏时间。对应的解决方案就是删除、延迟、标记为异步、使用用http2等。
页面直出。大部分web应用的可视元素都是由js执行创建插入的，这个过程很明显是可以提前的。手段有服务端渲染、预渲染等。也可以给应用添加骨架屏、Loading指示等，也算是预渲染。
当然还有路由跳转之间的优化，可以开启preload、dnsprefetch、keep-alive等。

或许会有人认为，将静态资源扔到 CDN 上后就一劳永逸了。然而现实世界中，网络环境十分复杂，相同主机在不同线路、不同地区、不同时间段的可用性和访问质量是不同的，所以使用 CDN 不是解决这个问题的银弹，但是同时使用多个 CDN 或许是当前阶段比较通用的方案。

用户网络环境复杂，运营商劫持，国外访问CDN无效等等，这种情况下会导致白屏。

有通用的策略，也有针对webpack打包的针对性方案。不过这些方案总结来说，还是要实现2个大的功能：
1.识别资源加载失败
2.重新加载失败的资源


## 骨架屏
对于有骨架屏的页面，用户打开页面后，先看到骨架屏，然后再显示正常的页面，来提升用户体验；但如果页面从始至终都显示骨架屏，也算是白屏的一种。
需要通过外部传参明确的告诉 SDK，该页面是不是有骨架屏，如果有骨架屏，通过对比前后获取的 dom 元素是否一致，来实现骨架屏的白屏检测。



# 白屏监控
实际上所有的监测方案都在js能执行的情况下，而js线程被高耗时任务占据这种情况，无法上报。

方案一：监控页面主元素是否渲染：
主要可以通过关键节点是否渲染来监控，如body子元素，root节点下是否挂载。
或者mutationObserver这个api来监控页面dom变化。

但这个方案有几个缺陷

1）白屏不一定是 DOM 被卸载，也有可能是压根没渲染，且正常情况也有可能大量 DOM 被卸载

2）遇到有骨架屏的项目，若页面从始至终就没变化，一直显示骨架屏，这种情况 Mutation Observer 也束手无策


但react这样框架，需要判断是否为ErrorBoundaries兜底组件：
错误边界是 React 组件，它可以 在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ，而不是使整个组件树崩溃。
自 React 16 开始，任何未被错误边界捕获的错误将会卸载整个 React 组件树。

所以使用React 兜底组件可以避免白屏，兜底组件可以在整个H5统一使用同一个 class="error-boundary"的标识。
当判断有 class="error-boundary" 时也作为白屏进行上报，但在字段上报上需要做特殊标识，以区别正在的白屏。


方案二：页面截图监测
借助canvas截图，算法对比图片，如果有骨架屏，对比图还要换成骨架屏的图片。实现复杂，通用性也差。

方案三：采样对比
主要采用采样对比+白屏修正机制的主要流程：

1、页面中间取17个采样点，利用 elementsFromPoint api 获取该坐标点下的 HTML 元素。

2、定义属于容器元素的集合，如 ['html', 'body', '#app', '#root']

3、判断17这个采样点是否在该容器集合中。

4、若初次判断是白屏，开启轮询检测，来确保白屏检测结果的正确性，直到页面的正常渲染

```
// 监听页面白屏
function whiteScreen() {
  // 页面加载完毕
  function onload(callback) {
    if (document.readyState === 'complete') {
      callback();
    } else {
      window.addEventListener('load', callback);
    }
  }
  // 定义外层容器元素的集合
  let containerElements = ['html', 'body', '#app', '#root'];
  // 容器元素个数
  let emptyPoints = 0;
  // 选中dom的名称
  function getSelector(element) {
    if (element.id) {
      return "#" + element.id;
    } else if (element.className) {// div home => div.home
      return "." + element.className.split(' ').filter(item => !!item).join('.');
    } else {
      return element.nodeName.toLowerCase();
    }
  }
  // 是否为容器节点
  function isContainer(element) {
    let selector = getSelector(element);
    if (containerElements.indexOf(selector) != -1) {
      emptyPoints++;
    }
  }
  onload(() => {
    // 页面加载完毕初始化
    for (let i = 1; i <= 9; i++) {
      let xElements = document.elementsFromPoint(window.innerWidth * i / 10, window.innerHeight / 2);
      let yElements = document.elementsFromPoint(window.innerWidth / 2, window.innerHeight * i / 10);
      isContainer(xElements[0]);
      // 中心点只计算一次
      if (i != 5) {
        isContainer(yElements[0]);
      }
    }
    // 17个点都是容器节点算作白屏
    if (emptyPoints == 17) {
      // 获取白屏信息
      console.log({
        status: 'error'
      });
    }
  }
}
```


若首次检测页面为白屏后，任务还没有完成，特别是手机端的项目，有可能是用户网络环境不好，关键的JS资源或接口请求还没有返回，导致的页面白屏。

需要使用轮询检测，来确保白屏检测结果的正确性，直到页面的正常渲染，这就是白屏修正机制。
轮询代码：
```js
// 采样对比
function sampling() {
  let emptyPoints = 0;
  ……面正常渲染，停止轮询
  if (emptyPoints != 17) {
    if (window.whiteLoopTimer) {
      clearTimeout(window.whiteLoopTimer)
      window.whiteLoopTimer = null
    }
  } else {
    // 开启轮询
    if (!window.whiteLoopTimer) {
      whiteLoop()
    }
  }
  // 通过轮询不断修改之前的检测结果，直到页面正常渲染
  console.log({
    status: emptyPoints == 17 ? 'error' : 'ok'
  });
}
// 白屏轮询
function whiteLoop() {
  window.whiteLoopTimer = setInterval(() => {
    sampling()
  }, 1000)
}
```

或者：
```
// 监听页面白屏
export function blankScreen() {
    // 页面加载完毕
    function onload(callback) {
        if (document.readyState === 'complete') {
            callback();
        } else {
            window.addEventListener('load', callback);
        }
    }
    // 定义属于白屏元素的白屏点
    let wrapperElements = ['html', 'body', '#container', '.content'];
    // 白屏点个数
    let emptyPoints = 0;
    // 选中dom点的名称
    function getSelector(element) {
        if (element.id) {
            return "#" + element.id;
        } else if (element.className) {// a b c => .a.b.c
            return "." + element.className.split(' ').filter(item => !!item).join('.');
        } else {
            return element.nodeName.toLowerCase();
        }
    }
    // 是否是白屏点判断
    function isWrapper(element) {
        let selector = getSelector(element);
        if (wrapperElements.indexOf(selector) != -1) {
            emptyPoints++;
        }
    }
    // 页面加载完毕初始化
    onload(function () {
        for (let i = 1; i <= 9; i++) {
            let xElements = document.elementsFromPoint(
                window.innerWidth * i / 10, window.innerHeight / 2);
            let yElements = document.elementsFromPoint(
                window.innerWidth / 2, window.innerHeight * i / 10);
            isWrapper(xElements[0]);
            isWrapper(yElements[0]);
        }
        // 总共9个点超过7个点算作白屏
        if (emptyPoints >= 7) {
            let centerElements = document.elementsFromPoint(
                window.innerWidth / 2, window.innerHeight / 2
            );
            console.log('页面白屏',{
                kind: 'stability',
                type: 'blank',
                emptyPoints,
                screen: window.screen.width + "X" + window.screen.height,
                viewPoint: window.innerWidth + "X" + window.innerHeight,
                selector: getSelector(centerElements[0])
            });
        }
    });
}
```

## 判断时机和监控方式

1. 触发onerror时
大多数情况下出现白屏都是因为代码执行异常所导致，那我们可以在代码异常的监控中来判断是否白屏。
```
// JS错误
window.onerror = function (message, source, lineno, colno, error): void {
    checkWhiteScreen()            
}
// Promise错误
window.addEventListener('unhandledrejection', function (event) {
    checkWhiteScreen()       
})

*   message：错误信息（字符串）。可用于HTML onerror=""处理程序中的event。
*   source：发生错误的脚本URL（字符串）
*   lineno：发生错误的行号（数字）
*   colno：发生错误的列号（数字）
*   error：Error对象
```

也可以在script 上添加onerror属性触发加载失败回调捕捉异常。
借助构建工具 ( 如 webpack 的 script-ext-html-webpack-plugin 插件) ，我们可以轻易地完成对所有 script 标签自动化注入 onerror 标签属性。
```
new ScriptExtHtmlWebpackPlugin({
    custom: {
      test: /\.js$/,
      attribute: 'onerror',
      value: 'onError(this)'
    }
 })
```

或者在window监听error，注意这些监听代码要在所有script之前。
```
window.addEventListener('error', function(event) { ... })

当资源（如img或script）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，但可以在捕获阶段被捕获
因此如果要全局监听资源加载错误，需要在捕获阶段捕获事件
//图片加载失败使用默认图片，依旧加载失败超过三次使用base64图片
window.addEventListener('error',function(e){
    let target = e.target, // 当前dom节点
        tagName = target.tagName,
        count = Number(target.dataset.count ) || 0, // 以失败的次数，默认为0
        max= 3; // 总失败次数，此时设定为3
    // 当前异常是由图片加载异常引起的
    if( tagName.toUpperCase() === 'IMG' ){
        if(count >= max){
            target.src = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//AK3/ALYH+5hX6FV5N4Y/5GHwx/vyf+iJa9ZrysPhoYVShDZu/potDmwWFhhIzhT2bv6aLQ//Z';
        }else{
            target.dataset.count = count + 1;
            target.src = '//xxx/default.jpg';
        }
    }
},true)
```
利用addEventListener在捕获阶段获得错误，通过判断e不是ErrorEvent来判断是资源加载错误。但是这个错误不能判断资源是404还是网络问题，都统一返回一个error。如果需要知道具体的问题，还需要通过ajax请求一次这个出错的资源，才能知道具体问题（是404、域名解析不了、服务不可用、还是加载超时等）

window.onerror是一个全局变量，默认值为null。当有js运行时错误触发时，window会触发error事件，并执行window.onerror()。onerror可以接受多个参数。

监听js运行时错误事件，会比window.onerror先触发，与onerror的功能大体类似，不过事件回调函数传参只有一个保存所有错误信息的参数，不能阻止默认事件处理函数的执行，但可以全局捕获资源加载异常的错误。


2. 定时3秒后进行检查
有时JS代码并没有报错，但是因接口数据没有活动到，前端也没有设置默认数据时，也会出现白屏，此时没有onerror触发，可以通过设置定时器触发白屏检测。
```
const timer = setTimeout(() => {
    clearTimeout(timer)
    checkWhiteScreen()    
}, 3000)
```
当以上两种时机触发时，就可以去执行判断白屏的逻辑，当发现判断白屏的三个条件都成立，这判定为白屏，就可进行上报。


# 计算白屏时间
通常认为浏览器开始渲染 <body> 标签或者解析完 <head> 标签的时刻就是页面白屏结束的时间点。

可使用 Performance API 时
白屏时间 = firstPaint - performance.timing.navigationStart;

不可使用 Performance API 时
白屏时间 = firstPaint - pageStartTime;




## 重新加载失败的资源

### 加载失败时，刷新页面 (reload）

当资源加载失败时，刷新页面可能是最简单直接的尝试恢复方式。当监控到资源加载失败时，我们通过 location.reload(true) 强制浏览器刷新重新加载资源（全部重载页面，不太好），并且为了防止出现一直刷新的情况，结合了 SessionStorage 限制自动刷新次数。

### 针对加载失败的文件进行重加载
css资源和js资源都是通过dom标签加载的，所以实现方案上可以统一，流程都是识别所有的dom，然后把对应链接里的CDN域名提高为新的域名，再把得到的新链接生成dom重新插入到页面中，利用浏览器的并行加载，顺序执行重新执行一遍这些资源。（如果出现部分js资源失败，部分成功。重新加载全部资源，可能会导致某些js执行出错，如果这些js文件不支持多次执行的话。我们这里不对这种情况做讨论，指考虑统一失败的情况，加载所有资源都使用了相同的CDN，且这些js都支持多次重复执行。）

替换域名动态重加载。然而，失败资源重加载成功后，页面原有的加载顺序可能发生变化，最终执行顺序发现变化也将导致执行异常。
在不需要考虑兼容性的情况下，资源加载失败时通过 document.write 写入新的 script 标签，可以阻塞后续 script 脚本的执行，直到新标签加载并执行完毕，从而保证原来的顺序。
于是我们需要增加 “管理 JS 执行顺序” 的逻辑。使 JS 文件加载完成后，先检查所依赖的文件是否都加载完成，再执行业务逻辑。当存在加载失败时，则会等待文件加载完成后再执行，从而保证正常执行。

手动管理模块文件之间的依赖和执行时机存在着较大的维护成本。而实际上现代的模块打包工具，如 webpack ，已经天然的处理好这个问题。通过分析构建后的代码可以发现，构建生成的代码不仅支持模块间的依赖管理，也支持了上述的等待加载完成后再统一执行的逻辑。
```
// 检查是否都加载完成，如是，则开始执行业务逻辑
function checkDeferredModules() {
    // ...
    if(fulfilled) {
        // 所有都加载，开始执行
        result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
    }
}
```

然而，在默认情况下，业务代码的执行不会判断配置的 external 模块是否存在。所以当 external 文件未加载完成或加载失败时，使用对应模块将会导致报错。
所以我们需要在业务逻辑执行前，保证所依赖的 external 都加载完成。最终通过开发 wait-external-webpack-plugin webpack 插件，在构建时分析所依赖的 external，并注入监控代码，等待所有依赖的文件都加载完成后再统一顺序执行。
