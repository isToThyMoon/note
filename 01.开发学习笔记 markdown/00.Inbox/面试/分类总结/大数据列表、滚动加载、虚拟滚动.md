# 

antd中叫虚拟列表，引入react-window实现。


有这种需求一定是大数据量dom。一般就是表格。要做表格首先要选择基于 DOM 还是 Canvas，Canvas 渲染效率比 DOM 高，这是浏览器实现导致的。这里主要探讨dom渲染的表格如何提高性能。

大量数据一次插入dom造成页面迟迟得不到渲染。

或者做一些修改后更新dom，都会有轻则瞬间白屏，重则页面卡死无响应的性能问题。如何解决？

渲染dom太多，大量的重排重绘。思路都是减少dom渲染的数量。

首先分页。常规想法，需要后端做分页或者前端拿到所有数据后前端做分页，但有些场景就是没有分页或者不需要分页。

或者requestAnimationFrame以帧的频率更新数据。

无法分页，滚动加载（懒加载）(但有个缺点，如果加载多了改动布局的时候仍然会卡顿)，实现方法多样，比较有意思的方式是IntersectionObserver监听dom元素与父元素的交叉情况（进入退出视窗），处理图片懒加载，组件懒加载。

缺点是只有滚动到某位置才会加载下一页。

更高要求就是写一个虚拟滚动(仅渲染视窗显示区域内的表格dom)。一个不太完美的例子：vue2实现：https://juejin.cn/post/6844903982742110216

而且为了滚动丝滑且无白屏，预留一些 Buffer 区域用于滑动时填充，表格仅渲染可视区域与 Buffer 区域部分。但这些方案都不可避免的存在快速滑动时白屏问题。

社区实现的虚拟滚动库有react-window，作者以前写了react-virtualized，react-window是一个全新、更小、更稳定的重写版本。





# 如何完美解决快速滑动白屏问题？


https://cloud.tencent.com/developer/article/1865797

单元格使用 DIV 绝对定位，所有单元格位置都要提前计算，这里可以利用 web worker 做并行计算


即不要使用原生的滚动条，而是使用 .scroll 绘制一个div代替滚动条，用 wheel事件 监听滚动的触发，然后去执行布局，而不是在onScroll中。
原因是用js控制触发的滚动发生在渲染完成之后，所以浏览器会在滚动发生前现完成渲染，这相当有趣。
当我们采用模拟滚动方案时，相当于采用了在滚动时 “高频渲染” 的方案，因此不需要使用截留，更不要使用 Buffer 区域，因为更大的 Buffer 区域意味着更大的渲染开销。
当然，滚动过快依然不是一件好事，既然滚动是由我们控制的，可以稍许控制下滚动速度，控制在每次触发 mousewheel 位移不超过 200 左右最佳。

预计算
像单元格合并、行列隐藏、单元格格式化等计算逻辑，最好在滚动前提前算掉，否则在快速滚动时[实时计算](https://cloud.tencent.com/product/oceanus?from=20065&from_column=20065)必然会带来额外的计算成本损耗。

但是这种预计算也有弊端，当单元格数量超过 10w 时，计算耗时一般会超过 1 秒，单元格数量超过 100w 时，计算耗时一般会超过 10 秒，用预计算的牺牲换来滚动的流畅，还是有些遗憾，我们可以再思考以下，能否降低预计算的损耗？

局部预计算
局部预计算就是一种解决方案，即便单元格数量有一千万个，但我们如果仅计算前 1w 个单元格呢？那无论数据量有多大，都不会出现丝毫卡顿。

但局部预计算有着明显缺点，即表格渲染过程中，局部计算结果并不总等价于全局计算结果，典型的有列宽、行高、跨行跨列的计算字段。

我们需要针对性解决，对于单元格宽高计算，必须采用局部计算，因为全量计算的损耗非常大。但局部计算肯定是不准确的，如下图所示：