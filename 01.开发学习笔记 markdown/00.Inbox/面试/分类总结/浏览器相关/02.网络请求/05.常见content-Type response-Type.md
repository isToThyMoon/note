---
title: 07.http协议常见content-Type response-Type
categories:
  - 01.开发学习笔记 markdown
  - 07.前端
  - 00.网络相关
---

HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据，

HTTP 协议是以 ASCII 码传输(为什么常常url要转码，因为http协议的编码方式)，建立在 TCP/IP 协议之上的应用层规范。

协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式（content type）。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。

# content-type介绍
content-type格式为 Content-Type: type/subtype;parameter;如 text/html;charset:tf-8;
主类型type: text文本类型 application应用类型 *所有类型
子类型subtype: html xml json 和 *所有格式
参数parameter 常用的是编码参数 charset:utf-8;
常见主子类型： 
text/plain 纯文本格式 text/html html格式 image/png png图片格式
application/json json格式
application/octet-stream 二进制流数据（常见文件下载）
...

## 普通get请求 
携带url参数，不需要参数存放在请求体的请求,报文也都没有content-type，因为也确实不需要，请求的body里没有数据。
get请求，查看devtool的payload类型是Query String Parameters。就是url查询参数的意思。
格式大致如此：?a=1&b=2&c=1

当然，超文本传输协议只规定了有请求头 Header 请求体这三部分，你如果非要在get请求的body里塞东西，在代码的实际实现上也完全没有什么问题，所谓的get post put等请求只是一种规则的约定，你最好这么做。

## post提交 主要最常用的有三种提交content-type：

### 默认表单提交application/x-www-form-urlencoded
Content-Type: application/x-www-form-urlencoded
这种提交方式在devtool查看XHR详情，payload区域显示请求体内容：
Payload:(Form Data):
a=1&b=2

payload类型是Form Data，其实就是这些被& =连接的序列化后的键值对。

浏览器的原生form表单，如果不设置 `enctype` 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。
实际上大部分情况都使用它即可，编码方式足够简单高效，各方面支持也都很完备，如各大浏览器调试工具、各大抓包软件等。
提交的数据按照 key1=val1&key2=val2 的方式进行编码，key和val都进行了URL转码

```
POST http://www.example.com HTTP/1.1 
Content-Type: application/x-www-form-urlencoded;charset=utf-8 

key1=val1&key2=val2
```

基本的请求类似上面这样，数据的编码方式采用 key1=val1&key2=val2 的形式，对其中的键值对都需要使用 URL Encode 编码一下。其实就是和 GET 请求的数据提交格式是一样的，只不过位置从 Request URL 上换到了 Request Body 里。

这种格式结构简单，但对于数据层级较深的情况，比如一些有复杂层级关系的接口数据，这种方式就显得有点力不从心了。另一方面，对于需要上传二进制数据（比如图像、音频等文件），这种方式就不那么高效了，而且对于非 ASCII 码的数据就丢失了，所以传文件的情况就不能使用这种方式。

适用场景：数据量不大、数据层级不深的情况下强烈建议这种数据提交格式

很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。

#### 在axios中模拟这种提交方式:

```
axios.post( url, { a:1, b:2 }, {
    // content-type默认就是application/x-www-form-urlencoded；可以不设置header
    // 设置请求前序列化data
    transformRequest: (data={})=> Object.entries(data).map(ent=> ent.join("=")).join("&"),
})
```
或者直接用第三方qs库序列化 把js对象序列化为 & = 连接的?key=value字符串
```
axios.post(url, qs.stringify({...}), options)
```
这两种方式通过devtool查看payload的类型都是Form Data

### 表单上传文件的需求multipart/form-data
Content-Type: multipart/form-data
通过devtool查看payload的类型都是Form Data

常见的 POST 数据提交的方式。
FormData对象将数据编译成键值对，以XMLHttpRequest来发送数据，主要用于发送表单数据（表单上传文件时，让 form 的enctype="multipart/form-data"），亦可用于发送带键数据（keyed data），而独立于表单使用。

当你需要提交文件、非 ASCII 码的数据或者是二进制流数据，则使用这种提交方式。

```
<form action="/" method="post" enctype="multipart/form-data">
  <input type="text" name="description" value="some text">
  <input type="file" name="myFile">
  <button type="submit">Submit</button>
</form>
```

```
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="description"

some text
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="myFile"; filename="chrome.png"
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
```

Content-Type 里指明了数据是以 multipart/form-data 来编码，生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。作用是分割不同的字段。

消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 `--boundary` 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 `--boundary--` 标示结束。

除了能通过表单来发起multipart/form-data请求，也可以通过js创建form-data对象来发送请求。

```
var formData = new FormData();

formData.append("username", "Groucho");
formData.append("accountnum", 123456); //数字 123456 会被立即转换成字符串 "123456"

// HTML 文件类型 input，由用户选择
formData.append("userfile", fileInputElement.files[0]);

// JavaScript file-like 对象
var content = '<a id="a"><b id="b">hey!</b></a>'; // 新文件的正文
var blob = new Blob([content], { type: "text/xml"});

formData.append("webmasterfile", blob);

var request = new XMLHttpRequest();
request.open("POST", "http://foo.com/submitform.php");
request.send(formData);
```

#### 在axios中模拟这种提交方式:
需要传入的data必须是FormData()类型，否则无法识别payload
headers在axios设置里可设可不设，会自动识别出传入数据是FormData类型自动设置。
```
const formData = new FormData();
formData.append('name', 'didi')

axios.post(url, formData, {
    headers:{
        'Content-Type': 'multipart/form-data'
    }
})
```

上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 `<form> `表单也只支持这两种方式（通过` <form> `元素的 `enctype` 属性指定，默认为 `application/x-www-form-urlencoded`。其实 `enctype` 还支持 `text/plain`，不过用得非常少）。

随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。

### json提交application/json
Content-Type: application/json

告诉服务端消息主体是序列化后的 JSON 字符串，这个类型越来越多地被大家所使用

除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数。

这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。

```
POST http://www.example.com HTTP/1.1 
Content-Type: application/json;charset=utf-8 

{"title":"test","sub":[1,2,3]}
```

## 除post外 其他不常用content-type

text/xml
是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范
```
POST http://www.example.com HTTP/1.1 
Content-Type: text/xml 
<!--?xml version="1.0"?--> 
<methodcall> 
    <methodname>examples.getStateName</methodname> 
    <params> 
        <param> 
            <value><i4>41</i4></value> 
    </params> 
</methodcall> 
```

XML-RPC 
协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。

text/html text/plain



# 设置content-type
1.在发送请求的页面header
<meta content="text/html" charset="utf-8">
这种方式不能指定 application/x-www-form-urlencoded和multipart/form-data两种类型

2.在form表单的enctype参数中
只能指定application/x-www-form-urlencoded和multipart/form-data这两种类型
默认第一种，浏览器会把表单中发送的数据编码为'key=value'对的形式
form-data常用上传文件。

3.直接设置在request-header参数中
无限制
xhr.send(data)中的data数据类型会影响请求头部content-type的默认值
如果使用xhr.setRequestHeader()手动设置了content-type的值，默认值会被覆盖。
```js
var str = 'DOMString等同于js中的普通字符串'；
var xhr = new XMLHttpRequest();
xhr.open('post', '/server', true);
xhr.onload=function(e){};
//xhr.send(data)的参数str是DOMString类型 content-type会默认为text/plain;charset=UTF-8;
xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8')
xhr.send(str)
```

-------

# 响应 responseType
responseType值          xhr.responseType数据类型   
""                      String
"text"                  String
"document"              Document
"json"                  js对象
"blob"                  Blob对象
"ArrayBuffer"           ArrayBuffer对象