---
title: 14.jsonp和ajax axios
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 00.浏览器相关
---

XMLHttpRequest 在 1999 年首次作为非标准的 Internet Explorer 5.0 ActiveX 组件出现，微软开发它是为了支持基于浏览器的 Outlook 版本，XML 是当时最流行（或被宣扬）的数据格式，除此之外，XMLHttpRequest 还支持文本和尚未发明的 JSON。

Jesse James Garrett 在他 2005 年的文章《AJAX: Web 应用程序的新方法》中提出了“AJAX”概念，那时谷歌邮箱和谷歌地图等基于 AJAX 的应用程序已经存在，但是这个术语激励了开发人员，并引起了流畅的 Web 2.0 体验爆炸式增长。

AJAX 是“Asynchronous JavaScript and XML”的缩写，尽管严格地说，开发人员并不需要使用异步方法、JavaScript 或 XML。我们现在将通用的“Ajax”术语表示任何从服务器获取数据、更新 DOM 而无需刷新整个页面的客户端过程。

所有主流浏览器都支持 XMLHttpRequest，并在 2006 年成为官方（ecmascript）的 web 标准。

# JSONP
JSON Padding
其实是动态创建script标签来请求资源
它的特点是一般返回一段JavaScript

script标签请求 是不受域名限制的，任何一个网站都可以使用其他网站的script

请求方：网站的前端（浏览器）
响应方：另一个网站的后端（服务器）
1.请求方创建script 它的src指向响应方 同时传一个查询参数src="http://aaa.com/dada.js?callbackName=yyy"
2.响应方根据查询参数callbackName构造形如

```    
yyy.call(undefined, '你要的数据')
这样的携带数据的响应
设置响应的Content-Type 为'application/javascript'
```

3.浏览器接受到响应，就会执行yyy.call(undefined, '你要的数据')
4.那么请求方就知道他要的数据"你要的数据"了。

这就是jsonp

一般形成约定：callbackName就是callback -> callback
yyy -> 随机数

前端：
```js
<script>
  button.addEventListener('click', function (e) {
    let script =document.createElement('script');
    let functionName = 'dadada' + parseInt(Math.random()*100000, 10);

    window[functionName] = function(result){
      if(result==='success'){
        amount.innerText = amount.innerText - 1;
      }else{

      };
    };

    script.src = 'http://summeres.site:8080/pay?callback=' + functionName;
    document.body.appendChild(script);
    
    script.onload = function(e){
      e.currentTarget.remove();
      delete window[functionName];
    }

    script.onerror = function(e){
      alert('fail');
      e.currentTarget.remove();
      delete window[functionName];
    }

  })
</script>
```

后端判断路径：
根据查询参数callbackName构造形如yyy.call(undefined, '你要的数据')
那么前端接收到这个script就会执行yyy.call(undefined, '你要的数据')。注意这里的yyy函数名是前端之前生成的随机数

后台不关心前台需要对什么具体的按钮、文字进行什么操作，这部分操作由前端来写好一个操作函数，后台通过收到script请求，验证后返回，调用这个函数就好。这个也是解耦。

```js
if(path == '/pay'){
    response.setHeader('Content-Type', 'text/javascript; charset=utf-8')
    response.statusCode = 200
    response.write('yyy.call(undefined, '你要的数据')')
    response.end()
```



用jquery来写 使用jsonp：
其实就是整合好了上面的代码。
```js
$.ajax({
  url:"http://summeres.site:8080/pay",
  dataType: "jsonp",
  success: function(response) {
    console.log(response);
  }
})
```
这里ajax字样会误导，实际上jsonp和ajax没有任何关系。


     
# ajax
AJAX不是JavaScript的规范，它只是一个缩写
Asynchronous JavaScript and XML  
意思就是用JavaScript执行异步网络请求
用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应。
在现代浏览器上写AJAX主要依靠XMLHttpRequest对象：

```javascript
function success(text) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById('test-response-text');
    textarea.value = 'Error code:' + code;
}

var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象

request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open('GET', '/api/categories');
request.send();

alert('请求已发送，请等待响应...');

```
除了用onreadystatechange还可以用onload属性
readystatechange 事件先于 load 事件执行。load 事件就相当于 readyState 的值为 4 后触发的事件。如果不需要跟踪请求返回之前的过程时，用 load 事件更省事儿。




创建 AJAX 对象
var r = new XMLHttpRequest()

设置请求方法和请求地址
r.open('GET', '/login', true)

注册响应函数
r.onreadystatechange = function() {
    if(r.readyState == 4) {
        console.log('请求成功', r.responseText.length)
    }
}
发送请求
r.send()



```js
// 发送登录数据
// 创建 AJAX 对象
var r = new XMLHttpRequest()
// 设置请求方法和请求地址
r.open('POST', '/login', true)
// 设置发送的数据的格式
r.setRequestHeader('Content-Type', 'application/json')
// 注册响应函数
r.onreadystatechange = function() {
    if (r.readyState === 4) {
        console.log('state change', r, r.status, r.response)
        var response = JSON.parse(r.response)
        console.log('response', response)
    } else {
        console.log('change')
    }
}
// 发送请求
var account = {
    username: 'gua',
    password: '123',
}
var data = JSON.stringify(account)
r.send(data)

```



```js
// 可以封装成这样的一个函数
var ajax = function(method, path, headers, data, reseponseCallback) {
    var r = new XMLHttpRequest()
    // 设置请求方法和请求地址
    r.open(method, path, true)
    // 设置发送的数据的格式
    r.setRequestHeader('Content-Type', 'application/json')
    // 注册响应函数
    r.onreadystatechange = function() {
        if(r.readyState === 4) {
            reseponseCallback(r)
        }
        // if (r.readyState === 4) {
        //     console.log('state change', r, r.status, r.response)
        //     var response = JSON.parse(r.response)
        //     console.log('response', response)
        // } else {
        //     console.log('change')
        // }
    }
    // 发送请求
    r.send(data)
}


ajax('GET', '/login', null, '', function(r){
    console.log(r.status, r.response)
})

ajax('GET', 'https://api.douban.com/v2/book/1220562', null, '', function(r){
    // console.log(r.status, book)
    var book = JSON.parse(r.response)
    var imgUrl = book.image
    var body = document.querySelector('body')
    var img = `
        <img src=${imgUrl}>
    `
    body.insertAdjacentHTML('beforeend', img)
})


// GET /v2/movie/subject/1764796
ajax('GET', '/v2/movie/subject/1764796', null, '', function(r){
    // console.log(r.status, book)
    var movie = JSON.parse(r.response)
    console.log(movie)
    // var imgUrl = book.image
    // var body = document.querySelector('body')
    // var img = `
    //     <img src=${imgUrl}>
    // `
    // body.insertAdjacentHTML('beforeend', img)
})
```

jquery写ajax：

```
$ajax({
    url: '',
    method: 'post'
})

$post('url', data)
$get('url',)
```

# axios
2016年出现，
一个js库，几乎照抄了jquery的ajax的用法。

promise based HTTP client for the browser and node.js

好处在于：
1.更完善的请求：
axios(config)
axios(url[, config])

----------------------分割线----------------------
axios.request(config)
axios.get(url[, config])
axios.delete(url[, config])
axios.head(url[, config])
axios.options(url[, config])
axios.post(url[, data[, config]])
axios.put(url[, data[, config]])
axios.patch(url[, data[, config]])

分割线下的方法其实都是axios(config)的变种，语法糖写法。

比jquery.ajax功能更多

2.只有ajax功能，功能更加专注。 

jquery的ajax功能由axios接替

而关于dom的操作 如获取dom 添加class等等 由于进程的发展被react vue这些不直接操作dom的框架代替
jquery才说退出了历史。

```JavaScript
axios.get('/api/home.json').then((res) => {
            const result = res.data.data;
			dispatch(changeHomeData(result));
        }).catch(()=>{
        });
```
或

```JavaScript
return new Promise((resolve, reject)=>{
	axios({
		url: options.url,
		method: options.method || 'get',
		baseURL: baseApi,
		timeout: 5000,
		params: options.params || '',  //是个无格式对象(plain object)或 URLSearchParams 对象
		//post请求是data
		data: options.data || ''
	})
	.then((response)=>{
		// console.log(response)
		if (options.data && options.data.isShowLoading !== false){
			loading =document.querySelector('#ajaxLoading');
			loading.style.display ='none';
		}
		if (response.status === 200){
			let res = response.data;
			if (res.code === 0){
				resolve(res);
			}else{
				Modal.info({
					title: '提示',
					content: res.msg
				})
			}
		}else{
			reject(response.data);
		}
	})
})
```

## 使用

get请求的参数一般是拼接到url上，所以我们在axios中会用 params这个配置来携带我们请求参数
post请求的参数一般是放在请求体里面的，所以我们会在axios中使用 data 这个配置来表示我们的请求参数

### 全局默认配置
我们可以直接在 axios.default上进行默认配置
// 全局默认配置
axios.defaults.baseURL = 'https://api.example.com';
axios.defaults.timeout = 1000 * 5


### axios实例配置
axios有一个create方法，返回的其实还是一个axios对象，但是我们在create中可以指定一些默认配置，返回的实例对象使用的时候就会遵循这些默认配置。
// axios实例默认配置
const request = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 1000 * 8
});





返回包装对象介绍
axios在返回值的时候，是会默认的对我们的这次请求进行一次包装。
```js
{
  // 请求响应的返回值
  data: {},
  // 请求状态
  status: 200,
  // 状态说明文字
  statusText: 'OK',
  // 请求的请求头
  headers: {},
  // 这次请求用到的 配置  指 刚刚问题一的配置
  config: {},
  // 请求实例  表示 axios 底层 封装的 XMLHttpRequest 的信息
  request: {}
}
```
一般来说，我们在使用时需要做对返回对象的判断封装，一般就是判断status和data的内容。

### 封装拦截
```
const request = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 1000 * 8
});

request.interceptors.response.use(function(response){
    let config = response.config //这里存的是请求的信息
    let {method, url, data } = config //data是请求的data
    ...
    return response
}, function(err){
    return Promise.reject(err)
});
```

# mock
axios有自己的mock功能，在作请求返回响应时中途拦截，对response作修改，使得你调试时无需写后端代码。

```
axios.interceptors.response.use(function(response){
    let config = response.config //这里存的是请求的信息
    let {method, url, data } = config //data是请求的data
    if(url === '/book/1' && method === 'get'){
        response.data = {
            name: 'dadada'
        }
    }
    return response
});

axios.get('/book/1')
    .then((response)=>{
        console.log(response)
    })
```