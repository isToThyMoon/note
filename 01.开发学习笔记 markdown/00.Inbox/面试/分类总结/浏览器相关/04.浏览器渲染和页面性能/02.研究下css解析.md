## CSS对DOM树构建和渲染的影响

来看看最简单的渲染流程：
案例：
```
//theme.css
div{
color : coral;
background-color:black
}
​
<html>
<head>
    <link href="theme.css" rel="stylesheet">
</head>
<body>
    <div>dididi</div>
    <script>
        console.log('time')
    </script>
    <div>dadada</div>
</body>
</html>
```

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/463a067369a9425fac1ccf54aeeac800~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)


首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染线程（渲染引擎）会解析 HTML 数据并构建 DOM。

早期版本浏览器这里你需要特别注意请求 HTML数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。但目前浏览器都采用一边请求一边构建，不会等到html文件全部下载完，当接收到html子节流时，网络进程就和渲染进程打通，一边接收数据，一边渲染引擎就开始解析。

我们提到过，当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。

和HTML DOM一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是CSSOM。

和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是document.styleSheets。具体结构可以去查阅相关资料，就不过多介绍了，你知道CSSOM的两个作用是怎样的就行了。（概念性东西，除了渲染流程以外不会再碰到了。）

有了 DOM 和 CSSOM，接下来就可以合成布局树了。

布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染树其实就构建完毕。

再往后就是layout 和 实际绘制了。

# CSSOM树
大体上来说，CSSOM 是一个建立在 Web 页面上的 CSS 样式的映射，它和 DOM 类似，但是只针对 CSS 而不是 HTML，浏览器将 DOM 和 CSSOM 结合来渲染 Web 页面。
![](https://raw.githubusercontent.com/heptaluan/blog-backups/master/cdn/js/37-08.png)


CSSOM 将样式表中的规则映射到页面对应的元素上，虽然 CSSOM 采取了复杂的措施来做这件事，但是 CSSOM 最终的功能还是将样式映射到它们应该对应的元素上去，更确切地说，CSSOM 识别 tokens 并把这些 Tokens 转换成一个树结构上的对应的结点，所有结点以及它们所关联的页面中的样式就是所谓的 CSS Object Model，从上面的渲染机制可以看出，CSSOM 对于 Web 页面的展示起着重要作用。

其实我们不必为了优化 Web 页面而去了解 CSSOM 是怎样工作的，这里有几个关于 CSSOM 的关键点是我们需要知道的，利用这些关键点可以优化页面的加载速度

* CSSOM 阻止任何东西渲染
* CSSOM 在加载一个新页面时必须重新构建
* 页面中 CSS 的加载和页面中 JavaScript 的加载是有关系的

下面我们就分别来看看以上三种情况：

1. CSSOM 阻止任何东西渲染

所有的 CSS 都是阻塞渲染的（意味着在 CSS 没处理好之前所有东西都不会展示），具体的原因是如果浏览器在 CSS 检查之前展示了页面，那么每个页面都是没有样式的，等一会之后又突然有了样式，整个页面的体验就会很糟糕。

由于 CSSOM 被用作创建 Render Tree，那么如果不能高效的利用 CSS 会有一些严重的后果，而主要的后果就是我们的页面在加载时白屏。

2. CSSOM 在加载一个新页面时必须重新构建，和有没有缓存css资源无关

这意味着即使我们的 CSS 文件被缓存了，也并不意味着这个已经构建好了的 CSSOM 可以应用到每一个页面，当用户跳到我们的另一个页面时（即使浏览器缓存了所有需要的 CSS），CSSOM 也必须重新构建一遍，也就是说，如果我们的 CSS 文件写得很蹩脚，或者体积很大，这也会对我们页面加载产生负面的影响。

1. 页面中 CSS 的加载和页面中 JavaScript 的加载是有关系的

简单来说，CSSOM 是展示任何东西的必需品，在 CSSOM 构建之前，所有东西都不会展示。
JavaScript 的加载执行必须等待CSSOM的构建完成，因为js有可能会操作CSSOM信息，为了避免闪烁和混乱，css加载执行会阻塞JS的执行。简

* 如果我们阻塞了 CSSOM 的构建（css文件过大），CSSOM 的构建就会消耗更长的时间，这就意味着页面的渲染也需要更长的时间
* 如果CSSOM 的构建阻塞过长时间让JavaScript等待执行，用户就会面对更长时间的白屏。


# 如何解析 CSS 选择器
浏览器会『从右往左』解析 CSS 选择器，我们知道 DOM Tree 与 Style Rules 合成为 Render Tree，实际上是需要将 Style Rules 附着到 DOM Tree 上，因此需要根据选择器提供的信息对 DOM Tree 进行遍历，才能将样式附着到对应的 DOM 元素上，我们以下面这段 CSS 为例

`.mod-nav h3 span {font-size: 16px;}`

对应的 DOM Tree 如下：
![](https://raw.githubusercontent.com/heptaluan/blog-backups/master/cdn/js/37-14.png)

若从左向右的匹配，过程是

* 从 .mod-nav 开始，遍历子节点 header 和子节点 div
* 然后各自向子节点遍历，在右侧 div 的分支中，最后遍历到叶子节点 a，发现不符合规则
* 所以需要回溯到 ul 节点，再遍历下一个 li-a，一颗 DOM 树的节点动不动上千，所以可以发现这种效率很低

如果从右至左的匹配

* 先找到所有的最右节点 span，对于每一个 span，向上寻找节点 h3
* 由 h3 再向上寻找 .mod-nav 的节点
* 最后找到根元素 html 则结束这个分支的遍历

两者对比下来，可以明显的发现后者匹配性能更好，是因为从右向左的匹配在第一步就筛选掉了大量的不符合条件的最右节点（叶子节点），而从左向右的匹配规则的性能都浪费在了失败的查找上面


# 性能优化
CSS 优化，<link> 标签的 rel 属性中的属性值设置为 preload 能够让我们在 HTML 页面中可以指明哪些资源是在页面加载完成后即刻需要的，最优的配置加载顺序，提高渲染性能。




# CSS加载出现阻塞会如何？例如HTML文档10ms css加载10S
当一个 CSS 文件在加载过程中出现阻塞，即 HTML 文档需要等待 CSS 文件加载完成后才能继续渲染，会导致以下现象：

1. **页面加载时间延长**：如果 CSS 文件较大或加载速度较慢，阻塞加载可能会显著延长页面的加载时间。这将影响用户体验，尤其是在慢速网络环境下。

2. **呈现页面闪烁**：如果页面在 CSS 文件加载前已经开始渲染，但没有样式信息，可能会导致页面以未样式化的形式呈现（称为 FOUC，Flash of Unstyled Content），然后在 CSS 文件加载完成后进行样式化，导致页面闪烁。

3. **页面渲染阻塞**：在默认情况下，浏览器会等待 CSS 文件加载完成后再开始渲染页面，因为它需要正确应用样式规则。这可能导致页面渲染的阻塞。

在你提到的情况中，如果 HTML 文档需要等待 10 秒钟才能加载 CSS 文件，用户将面临长时间等待的情况，这通常会导致不良的用户体验。浏览器的加载进度可能会显示很长时间，直到 CSS 文件加载完成。

为了减轻这种情况的影响，可以采取以下一些方法：

1. **优化 CSS 文件**：确保 CSS 文件是经过压缩和精简的，以减少文件大小。使用工具来优化 CSS 文件，如压缩、合并和减少请求次数。

2. **异步加载**：将 CSS 文件异步加载，使页面能够尽快开始渲染，而不必等待 CSS 文件加载完成。这可以通过使用 JavaScript 动态创建 `<link>` 标签来实现。

3. **分离关键样式**：将关键的样式信息内联到 HTML 文档的 `<style>` 标签中，以确保页面的关键部分能够快速加载和呈现。这样可以减少 FOUC 的风险。

4. **使用浏览器缓存**：利用浏览器的缓存机制，确保 CSS 文件在后续访问时能够更快地加载。

5. **CDN 加速**：将 CSS 文件托管在内容分发网络（CDN）上，以提高文件的加载速度。

通过这些方法，可以改善页面加载性能，减少用户等待时间和提供更好的用户体验。