# 渐进式重构 MutationObserver

选择产品目录功能，旧jsp实现方式就是在A页面点击新开页面B，B页面选择后通过window.opener.document 触发相应回调，并且修改A页面隐藏元素dom数据。

可能有其他老项目使用，完全在react组件中照搬相应逻辑，回调等等，
但对修改A页面隐藏input数据这样，在didMount阶段，通过MutationObserver监听变化并将数据同步到组件状态中。
```js
var observer = new MutationObserver(callback);


function callback(mutationList, observer) {
  mutationList.forEach((mutation) => {
    switch(mutation.type) {
      case 'childList':
        /* 从树上添加或移除一个或更多的子节点；参见 mutation.addedNodes 与
           mutation.removedNodes */
        break;
      case 'attributes':
        /* mutation.target 中某节点的一个属性值被更改；该属性名称在 mutation.attributeName 中，
           该属性之前的值为 mutation.oldValue */
        break;
    }
  });
}
```

```js
var targetNode = document.querySelector("#someElement");
var observerOptions = {
  childList: true,  // 观察目标子节点的变化，是否有添加或者删除
  attributes: true, // 观察属性变动
  subtree: true     // 观察后代节点，默认为 false
}

var observer = new MutationObserver(callback);
observer.observe(targetNode, observerOptions);
```

调用 observe() 即可开始观察 DOM。当观察者 observer 发现匹配观察请求中指定的配置项的更改时，callback() 方法便会被调用。
从现在开始直到调用 disconnect() ，每次以 targetNode 为根节点的 DOM 树添加或移除元素时，以及这些元素的任意属性改变时，callback() 都会被调用。

记录mutation类型，区分是子节点修改，那么触发修改。


# 页面白屏 卡顿和崩溃区别




# 前端白屏检测方案


# 前端报错收集方案


# 前端埋点方案
