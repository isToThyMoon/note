# 

要做表格首先要选择基于 DOM 还是 Canvas，Canvas 渲染效率比 DOM 高，这是浏览器实现导致的。Canvas 渲染效率比 DOM 高，这是浏览器实现导致的。

这里主要探讨dom渲染的表格如何提高性能。

高性能表格的需求主要是在上千上万行数据加载在表格里的场景。react表格中的加载大量数据就要构建大量dom，那么无论是首次加载还是做一些修改后更新dom，都会有轻则瞬间白屏，重则页面卡死无响应的性能问题。如何解决？

渲染dom太多，大量的重排重绘。思路都是减少dom渲染的数量。

一种是分页，常规想法，需要后端做分页或者前端拿到所有数据后前端做分页，但有些场景就是没有分页或者不需要分页，

一种是滚动加载（懒加载）(但有个缺点，如果加载多了改动布局的时候仍然会卡顿)

一种是虚拟滚动（仅渲染视窗显示区域内的表格dom）。

即预留一些 Buffer 区域用于滑动时填充，表格仅渲染可视区域与 Buffer 区域部分。但这些方案都不可避免的存在快速滑动时白屏问题。


如何完美解决快速滑动白屏问题？



https://cloud.tencent.com/developer/article/1865797

单元格使用 DIV 绝对定位，所有单元格位置都要提前计算，这里可以利用 web worker 做并行计算


即不要使用原生的滚动条，而是使用 .scroll 代替滚动条，用 mousewheel 监听滚动的触发，
原因是用js控制触发的滚动发生在渲染完成之后，所以浏览器会在滚动发生前现完成渲染，这相当有趣。
当我们采用模拟滚动方案时，相当于采用了在滚动时 “高频渲染” 的方案，因此不需要使用截留，更不要使用 Buffer 区域，因为更大的 Buffer 区域意味着更大的渲染开销。
当然，滚动过快依然不是一件好事，既然滚动是由我们控制的，可以稍许控制下滚动速度，控制在每次触发 mousewheel 位移不超过 200 左右最佳。

预计算
像单元格合并、行列隐藏、单元格格式化等计算逻辑，最好在滚动前提前算掉，否则在快速滚动时[实时计算](https://cloud.tencent.com/product/oceanus?from=20065&from_column=20065)必然会带来额外的计算成本损耗。

但是这种预计算也有弊端，当单元格数量超过 10w 时，计算耗时一般会超过 1 秒，单元格数量超过 100w 时，计算耗时一般会超过 10 秒，用预计算的牺牲换来滚动的流畅，还是有些遗憾，我们可以再思考以下，能否降低预计算的损耗？

局部预计算
局部预计算就是一种解决方案，即便单元格数量有一千万个，但我们如果仅计算前 1w 个单元格呢？那无论数据量有多大，都不会出现丝毫卡顿。

但局部预计算有着明显缺点，即表格渲染过程中，局部计算结果并不总等价于全局计算结果，典型的有列宽、行高、跨行跨列的计算字段。

我们需要针对性解决，对于单元格宽高计算，必须采用局部计算，因为全量计算的损耗非常大。但局部计算肯定是不准确的，如下图所示：





