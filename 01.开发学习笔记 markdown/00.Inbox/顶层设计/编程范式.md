---
title: 02.编程范式 函数式编程
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
---

# 编程范式：命令式编程 声明式编程
编程范式是一种编程思想或方法论，用于组织和编写计算机程序。不同的编程范式强调不同的概念、原则和方式来处理数据、控制流程和组织代码。
常见的有：
1.命令式编程（Imperative Programming）（如面向过程 面向对象）：
命令式编程是一种更广泛的编程范式，它涵盖了面向对象编程和面向过程编程。大多数编程语言允许您使用对象和方法（面向对象）以及函数和过程（面向过程）来组织代码，可以同时使用。
在命令式编程中，程序员编写详细的指令，以描述程序的执行步骤和数据操作。这包括OOP中的方法调用、PP中的函数调用以及控制流程（例如if语句和循环）。命令式编程强调程序的“如何”执行。

2.声明式编程（Declarative Programming）（如：SQL查询语言 HTML、CSS 函数式编程（map filter））：
声明式编程强调描述问题的声明，而不是解决方案的实现细节。
它强调“做什么”，而不是“如何做”。在声明式编程中，程序员描述所需的结果，而不是详细说明如何计算它。常见的例子包括SQL查询语言和函数式编程中的一些方法。声明式编程通常更抽象、更易读和更易维护。

在实际开发中，不同的编程范式可以根据问题的性质和需求进行选择和组合。

现代的编程语言不约而 同的朝着面向对象、函数式、动态、解释执行的方向发展，例如Ruby,Swift。而另一些语言则更加强调函数式编程，如F#,Scala，这种语言有着 强大的类型推断系统，编写的代码洁程度则令人叹为观止。

实际上编程范式和语言不是牢牢绑定的，我们可以在js中使用面向对象的方式解决问题，也可以使用函数式编程的方式解决问题。

# 编程范式：命令式编程（面向过程 面向对象）

面向过程编程（Procedural Programming PP）：PP是一种编程范式，它将程序组织为一系列过程或函数，这些过程按顺序执行，通常包括输入、处理和输出。PP强调过程和数据的分离，程序的执行顺序和数据的流动，而不是对象之间的交互。它通常用于编写简单的脚本或执行特定任务的程序。

面向对象编程（Object-Oriented Programming OOP）：OOP是一种编程范式，它将程序组织为对象的集合，每个对象都有其自身的属性和方法。强调封装、继承和多态。OOP的关键思想是将数据和操作封装在对象中，以提高代码的可维护性和可重用性。在OOP中，程序由对象之间的交互构建，常用于构建具有复杂状态和行为的应用程序。

而且面向过程是以事件为中心，将解决问题的步骤分析出来，然后用函数一一实现，最后主函数按顺序调用所有子函数解决问题。
这种方式直面解决问题，效率非常高，且代码短小精悍，善于结合数据结构来开发高效率的程序。
但是缺点是要深入思考，针对性太强导致代码复用性低，拓展能力差，后期维护难度大。

问题规模变大时，利用面向过程这种耗费精力的方式来解决就远远不够了。

面向对象是一种以对象为中心的编程思想，将问题分解成各个对象，每个对象拥有各自的属性和行为，建议对象不是为了完成一个步骤，而是描述对象在解决问题步骤汇总的属性和行为。
这种方式结构清晰，完成模块化和结构化，不仅符合人类思维也因为高度封装易于复用拓展，容易维护，可以构建出低耦合大规模的系统。
缺点是编码难度大，建立对象修改对象要增加许多无其他意义的开销，也容易让代码变得臃肿。
由于面向更高的逻辑层，性能更低，计算时间和空间存储的开销都很大。


java等面向对象编程中，
类和实例是大多数面向对象编程语言的基本概念。

1.类：类是对象的类型模板，例如，定义Student类来表示学生，类本身是一种类型，Student表示学生类型，但不表示任何具体的某个学生；

2.实例：**实例**是根据类创建的**对象**，例如，根据Student类可以创建出xiaoming、xiaohong、xiaojun等多个实例，每个实例表示一个具体的学生，他们全都属于Student类型。

JavaScript的所有引用类型数据都可以看成对象， 函数也是对象 但是 js对象又是由函数创建的。

## 声明式编程
声明式编程也是一种范式，但它是一个比较大的概念，函数式编程是它的一个子集。声明式编程能指定每一步操作，而不用向计算机描述具体的实现细节。与之相对立的是命令式编程，它会命令计算机每一步该怎么做。以数组的元素翻倍为例

先用命令式编程实现，如下所示。
``` JavaScript
var arr = [1, 2, 3],
  length = arr.length,
  doubles = [];
for (let i = 0; i < length; i++) {
  doubles.push(arr[i] * 2);
}
```

在命令式的代码中，先用for循环遍历整个数组，然后让每个元素乘以二，再将计算结果插入到doubles数组中，直至将所有的元素计算完才终止整套操作。改用声明式编程可以像下面这样实现相同的功能。
`var doubles = [1, 2, 3].map(value => value * 2);`

在声明式的代码中，用map()方法替代了循环语句（即不指明流程的控制方式），既不用再维护计数器，也不用再通过索引访问数组的元素，配合ES6的箭头函数让整套操作变得非常简洁。

除了这些表面区别之外，还有个最本质的区别，那就是声明式编程会避免用变量保存程序的状态，从而能提高代码的无状态性。在命令式的代码中，每次迭代都会修改doubles变量，这是个状态变量，而在声明式的代码中，改用返回值保存程序的状态。

### 函数式编程
FP将计算视为函数应用，强调不可变性、纯函数、高阶函数和递归。

代表语言有haskell、Scala、erlang等，python和js并不是纯的函数式编程语言，部分支持函数式编程，但它们都提供了很多函数式编程中好的特性，如lambda map reduce filter等等。

源自于数学理论，它似乎也更适用于数学计算相关的场景

纯函数分解复杂逻辑业务
链式写法符合思维逻辑

函数式编程更注重执行结果而非执行过程，富有表现力，非常容易用简短的代码描述解决方案（map filter），缺点就是因为注重执行结果，bug难以追溯。

#### 函数优先
函数式编程强调在程序中使用函数。由于JavaScript中的函数是一等公民，它既可以是变量的值，也可以作为另一函数的参数或返回值，因此通过函数可构建一层抽象以替代流程控制或解决复杂的逻辑操作。例如对数组中的数字进行排序和过滤，可以像下面这样运用函数式编程的思想实现。
`[4, 1, 5, 2, 3].sort((a, b) => a > b).filter(value => value > 2);        //[3, 4, 5]`

函数式编程旨在将复杂的运算分解成一系列嵌套的函数，逐层推导，不断渐进，直至完成运算。

#### 纯函数
纯函数（Pure Function）是一种没有副作用、引用透明的函数，它是函数式编程的基本概念，接下来会重点讲解它的三个特征。

1）无副作用（不依赖外部资源和不确定操作）
函数在读写外部资源或执行不确定的操作时就会产生副作用，例如修改函数外的变量、调用Date.now()或Math.random()、更新cookie信息等。副作用不仅会降低程序整体的可读性，有时候还会带来意料之外、难以排查的错误，下面是一个副作用的例子。
``` JavaScript
var digit = 1;
function increment() {
  digit += Math.random();
  return digit;
}
```

在上面的代码中，increment()函数产生了副作用，因为每次调用它都会更新外部的digit变量，并且每次得到的计算结果也无法预知。

2）引用透明（Referential Transparency）、幂等性
引用透明性是指一个函数调用可以被它的返回值所代替，并且整个程序的行为不会改变，具体来说，如果一个函数对于给定的输入总是返回相同的输出，那么它就是引用透明的。
如果一个函数是引用透明的，那么可以安全地将函数的调用替换为其返回值，而不会对程序的行为产生任何影响。
我们可以利用这个特性对纯函数进行“加和乘”的运算，这是重构代码的绝妙手段之一
```js
// 引用透明的函数
function add(a, b) {
  return a + b;
}

const result1 = add(2, 3); // 结果为 5
const result2 = 2 + 3;    // 结果也为 5，可以替代 add(2, 3)

// 非引用透明的函数，因为它依赖于外部状态
let counter = 0;
function increment() {
  counter++;
  return counter;
}

const value1 = increment(); // 值为 1
const value2 = increment(); // 值为 2，不可替代 increment() 调用
```

和幂等性类似：
幂等性（Idempotence）是一个计算机科学和数学概念，通常用于描述某个操作、函数或处理的性质。一个幂等的操作或函数，无论执行多少次，其结果都与执行一次的结果相同。
简单的说就是，函数的运行只受其输入值的影响，如下代码所示，传递给add()函数固定的参数会返回固定的值。
``` JavaScript
function add(a, b) {
  return a + b;
}
```

4）参数值在内部不可变
传递给纯函数的参数值是不允许在内部将其改变的，换句话说，在函数内部使用的是参数值的副本。如果参数值是基本类型的，那么传递给函数的就是其副本；但如果参数值是引用类型（对象）的，那么需要注意，传递给函数的是引用对象的指针。

下面用一个示例说明，addDigit()函数的参数是一个数组，它的功能是为该数组的每个元素加一，在执行addDigit(digits)之后，由于digits变量是一个数组，因此它的元素会随着函数的调用而被改变。
``` JavaScript
var digits = [1, 2, 3];
function addDigit(arr) {
  for (let i = 0, len = arr.length; i < len; i++) {
    arr[i] += 1;
  }
  return arr;
}
addDigit(digits);
console.log(digits);       
//[2, 3, 4]
//接下来修改addDigit()函数，使之能满足纯函数的要求，如下所示。

var digits = [1, 2, 3];
function addDigit(arr) {
  return arr.map(value => value + 1);
}
addDigit(digits);
console.log(digits);       //[1, 2, 3]
```

在addDigit()函数内部，用map()方法替代for循环，使得在不改变参数的前提下，完成元素加一的功能。

#### 优点
函数式编程有许多优点，本节只列出了其中的两点。

（1）函数式编程可将复杂的任务分解成一个个既简单又独立的纯函数，有利于提高代码的模块化、复用性、预测性以及可测试性。
（2）函数式编程有很高的自由度，可以采用更符合人类思维习惯的链式写法，以此提高代码的可读性。

接下来会用两种函数式的写法操作一个数组，为了便于演示省略了函数的具体实现，首先是普通的函数式写法，如下所示。
`elementDouble(filterEven(arr, filterFn), doubleFn);`

两个函数都有两个参数，第一个是数组，第二个是相应的回调函数。具体的执行过程是先通过filterEven()函数过滤掉数组中偶数位置的元素，再用elementDouble()函数把每个元素翻倍，下面改成链式的写法。
`filerEven(arr, filterFn).elementDouble(arr, doubleFn);`

通过两段代码的对比可以看出，链式的写法更容易让人理解，代码意图也更清晰。

#### 代数效应
React核心团队成员Sebastian Markbåge（React Hooks的发明者）曾说：我们在React中做的就是践行代数效应（Algebraic Effects）。

代数效应是函数式编程中的一个概念，用于将副作用从函数调用中分离，使函数关注点保持纯粹。

那么代数效应与React有什么关系呢？最明显的例子就是Hooks。

对于类似useState、useReducer、useRef这样的Hook，我们不需要关注FunctionComponent的state在Hook中是如何保存的，React会为我们处理。

我们只需要假设useState返回的是我们想要的state，并编写业务逻辑就行。