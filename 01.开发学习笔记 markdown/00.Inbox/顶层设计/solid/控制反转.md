
# 控制反转IoC

控制反转（Inversion of Control - IoC）和依赖倒置（Dependency Inversion - DIP）是两个与软件设计和架构有关的概念，它们在某种程度上是相关的，因为依赖倒置是实现控制反转的一种方法。
控制反转通常是通过依赖注入（Dependency Injection）来实现的，而依赖注入是依赖倒置的一种具体实现方式。通过依赖注入，高层模块（或组件）可以声明它们需要哪些依赖，而不需要自己创建这些依赖对象。这些依赖对象的创建和管理由 IoC 容器或框架负责，这就是控制反转的体现。

88年提出控制反转IoC，95年提出依赖倒置DIP，04年提出依赖注入DI。

控制反转（IoC）： IoC 是一种更高级别的概念，它涉及到控制程序流程的权力。在传统的编程中，程序员通常控制代码的执行顺序。而在 IoC 中，控制权被反转，由框架或容器来控制代码的执行流程。典型的 IoC 容器会负责创建对象、管理对象之间的依赖关系，并在适当的时候调用对象的方法。这种控制反转有助于实现模块化、可测试和可扩展的代码。

依赖倒置原则（DIP）： DIP 是 SOLID 原则中的一部分，它强调高层模块不应该依赖于低层模块，而是都应该依赖于抽象。这意味着在软件设计中，应该依赖于接口或抽象类，而不是具体的实现。DIP 有助于实现松散耦合，以便在系统中更容易进行更改和扩展。

总之，控制反转和依赖倒置是相关的，因为依赖倒置是实现控制反转的一种方法。它们都有助于实现松散耦合、可维护性和可扩展性，是现代软件设计和架构中的重要概念。

# react中的依赖倒置和依赖注入
依赖倒置常常用依赖注入来具体实现，dependency injection其实通俗来说很简单，就是解耦依赖和使用者，不要在使用者的内部定义和实现它的具体的依赖，而是把具体的依赖转化成抽象的依赖，使用者依赖于这个抽象的依赖，方便随时修改低层模块。

比如要实现一个功能：“我将开特斯拉去新疆。”这时候就把这个功能高层模块和特斯拉这个具体依赖绑定，后续我们想换车，就必须在高层模块内部修改和特斯拉相关的功能，比如特斯拉的启动，特斯拉的刹车，特斯拉的补能。

而如果修改成“我将开车去新疆。”就把具体的依赖改成“车”这个抽象的依赖，至于具体是什么车，可以继承车这个抽象类，实现具体的功能方法如启动、刹车，完成具体的依赖。将车作为去新疆这个高层模块功能的一个待接入接口，就实现了依赖注入，即注入具体的车。等出发时可以决定开不同的车，特斯拉、卡罗拉、保时捷等等，甚至你还可以抽象出油车、电车、混动车、氢气车、核能车等更抽象的类去具体继承实现。

抽象出来意味着这例子中每种依赖最好都有同样的操作方法，如启动、刹车、制冷等等，否则你还是需要修改高层模块的内部代码来使用不同的工具。所以依赖注入也好，其他的设计模式也好，都是有限制的，它是相对的抽象，做不到绝对的抽象。

编程没有绝对的银弹。

前端尤其是react的布道者Dan在相关文章提到过DI原则，表达的意思就是react和renderer是解耦的，开发者根据运行环境是浏览器还是手机，决定renderer是react-dom还是react-native，解耦后，如果以后有新的renderer，也可以根据抽象的renderer来随便添加。

其实根本的意思还是从代码中抽离出公共部分内容，这也是设计模式的本质。

## 控制反转历史

在讨论控制反转之前，我们先来看看软件系统中耦合的对象。
当多个Object之间互相调用，他们就像齿轮一样啮合，协同工作且配合良好。但是互相耦合，一个零件不能正常工作，整个系统就崩溃了。这是一个强耦合的系统。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。

为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC理论，用来实现对象之间的“解耦”。

但是互相耦合，一个零件不能正常工作，整个系统就崩溃了。这是一个强耦合的系统。齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。

为了解决对象间耦合度过高的问题，软件专家Michael Mattson提出了IoC理论，用来实现对象之间的“解耦”。其基本思想是：借助于“第三方”实现具有依赖关系的对象之间的解耦。

由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。

我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：

1.软件系统在没有引入IOC容器之前，系统运行过程中，对象A调用对象B中的方法，我们说对象A依赖于对象B，因为没有对象B，对象A也无法正常运作。
那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。

2.软件系统在引入IOC容器之后，这种情形就完全改变了，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。
通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。



## 依赖注入实现控制反转

JavaScript中，你可以使用依赖注入（Dependency Injection）模式来实现控制反转，以便将依赖项传递给函数或类，而不是在函数或类内部创建它们。这有助于提高代码的可维护性和可测试性。

下面是一个简单的JavaScript示例，演示如何实现依赖注入：

```javascript
// 依赖项 - Logger
class Logger {
  log(message) {
    console.log(`Log: ${message}`);
  }
}

// 依赖项 - UserService
class UserService {
  constructor(logger) {
    this.logger = logger;
  }

  createUser(username) {
    // 创建用户的逻辑
    this.logger.log(`User created: ${username}`);
  }
}

// 使用依赖注入创建实例
const logger = new Logger(); // 创建日志记录器实例
const userService = new UserService(logger); // 将日志记录器传递给用户服务 （注入依赖）

// 使用用户服务创建用户
userService.createUser('john_doe');
```

在上述示例中，我们有两个依赖项：`Logger` 和 `UserService`。`UserService` 在构造函数中接收一个 `logger` 参数，这是一个依赖注入的示例。我们首先创建一个日志记录器实例，然后将它传递给 `UserService` 构造函数。

这种方式允许我们轻松地替换或共享依赖项，例如，我们可以轻松地传递不同的日志记录器实例，或者在应用的不同部分共享同一个日志记录器。

通过依赖注入，我们将控制权从创建依赖项的地方移到了使用它们的地方，从而实现了控制反转的原则。这提高了代码的灵活性和可维护性，使代码更容易测试和扩展。