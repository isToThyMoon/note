
# 涉及typescript type导入导出
Typescript 3.8版本中专门引入了import type和export type

Typescript做了哪些工作:
为你编写的typescript代码添加静态类型检查
将你编写的ts+js代码, 最终编译转化成javascript代码.
还能配合ide做更好的类型提示

但第二件事, 除了tsc能做之外, 还存在别的编译工具可以做到, 比如我们最常用的Babel

首先说tsc的编译, 在我们日常写代码的过程中, 通常会使用import去导入一些类型或者值, 比如下面的写法:

```ts
// ./foo.ts
interface Options {
    // ...
}

export function doThing(options: Options) {
    // ...
}

// ./bar.ts
import { doThing, Options } from "./foo.js";

function doThingBetter(options: Options) {
    // do something twice as good
    doThing(options);
    doThing(options);
}
```

上面的代码中, doThing是作为一个值被导入, Options作为一个类型被导入, 这样同时导入其实很方便, 因为我们不用担心我们导入的是什么, 只需要知道我要用它, import就完事了, 哪怕我同时import的是一个类型和一个实际值也没有关系。

但我们能够同时import一个值和一个类型, 是因为一个叫**import elision**(导入省略)的功能在起作用。

当Typescript进行代码编译时, 发现Options是作为一个类型被导入的, 就会自动在生成的JS代码中删除掉它的导入, 所以最终生成的是类似于(类似, 用于解释说明, 但可能非实际输出代码)下面的JS代码：
```
// ./foo.js
export function doThing(options: Options) {
    // ...
}

// ./bar.js
import { doThing } from "./foo.js";

function doThingBetter(options) {
    // do something twice as good
    doThing(options);
    doThing(options);
}
```
可见, 所有跟类型相关的代码, 都在最终编译生成的文件里被删除了, 所以我们直接通过import和export来导入/导出值和类型的写法是很方便的, 但是这么写, 也会存在一些问题。

1. 容易产生模棱两可语句，单引入页面无法判断引入的是类型还是变量
2. 导入省略将删除引入副作用的代码
```
// 因为import elision的功能, 这行代码在最终生成的js代码中会被删除
import { SomeTypeFoo, SomeOtherTypeBar } from "./module-with-side-effects";

// 这行代码要一直存在 因为文件里有一些副作用代码
import "./module-with-side-effects";
```

## import type
基于上面的问题, Typescript 3.8中引入了import type, 希望能够用一种更加清晰易懂的方式来控制某一个导入是否要被删除掉。

```ts
import { MyThing } from "./some-module.ts";

export { MyThing };
```

上面的例子就是我们在问题1中介绍过的, 像Babel这样的编译工具是不能够准确的识别MyThing到底是一个值还是类型的, 因为Babel在编译的过程中, 一次只会处理一个文件.
所以这种时候, 我们就需要一种方式, 来准确的告诉正在编译这个文件的编译工具, 现在使用import type和export type导入和导出的MyThing就是一个类型, 你完全可以在编译的时候把这段代码省略(删除)掉。

```
import type { MyThing } from "./some-module.ts";

export type MyThing;
```

使用import type 和export type导入和导出的类型只能在类型上下文中使用, 不能作为一个值来使用。

## class
有一点需要注意的是, class既可以代表一个类型, 也可以代表一个值, 它在runtime是有实际的意义的, 所以用import type引入一个class的时候, 不能用到它值的含义, 不能extend这个class。

```ts
import type { Component } from "react";
interface ButtonProps {
  // ...
}
class Button extends Component<ButtonProps> {
  // error! 'Component' only refers to a type, but is being used as a value here.
}
```


## 不可以同时引入默认和命名绑定
使用import type的时候, 可以引入一个默认导出的类型, 也可以引入命名绑定的形式导出的类型, 但是不可以同时使用两者.
```
import type Foo, { Bar, Baz } from "some-module";
//     ~~~~~~~~~~~~~~~~~~~~~~
// error! A type-only import can specify a default import or named bindings, but not both.

```

## import 和 import type 有什么区别

可以导入的内容相同, 但是使用的方式不同。
import和import type都可以导入一个类型或一个值, 但是使用import type导入的值, 只能在类型上下文中使用, 不能作为一个值来使用, 而import导入的类型和值, 都可以按照其原本定义来使用。

```ts
// type.ts
export type UnionType = string | number;
export const unionValue: UnionType = '1';


// value.ts
import { UnionType, unionValue } from './type';

const value1: UnionType = 'value1'; // 作为类型使用
const value2: typeof unionValue = 'value2'; // 获取类型
const value3 = unionValue; // 作为值使用


// value1.ts
import type { UnionType, unionValue } from './type';

const value1: UnionType = 'value1'; // 作为类型使用
const value2: typeof unionValue = 'value2'; // 获取类型

// Error: "unionValue" 是使用 "import type" 导入的，因此不能用作值
const value3 = unionValue; // 作为值使用

```

可以看到上面的代码, 分别使用import和import type引入了一个类型UnionType和一个值uninoValue, 在value1.ts文件中, 使用import type导入的值unionValue, 直接作为一个值使用时, 是会报错的。

import type导入的内容只能用在跟类型相关的地方。

## 跟import type有关的tsconfig.json项
importsNotUsedAsValues，
isolatedModules