---
title: 02.pluglin
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 05.webpack
  - 核心概念
---

举个例子：

每次打包在打包完成后于dist目录下生成一个index.html 自动引入打包完成的bundle.js文件。

plugins实现自动化操作。

plugin可以在webpack运行到某一时刻的时候 帮你做一些事情。

再比如clean-webpack-plugin实现在每次重新打包前清空dist目录。

先安装插件
`npm install html-webpack-plugin clean-webpack-plugin --save-dev`

```js
plugins: [
    new HtmlWebpackPlugin({
    template: 'src/index.html'   //打包完成后以此路径的文件为模版生成一个html文件
    }),
    new CleanWebpackPlugin(['dist']) //每次重新打包前将dist目录清空
]
```



# 自定义插件
https://webpack.docschina.org/contribute/writing-a-plugin/

Webpack中的插件机制就是基于Tapable实现与打包流程解耦，插件的所有形式都是基于Tapable实现。
Tapable包本质上是为我们更方面创建自定义事件和触发自定义事件的库，类似于Nodejs中的EventEmitter Api。
所以在webpack 存在了各种各样的钩子，既然有了这些钩子，我们就可以监听webpack 开始的过程 ，完成的过程，或者说所有静态资源打包的过程，我们都可以进行一些操作，然后就出现了市面上的各种各样的插件。

任何一个webpack插件都是一个类(当然类本质上都是funciton的语法糖)，每个插件都必须存在一个apply方法。

这个apply方法会接受一个compiler对象。我们上边做的就是依次调用传入的plugin的apply方法并且传入我们的compiler对象。
这里我请你记住上边的流程，日常我们编写webpack plugin时本质上就是操作compiler对象从而影响打包结果进行。


webpack准备编译阶段：
1. 合并参数
2. 创建 compiler 对象
3. 然后加载插件函数 ，也就是遍历插件数组，然后调用每个插件实例的apply 方法

```js
// 伪代码
function webpack(options) {
  // 合并参数
  const mergeOptions = _mergeOptions(options);
  // 创建compiler对象
  const compiler = new Compiler(mergeOptions);
  // 加载插件
  _loadPlugin(options.plugins, compiler);
  return compiler;
}
// 加载插件函数
function _loadPlugin(plugins, compiler) {
  if (plugins && Array.isArray(plugins)) {
    plugins.forEach((plugin) => {
      plugin.apply(compiler);
    });
  }
}
module.exports = webpack;
```

这就解释了为什么 我们编写的 webpack plugin 总是要有apply 方法了。
然后这个compiler 上面就有各种各样的钩子， 你就可以结合自己的需求去写一个自定义插件了。