# signed integers & unsigned integers
有符号数（signed）可以表示特定类型规定范围内的整数（包括负数），而无符号数只能表示非负数（0及正数）。 有符号数能够表示负数的代价是能够表示的正数范围的缩小，因为其约一半的数值范围要用来表示负数（如8位有符号整数中，对应8位无符号整数表示128~255的部分被用于表示-127~-1）。

00000000 表示范围0~2^8 -1 即 0～255
'sign'0000000 表示范围-(2^7-1)～2^7-1即-127 ～127

# floating point（有理数）
相对于定点数的概念，定点数固定的是小数点位置，可以表达一个确定的整数或小数。

浮点数，用于近似表达一个某个实数，浮点计算是指浮点数参与的计算，这种计算通常伴随着因无法精确表示而进行的近似或舍入。

表达方式类似10进制的科学计数法。小数点位置不固定，同一个数字采用记数法可以有多种表达方式。

一个floating point表示。
V = (-1)^S * M * R^E
S符号位，M尾数，R基数，E指数。
需要选择一个基数R（计数系统的基）和精度p（即用多少位来存储）。

例如32bit表示一个浮点数：
31 30 29 28 27 .......3 2 1 0
符号位S在31，占1bit
指数E占据8bit
尾数M占据剩余23bit

按照这个规则，将十进制数 25.125 转换为浮点数（D decimal 十进制，B binary 二进制）

25.125 = 25(D) + 0.125(D)
 ---> 11001(B) + 0.001(B)
 
 则25.125(D) = 11001.001(B) = 1.1001001 * 2^4(B)
 
 则符号位0，尾数M = 1.1001001(B)，指数E=4(D) = 100(B)
 
 转化存储到32bit内存
 
 但是指数位数和尾数位数是可以任意指定的，指数位越多，尾数位越少，表示数值范围越大，但精度越低。反之表示数值范围越小，精度越高。

早期厂商计算机都有自己的浮点数标准，那么不同计算机不统一必须要相互先转化，这肯定是不行的。

1985年IEEE组织推出了IEEE754浮点数标准，各大厂商协商遵守大家计算机都这么设计。

单精度浮点数 float：32 位，符号位 S 占 1 bit，指数 E 占 8 bit，尾数 M 占 23 bit。 单精度浮点数最多有7位十进制有效数字
双精度浮点数 float：64 位，符号位 S 占 1 bit，指数 E 占 11 bit，尾数 M 占 52 bit。

为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定：
规格化：
为了使有效值和尾数能够统一，在空间上表达更有效率 有必要将所有浮点数规格化，即浮点数通过调整阶码，写成小数点前不含有有效数字，小数点后第一位由非0数字表示，举例-306.5规格化为-0.3065*103 。

二进制浮点数的规格化方法：
通过调整小数点的阶码使得该数的有效值在1和2之间，既二进制浮点数的整数部分为1，

例如：0.8125 = 0.1101（B） = 1.101e-1（B）

尾数 M 的第一位总是 1（因为 1 <= M < 2），因此这个 1 可以省略不写，它是个隐藏位，这样单精度 23 位尾数可以表示了 24 位有效数字，双精度 52 位尾数可以表示 53 位有效数字
指数 E 是个无符号整数，表示 float 时，一共占 8 bit，所以它的取值范围为 0 ~ 255。但因为指数可以是负的，所以规定在存入 E 时在它原本的值加上一个中间数 -127（移码），这样 E 的取值范围为 -127 ~ 128。表示 double 时，一共占 11 bit，存入 E 时加上中间数 1023，这样取值范围为 -1023 ~ 1024。
除了规定尾数和指数位，还做了以下规定：

指数 E 非全 0 且非全 1：规格化数字，按上面的规则正常计算
指数 E 全 0，尾数非 0：非规格化数，尾数隐藏位不再是 1，而是 0(M = 0.xxxxx)，这样可以表示 0 和很小的数
指数 E 全 1，尾数全 0：正无穷大/负无穷大（正负取决于 S 符号位）
指数 E 全 1，尾数非 0：NaN(Not a Number)

所以规定浮点数范围时要除去E全0全1情况

单精度浮点数取值范围：
E最大取值: 2^8-1= 255 除去全1情况 255-1等于254 减去移码127 254-127 = 127
尾数M最大情况23位全1
最大值+(1.1111........)x2^127 （B）约等于 3.402823E38 （D） E代表十进制科学计数法

Math.pow(2,105)* 0b11111111111111111111111 = 3.4028232635611926e+38

# 浮点数为什么有精度损失？
我们再来看一下，平时经常听到的浮点数会有精度损失的情况是怎么回事？

如果我们现在想用浮点数表示 0.2，它的结果会是多少呢？

0.2 转换为二进制数的过程为，不断乘以 2，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。

0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0（发生循环）
...
所以 0.2(D) = 0.0011...(B)。

因为十进制的 0.2 无法精确转换成二进制小数，而计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。

# js数值类型
JavaScript 内部只有一种数字类型Number，也就是说，JavaScript 语言的底层根本没有整数，所有数字都是以IEEE-754标准格式64位浮点数形式储存，采用双精度存储（double precision），使用64位固定长度来表示，其中1位用来表示符号位，11位用来表示指数，52位表示尾数。

因为有些小数以二进制表示位数是无穷的。JavaScript会把超出53位之后的二进制舍弃，所以涉及小数的比较和运算要特别小心。

符号位(sign)：第1位是正负数符号位，0代表正数，1代表负数
指数位(Exponent)：中间11位存储指数，用来表示次方数
尾数位(mantissa)：最后的52位是尾数，超出部分自动进一舍零

js计算小数时，十进制的0.1和0.2会转换成二进制的，但是由于浮点数用二进制表示是无穷的，最后多余的二进制被截断，造成精度损失。

# 解决办法
1.引入第三方库，decimal.js big.js
2.在知道小数位个数的前提下，可以考虑通过将浮点数放大倍数到整型(最后再除以相应倍数)，再进行运算操作。




# 计算

1.丢弃小数部分,保留整数部分 
js:parseInt(7/2) 

3,四舍五入. 
js: Math.round(7/2) 

2.向上取整,有小数就整数部分加1 
js: Math.ceil(7/2)

4,向下取整 
js: Math.floor(7/2)