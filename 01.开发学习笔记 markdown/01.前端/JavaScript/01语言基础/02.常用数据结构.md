---
title: 02.常用数据结构(类型)
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
tags:
  - js
date:
---

# typeof instanceof 和判断数据类型
**typeof**能得到number string boolean undefined symbol object function

所以typeof只能区分值类型。typeof 全部数据结构 的两个bug：
1.`typeof null === 'object'` 得到的是"object"
2.`typeof ()=>() ==='function'` 对于函数会得到 "function"。 function本质上来说也是object，是个非常特殊的对象，但其实没有function这个类型。

> JS 的最初版本中，使用的是 32 位 系统， 为了性能考虑使用低位存储了变量的类型信息， 000 开头代表是对 象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的 内部类型判断代码已经改变了，但是对于这个 Bug 却是⼀直流传下来。


**instanceof** 左操作数是一个类，右操作数是标识对象的类。如果左侧的对象是右侧类的实例，则返回true

## js中如何判断数据类型
常规的typeof instanceof

instanceof来判断类型往往得不到理想结果，Object是原型链的顶层`Object.prototype.__proto__ === null`
所以哪怕：
```
new Number(1) instanceof Object === true
1 instanceof Object === false
```
所以不要使用`xx instaceof Object`

如果我们想获得⼀个变量的正确类型，lodash的实现：`Object.prototype.toString.call(target)`
获得类似`[object Type]`的字符串



-------

# 数据类型
**基本类型**（primitive values）有number string boolean null undefined symbol（es6引入） bigInt（后加入）

**引用类型** object

array和object 是js里两个重要数据类型  相当于python里的list和dict
其中object每个键又称为对象的属性 要获取一个对象的属性，可以用[""]和点操作

而在js中，array function都是对象object

## number
十进制（0-9）
1.1 = 1.1
.1 = 0.1
1.23e2 = 123

二进制 （以0b开头）
0b11 = 3

八进制 （以0开头）
011 = 9

16进制 （以0x开头）

## string 字符串
以单引号或双引号包裹  '' ""
'' ""表示空字符串 长度是0
' '  " "表示空格字符串 长度是1

### 转义： \表示转义
在代码中表示字符串的时候, 很多东西不方便表示, 因此我们使用转义符的方式来表示
转义符是字符串中的特殊符号，由反斜杠（backslash）开始，接另一个字符结束
常用的转义符有
还有一些别的转义符，但极少使用，对于这种东西，不必记忆，知道有这么回事就好了。
```js
 \n     // 表示一个换行符
 \t     // 表示一个 TAB（制表符）
 \\     // 表示一个反斜杠 \
 \a     // 表示系统警铃声，有的系统不会响
 \'     // 表示一个单引号
  \"     // 表示一个双引号

var a = '\'' 单引号
var n = '\n' 回车
var t = '\t' tab 制表符
var b = '\\' \符号
```

### 多行字符串：
多行字符串   
es6: 

```js
var s = `1234
45678` 
# 反引号表示多行字符串
```

### 模板字符串
要把多个字符串连接起来，可以用+号连接：

```js
var name = '小明';
var age = 20;
var message = '你好, ' + name + ', 你今年' + age + '岁了!';
alert(message);
```

如果有很多变量需要连接，用+号就比较麻烦。ES6新增了一种模板字符串，表示方法和上面的多行字符串一样，但是它会自动替换字符串中的变量：

```js
var name = '小明';
var age = 20;
var message = `你好, ${name}, 你今年${age}岁了!`;
alert(message);
```

## boolean
true false 开头字母不大写 大写报错
&& 与 同真取真 否则为假
|| 或 一个取真为真 同假取假

## null
它是一个类型 一个值 是null

## undefined
它是一个类型 一个值 是undefined

这是js的一个原创设计 bug 设计的不好

如果变量声明后没有赋值 值就是undefined  这个是语法
有一个对象 现在不想给值 就是null 表示空对象 这是惯例表示 不是语法限制
有一个非对象 不想给值 就是undefined 空的非对象 

## symbol
暂跳过

## object
前面都是基本类型
object是引用类型
复杂类型由简单类型组成
{}表示对象

能不能
```js
person = {
name: 'dadada',
person.self:person
}
```
未定义完，对象的某个key对应的value却也是对象本身。
是可以的，这是内存的内容。self存储的是一个对象的引用，也就是对象在堆中的地址。

JavaScript中对象的key不严格要求加引号''，但json中key value是严格要双引号""包裹的。

取value时，要用person['name'] 当key符合标识符的规范时，我们可以用.运算符。
person.name

delete person['name'] 把key和value都删除。
那么person.name显示undefined  'name' in person 返回false


### 数组array
```js
Array.apply(null, { length: 20 }).map(function () {
  return ...
})
```

为什么写这么复杂？
ES5开始apply函数的第二个参数除了可以是数组外，还可以是类数组对象（即包含length属性，且length属性值是个数字的对象）。对象{length: 2}就是一个类数组对象，因为没有初始化下标0，1的值，所以获取0，1下标的值得到的都是undefined。
这样就很容易知道该表达式的值是一个长度为20，且每个元素值都被初赋值为undefined的数组（注意此时不是数组元素没有初始化，而是初始化成undefined，这就是跟Array(20)的区别， Array（20）创建了一个长度为20数组，但是值都没有初始化）

而map函数并不会遍历数组中没有初始化或者被delete的元素（有相同限制还有forEach, reduce方法）。所以这样写的原因就是为了确保数组每个值被初始化，能够正确调用高阶函数。

### function
特殊的object对象
想复制一个function: `eval(target.toString())`

# json
什么是json
有一个常见的需求是在 字典/数组 和 字符串 之间相互转换
这个过程叫做 序列化/反序列化
在 js 中, 序列化使用 JSON 数据格式
全称 JavaScript Object Notation (js 对象标记)
这个格式已经是现在用于互联网数据交换的事实标准格式了
python 也有内置的标准库进行这种转换

json作为字符串：
对象表示为键值对
数据由逗号分隔
花括号保存对象
方括号保存数组

json中的键值对，键名一定要用双引号包裹，这点和js对象的写法不太一样，js对象的键名不严格要求引号。

JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。

## js 中list转换转化为json字符串
注意 typeof 语句可以查看一个变量的类型

```js
var s = JSON.stringify([1, 2, 3, 4]);
console.log('序列化后的字符串', typeof s, s);
var a = JSON.parse(s);
console.log(typeof a, a);
```
输出：
“序列化后的字符串 string [1,2,3,4]
object [ 1, 2, 3, 4 ]”

在 js 中, 由于历史遗留的 bug
typeof [] 会显示 object, 这是正常的

## js对象转化为json字符串
在js处理中使用JSON.stringify()方法：

```
var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{"a": "Hello", "b": "World"}'
```
2.从JSON字符串转换为JS对象，在js处理中使用 JSON.parse() 方法：

```
var obj = JSON.parse('{"a": "Hello", "b": "World"}'); //结果是 {a: 'Hello', b: 'World'}
```
