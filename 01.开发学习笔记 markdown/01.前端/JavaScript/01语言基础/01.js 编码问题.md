---
title: 01.js 编码问题
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
---

计算机中只用0 1存储数据。
为了存储数字，各国字符，并且统一标准不产生歧义，产生了字符集charset和编码encoding。
十进制 二进制 八进制 16进制这些数字在计算机中表示含义由0 1组成。

# ASCII字符集
ASCII编码实现了英文世界所有的字母、符号与01对应关系。
如 a 97 b 98 c 99  需要8位 0101 0101
一个字节8比特位 一共可以用来表示256种不同的状态 2的8次方

ASCII码一共规定了128个字符的编码，比如空格"SPACE"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

# GBK字符集
中国国家标准库提出了GB2312 （与日本jis同期推出，问题很大，很多字没录入）
ms在此基础上扩展了国标GBK实现了中文的编码 如 ‘你’ 对应 2F60 需要16位 0010 1111 1100 0000
中国又写了GB13080 兼容unicode 但基本没人使用。

# unicode字符集
为了存世界上所有语言和字符。
实现了unicode字符集。但是不能所有的字符都占用4字节。
utf-8编码方式实现了可变长的unicode。优化后更有利于存储。
UTF-8的编码规则很简单，只有二条：
1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号（n>1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。
一个utf-8数字占1个字节 一个utf-8英文字母占1个字节

Unicode符号范围 | UTF-8编码方式
(十六进制) | （二进制）
--------------------+---------------------------------------------
0000 0000-0000 007F | 0xxxxxxx
0000 0080-0000 07FF | 110xxxxx 10xxxxxx
0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx
0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

下面，还是以汉字"严"为例，演示如何实现UTF-8编码。
已知"严"的unicode是4E25（100 1110 0010 0101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此"严"的UTF-8编码需要三个字节，即格式是"1110xxxx 10xxxxxx 10xxxxxx"。然后，从"严"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，"严"的UTF-8编码是"11100100 10111000 10100101"，转换成十六进制就是E4B8A5。

占3个字节的：基本等同于GBK，含21000多个汉字
占4个字节的：中日韩超大字符集里面的汉字，有5万多个
一般用16进制表示。

js中'\uxxxx'表示unicode编码的字符 不能识别编号大于oxFFFF的unicode字符


# 关于base64：
全局函数btoa（）可以将字符串转为base64编码。
全局函数atob（）可以将base64编码转化为原来编码。

但对于中文等非ASCII码字符 需要先encode一下：
btoa(encodeURIComponent('王巨仙')) 转化为base64编码
decodeURI(atob（'JUU3JThFJThCJUU1JUI3JUE4JUU0JUJCJTk5'）)将base64编码转化为中文字符

# escape，encodeURIComponent()，encodeURI()

escape ( 已经废弃，mdn建议使用encodeURIComponent()，encodeURI()代替 ) 是对字符串(string)进行编码(而另外两种是对URL)，生成新的由十六进制转义序列替换的字符串，作用是让它们在所有电脑上可读。编码之后的效果是%XX或者%uXXXX这种形式。其中 ASCII字母 数字 @*/+ 这几个字符不会被编码，其余的都会。最关键的是，当你需要对URL编码时，请忘记这个方法，这个方法是针对字符串使用的，不适用于URL。

为了避免服务器收到不可预知的请求，对任何用户输入的作为 URI 部分的内容你都需要用 encodeURIComponent 进行转义。比如，一个用户可能会输入"Thyme &time=again"作为comment变量的一部分。如果不使用 encodeURIComponent 对此内容进行转义，服务器得到的将是comment=Thyme%20&time=again。请注意，"&"符号和"="符号产生了一个新的键值对，所以服务器得到两个键值对（一个键值对是comment=Thyme，另一个则是time=again），而不是一个键值对。

encodeURIComponent和decodeURIComponent是一对。encodeURI和decodeURI是一对。

唯一区别就是编码的字符范围，
escape方法不会对下列字符编码:ASCII字母 数字 @*/+ 
其中encodeURI方法不会对下列字符编码：ASCII字母 数字 ~!@#$&*()=:/,;?+'
encodeURIComponent方法不会对下列字符编码 ASCII字母 数字 ~!*()'
所以encodeURIComponent比encodeURI编码的范围更大。实际例子来说，encodeURIComponent会把http://编码成  http%3A%2F%2F而encodeURI却不会。

1、如果只是编码字符串，不和URL有半毛钱关系，那么用escape。
2、如果你需要编码整个URL，然后需要使用这个URL，那么用encodeURI。
3、当你需要编码URL中的参数的时候，那么encodeURIComponent是最好方法。

# urlEncode
一个node包
`urlEncode('我见青山多妩媚','gbk')` 将常规字符串以gbk格式编码