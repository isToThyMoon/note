---
title: 03.类的类字段或字段函数
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 函数 对象 类
tags:
  - js
date:
---

写这一篇的原因主要是因为：当我们定义一个类后，创建该类实例时，某些定义在类中函数的this指向问题十分不明朗。

我们知道，this的指向大部分情况是指向调用本函数的对象。而箭头函数的this只认词法作用域，它顺着作用域链寻找包裹自己的最近的外层作用域中this是什么。

但似乎react class写法中，使用箭头函数定义方法，箭头函数内的this是始终指向创建后的那个组件实例。这似乎是冲突的。


先看实例变量和实例函数，和类字段的关系。

类字段定义后，在类的实例化时创建对应的实例变量。
和constructor中或者构造函数中通过this.创建是一样的，区别在于类字段创建实例变量的时机要比constructor中早一些。

# 实例化时候类字段什么阶段初始化 顺序是什么？
看最复杂的情况
对于一个继承父类的子类来说：

1.先初始化基类的类字段
2.在派生类的constructor中 先执行第一行的super()方法 也就是基类的constructor（构造函数体）
3.初始化派生类的类字段
4.执行派生类的constructor内容

# 实例变量和实例的函数
在面向对象编程中除了一些库函数我们还是希望在对象定义的时候同时定义一些属性和方法，实例化后可以访问，JavaScript也能做到这样

```javascript
function Obj(){
    this.a=[]; //实例变量
    this.fn=function(){ //实例方法

    }
}

console.log(typeof Obj.a); //undefined
console.log(typeof Obj.fn); //undefined

var o=new Obj();
console.log(typeof o.a); //object
console.log(typeof o.fn); //function
```

然而

```javascript
function Obj(){
    this.a=[]; //实例变量
    this.fn=function(){ //实例方法

    }
}

var o1=new Obj();
o1.a.push(1);
o1.fn={};
console.log(o1.a); //[1]
console.log(typeof o1.fn); //object
var o2=new Obj();
console.log(o2.a); //[]
console.log(typeof o2.fn); //function
```

上面的代码运行结果完全符合预期，但同时也说明一个问题，在o1中修改了a和fn，而在o2中没有改变，由于数组和函数都是对象，是引用类型，这就说明o1中的属性和方法与o2中的属性与方法虽然同名但却不是一个引用，而是对Obj对象定义的属性和方法的一个复制。

这个对“属性”来说没有什么问题，但是对于方法来说问题就很大了，因为方法都是在做完全一样的功能，但是却又两份复制，如果一个函数对象有上千和实例方法，那么它的每个实例都要保持一份上千个方法的复制，这显然浪费内存也不科学的，prototype应运而生。


# 类字段 class field
“类字段”是一种允许添加任何属性的语法。

```js
class User {
  name = "John" // 类字段
  
  click = () => {} // 类字段
  
  sayHi() {
    alert(`Hello, ${this.name}!`);
  }

}

new User().sayHi(); // Hello, John!
```
如果不在constructor声明中初始化，而是直接在类体写`name = "John"`，或`name=()=>{}`函数，这个属性没有被放在 User.prototype 中。它是在调用constructor之前创建的。
（严格来说是constructor函数内的super()函数执行之后 constructor函数后续其他内容执行之前。）
它是对象自身的属性。其实写进constructor是一样的。但是作为类的公共字段，我们可以对所有对象提前初始化。new后每一个实例都会自动有属性name = "John"。 

`click = () => {...}`作为类字段（class field）被创建于每一个独立对象内部，那么对于每一个Button构造函数创建出来的对象它都是一个独立的函数。

类字段的形式写字段方法和 xxx(){}这样的原型方法简写的区别就在于，
原型方法存放在类的prototype中，
注意class中存储进prototype的方法写法是`sayHi(){}`，如果是sayHi = function(){} 这种匿名函数形式，很明显这就是class field了。不是类prototype里的公共方法。
通过原型链由所有通过此类创建的对象共享，优点是无需重复创建，节省内存空间。
类字段则在实例化对象时每个对象都拥有一个此字段属性。

类字段的采用主要是为了方法和属性分开写，不然属性和方法全部写在constructor中，增加心智负担。

类字段是可以被继承的。


# 类字段方法中的this
并且更有用的一点是，由于js中的函数具有动态的this，它取决于调用上下文环境，因此，如果一个对象方法被传递到某处，或者在另一个上下文中被调用，则 this 将不再是对其对象的引用。例如，此代码将显示 undefined：

```js
class Button {
  constructor(value) {
    this.value = value;
  }

  click() {
    alert(this.value); // 会丢失this
  }
  
  sayHi = function(){
    alert(this.value); // 会丢失this
  } 
  
}

let button = new Button("hello");

setTimeout(button.click, 1000); // undefined

setTimeout(button.sayHi, 1000); // undefined  setTimeout等特殊情况函数，回调函数作为参数被传入之后，函数都是挂在在window上的
```

这个问题被称为“丢失 this”。

有两种可以修复它的方式：
1.传递一个箭头函数，将实例作为调用方：例如 setTimeout(() => button.click(), 1000)。
2.将方法绑定到对象，例如在 constructor 中 `bind(this)`。

3.类字段提供了另一种非常优雅的语法：

```js
class Button {
  constructor(value) {
    this.value = value;
  }
  click = () => {
    alert(this.value);
  }
}

let button = new Button("hello");

setTimeout(button.click, 1000); // hello
// setTimeout会挂在到window上，回调函数也是，即使这里类字段写成click = function(){alert(this.value)}也还是undefined。 
// 但这里this指向没问题，是因为箭头函数有效是因为引擎在处理箭头函数时做了一点魔法。看下面。
```

# 深度理解下字段方法是箭头函数时this的情况
不是说箭头函数没有自己的this 是从词法作用域的外层寻找吗？
为什么这里class定义类字段为箭头函数呈现另一种结果？

```js
var name = 'jerry'; 
class Animal {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    sayName = function(){console.log(this.name);};

    sayAge = ()=>{console.log(this.age);}
}

let tom = new Animal('tom',19);
let [sayName, sayAge] = [tom.sayName, tom.sayAge];
sayName();  // undefined
sayAge();   // 正常输出19
```

不仅sayName里this.name是undefined，严格模式下，this其实也是undefined
这个很好理解，函数执行上下文的this由调用该函数的对象确定

为什么sayAge()因为采用箭头函数的定义方式就可以保存实例对象的this呢？
不是说箭头函数的this是认准词法作用域，在书写时确定的吗？

真正原因我们用 babel 把上面这段代码编译到 ES5 看一下就能明白了
省略掉无关编译结果：


```js
var Animal = function Animal(name, age) {
  var _this = this;  // 根源在这！ 解释器保存了实例的this 并且在箭头函数里直接使用了该_this

  _classCallCheck(this, Animal);

  _defineProperty(this, "sayName", function () {
    console.log(this.name);
  });

  _defineProperty(this, "sayAge", function () {
    console.log(_this.age);
  });

  this.name = name;
  this.age = age;
};
```

注意两个_defineProperty 的回调函数内对于 this 的使用方式。一个是直接用了 this，一个用了构造实例的闭包，所以一个 this 会丢失（成为undefined），而另一个不会。
结合「箭头函数不具有自己的 this，它的 this 永远是定义时包裹它的代码块的 this」，就可以理解为什么 ES6 编译到 ES5 是这样的实现。其实还是作用域、执行上下文、闭包的问题。

说到底还是解释器硬绑定，和语法本身关系不大，虽然很方便，但个人觉得这破坏了语言的统一性。
「箭头函数不具有自己的 this，它的 this 永远是定义时外层词法作用域的 this」这句话的后半句是不对的，箭头函数作为class的field时候，会绑定当前对象，是解释器的trick，其它时候都是从作用域链中获取，而不是定义时的代码块。

