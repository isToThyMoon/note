---
title: 01.编译原理下的作用域
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - root
---

几乎每一种编程语言，它最基本的能力都是能够存储变量值、并且允许我们通过变量来对变量值进行访问和修改。

有了变量之后，应该把它放在那里、程序如何找到它们？这需要我们提前约定好一套**存储变量、访问变量的规则**，这套规则，就是我们常说的作用域。但更多时候，我们提到作用域，指的是这个规则约束下的一个变量、函数、标识符可以被访问的所在区域（这时它就更具体了）。

理解作用域的实现机制，我们需要结合编译原理一起来看。

```js
一个语句：`var name = 'dada'`
JS 会怎么理解？
在我们看来，这只是一个声明语句。但是在 JS 引擎眼里，它却包含了两个声明：
var name （编译时处理）
name = ‘dada’ （运行时处理）

编译阶段：编译器主要确定作用域规则。
执行阶段： 这时登场的就是大家常常听到的JS 引擎了。JS 引擎在执行代码的时候，仍然会找遍当前作用域，看看是不是有一个叫 name 的家伙。如果能找到，那么万事大吉，给你赋值。如果找不到，它也不会灰心，它会从当前作用域里 “探出头去”，看看 “外面” 有没有，或者 “外面的外面” 有没有。如果最终仍然找不到 name 变量，引擎就会抛出一个异常。

这里出现了一个有趣的东西，就是我们引擎的查找过程 —— 何谓探出头去？何谓 “外面” 呢？这就引出了我们 JS 作用域里一个非常重要的概念。作用域链。
```

然而，js不是不存在编译阶段的动态语言吗？ 编译只有静态语言才有，高级语句被编译成机器可读的机器码后被执行。

我们知道，javascript是单线程的解释性语言，单线程就是先执行完一个，再执行另一个，解释性语言就是先翻译一行，再执行一行，先翻译一行，再执行一行，但是js在执行之前通常会先通篇扫描一遍代码，而先不执行，通篇扫描就是看看代码有没有什么低级语法错误，这个过程（通篇扫描）就叫语法（义）分析。

所以事实上，JS 也是有编译阶段的，它和传统静态编译语言的区别在于，JS不会早早地把编译工作做完，而是一边编译一边执行。简单来说，所有的 JS 代码片段在执行之前都会被编译，只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。

编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码（全局代码、函数代码、eval代码），执行上下文在这个阶段创建。

也就是：

编译阶段：
* 词法分析 语法分析 语义检查 生成正确语法树 生成最后字节码
* 作用域规则确定
执行阶段：
* 创建执行上下文
* 执行可执行代码
* 垃圾回收

庞大的代码里必然不会只有一两个函数，那么如何管理每次执行函数时候创建的上下文呢？js引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。

# 作用域链。

作用域套作用域，就有了作用域链。

现在我们已经知道，作用域本质上就是程序存储和访问变量的规则。上个小节，我们聊过了作用域在 JS 这门语言中的实现机制。现在，我们来看看，这套规则的内容具体是怎么回事儿。

JS 世界中，目前已经有了三种作用域：
* **全局作用域** 声明在任何函数之外的顶层作用域的变量就是全局变量，这样的变量在 全局作用域
* **函数作用域** 在函数内部定义的变量，在函数作用域
* **块作用域** ES6 开始，我们迎来了了两个用于声明变量的新关键词: let 和 const。这两个关键字定义的变量，如果被一个大括号 { } 这样括住了，那么这个大括号就是一个代码块，大括号括住的这些变量就形成了一个块作用域

在变量的查找过程中，嵌套最多的情况，从块作用域到外层函数作用域到全局作用域，这个过程中形成了一条作用域链。

变量的查找过程遵循原则有词法作用域、动态作用域。这是下面的内容。