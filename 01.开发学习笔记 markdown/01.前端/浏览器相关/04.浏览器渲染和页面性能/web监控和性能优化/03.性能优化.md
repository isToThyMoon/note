# 性能优化
比如你说你优化了一个前端项目的首屏性能，降低了白屏时间，那么面试官对这个性能优化问题会进行深挖，来考察候选人的实际水平：

你的性能优化指标是怎么确定的？平均下来时间减短了多少？
你的性能是如何测试的？有两种主流的性能测试方法你是怎么选的？
你是根据哪些指标进行针对性优化的？
除了你说的这些优化方法还有没有想过通过xx来解决？
你的这个优化方法在实际操作中碰到过什么问题吗？有没有进一步做过测试？
我们假设这么一种情况，比如xxxx，你会这么进行优化？

性能优化、关注的性能指标，白屏 卡顿 崩溃研究。

react优化：
antd大表格双滚动条问题，

antd多input卡顿。

echarts动态数据低端设备不流畅卡顿，可以使用requestAnimationFrame内分批添加数据。公司信息查询页，查询结果是一个公司item的从上至下的瀑布流，首次加载过多，或者用户滚动加载，数据量越来越大时出现卡顿。
C端优化：
针对FCP LCP DCL进行优化。

node中间层解决后端文档下载内嵌echarts图表的问题

## 性能优化

H5面向C端用户比较多，这方面更应该关心一些性能指标数据，比如FP，FCP等等，围绕这些指标进行优化。

网站速度是可靠的 SEO（搜索引擎优化）策略的关键部分。性能对于 Google 搜索引擎排名尤为重要。DCL 和 FCP 是 Google 评估性能时强调的两个指标，而 Google PageSpeed Insights 可以帮助开发人员对其进行评估。（尽管 Google 并未具体说明这两个性能指标对于搜索排名的影响有多大，但肯定将它们考虑在内。）

优化主要也考虑这两个指标时间的缩短。

利用缓存和利用 CDN 是缩短 DCL 和 FCP 时间的两个基本措施。

made-in-china.com 优化后：
FP/FCP：586ms
LCP：849ms
DCL：1.2s
L：1.36s



优化主要对象是关键渲染路径：
关键渲染路径（Critical Rendering Path）是指在网页加载过程中，浏览器必须执行的一系列关键步骤，以将 HTML、CSS 和 JavaScript 转换为用户可以看到的页面。这个过程的优化对于提高网页加载性能和用户体验非常重要。

关键渲染路径包括以下主要步骤：

解析 HTML（HTML Parsing）：浏览器从服务器接收到 HTML 文件后，会解析该文件，构建文档对象模型（DOM）。这个过程将 HTML 标记转换为表示网页结构的数据结构。

解析 CSS（CSS Parsing）：浏览器解析 CSS 样式表，并构建样式规则树（CSS Rule Tree）。这个过程确定了每个 HTML 元素应该如何渲染的样式信息。

构建渲染树（Render Tree Construction）：浏览器将 DOM 树和 CSS 样式规则树组合成渲染树（Render Tree）。渲染树只包含需要呈现在屏幕上的元素，隐藏元素不会包括在渲染树中。

布局（Layout）：浏览器计算每个元素在屏幕上的准确位置和尺寸，这个过程称为布局。布局的计算基于渲染树中的元素以及它们的样式信息。

绘制（Painting）：一旦布局完成，浏览器根据布局信息将页面的内容绘制到屏幕上，创建一个位图。这个位图包含了可见内容的像素信息。

合成（Compositing）：如果页面包含多个图层（例如，使用 CSS 3D 变换或动画效果创建的图层），浏览器会将这些图层合成为最终的页面图像。

显示（Display）：最终，渲染的位图会被发送到显示设备，呈现给用户。


为了尽快完成关键渲染路径，应当最大限度减小三种可变元素：关键资源的数量、大小，关键路径长度。具体如下：

减少关键资源的数量：删除它们、延迟它们的下载（懒加载），将它们标记为异步等。
减小传送大小：压缩代码，利用缓存等。
优化关键资源的加载顺序：尽可能提早下载（预加载），以缩短关键路径长度。


浏览器在能够渲染任何内容之前，需要将 HTML 标记解析为 DOM 树。如果 HTML 解析器遇到任何外部样式表（<link rel="stylesheet">）或同步 JavaScript 标签（<script src="main.js">），则会暂停解析。

脚本和样式表都是阻塞渲染的资源，这些资源会使 FCP 延迟，进而导致 LCP 延迟。延迟加载任何非关键的 JavaScript 和 CSS，从而提高网页主要内容的加载速度。

1.压缩css资源：
对于 webpack：optimize-css-assets-webpack-plugin
对于 Gulp：gulp-clean-css
对于 Rollup：rollup-plugin-css-porter
提升0.6秒。

2.通过chrome的coverage选项卡查看网页未使用的css和js资源并优化。
*将未使用的css js资源完全删除或者移动到另一个样式表。
*对于任何初始渲染时不需要的 CSS，请使用 loadCSS 来异步加载文件，这里运用了rel="preload"和onload。

异步加载css
```
<link rel="preload" href="stylesheet.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="styles.css"></noscript>
```
这不是加载 CSS 的标准方式。以下是工作原理：
*link rel="preload" as="style" 异步请求样式表。您可以在预加载关键资产指南中了解有关 preload 的更多信息。
*link 的 onload 属性允许在加载 CSS 完成后对其进行处理。
*在使用 onload 处理程序后将其“归零”有助于某些浏览器避免在切换 rel 属性时重新调用处理程序。
*对 noscript 元素内的样式表的引用可作为不执行 JavaScript 的浏览器的后备。

提升0.2秒

异步加载css优化之后，可以在performance追踪到FCP标记出现在了css请求之前，这意味着浏览器在渲染页面之前不需要等待css加载

3.内联关键 CSS
通过把用于首屏内容的任何关键路径 CSS 直接包括在<head>中来将这些 CSS 进行内联。
如果您无法为您的网站手动添加内联样式，请使用库来将该过程自动化。一些示例：
Critical、CriticalCSS 和 Penthouse 都是提取和内联首屏 CSS 的包
Critters 是一个 webpack 插件，能够内联关键 CSS 并对其余部分进行懒加载
提升0.5秒


4.减少 JavaScript 阻塞时间
削减和压缩 JavaScript 文件
延迟加载未使用的 JavaScript
最大限度减少未使用的 polyfill

5.优化和压缩图像
首先考虑不使用图像。如果图像与内容无关，请将其删除。
压缩图像（例如使用 Imagemin）
将图像转换为更新的格式（JPEG 2000、JPEG XR 或 WebP）
使用响应式图像
考虑使用图像 CDN

图片懒加载：
1.Chrome浏览器的IMG图片和IFRAME框架会支持原生懒加载特性，使用loading="lazy"语法。
让一张图片在靠近浏览器视窗的时候才加载。
`<img src="./example.jpg" loading="lazy" alt="dada">`
但Lazy loading加载数量与屏幕高度有关，高度越小加载数量越少，但并不是线性关系。
Lazy loading加载数量与网速有关，网速越慢，加载数量越多，但并不是线性关系。
滚动即会触发图片懒加载，不会说滚动一屏后再去加载。
窗口resize尺寸变化也会触发图片懒加载，当屏幕高度从小变大的时候。

`var isSupportLoading = 'loading' in new Image();`检测浏览器是否原生支持图片懒加载。

2.需要将图片的地址放到 data-src 属性里，而src值不需要，直接将src属性去掉。
所有具有data-src属性的图片，我们将其初始显示状态为不可见，通过透明度来调节：
```
img {
	opacity: 1;
	transition: opacity 0.3s;
}

img[data-src] {
	opacity: 0;
}
```

我们最终会将 data-src 属性去掉，换成src属性，但这是图片加载成功后的动作：
```
[].forEach.call(document.querySelectorAll('img[data-src]'), function(img) {
	img.setAttribute('src', img.getAttribute('data-src'));
	img.onload = function() {
		img.removeAttribute('data-src');
	};
});
```
相比起其它各种的图片延迟加载技术，这种方法非常的简单，它几乎不要求其它任何条件，可以用在任何地方，使用起来非常灵活。

当然，简单有简单的好坏，也会因为简单而不足。它不具有图片图片滚动到可视窗口内再加载的功能。

3.滚动时监听，el.offsetTop - document.documentElement.scrollTop <= viewPortHeight
需要实现图片加载前loading的效果的话，我们就可以给img的src设为loading图片的路径，data-src设为图片真实路径，在上述callback函数，将data-src的值赋给src即可

4.getBoundingClientRect

5.Intersection Observer
判断两个元素是否重叠，因为不用进行事件的监听，性能方面相比getBoundingClientRect会好很多



## 代码规范
优化 JavaScript 执行：
对于动画效果的实现，避免使用setTimeout或setInterval，请使用requestAnimationFrame。
将长时间运行计算的 JavaScript 从主线程移到 Web Worker。
使用微任务来执行对多个帧的 DOM 更改。

缩小样式计算的范围并降低其复杂性：
降低选择器的复杂性，比如BEM命名规范。
减少在元素更改时需要计算的工作量。

避免大型、复杂的布局和布局抖动：
布局的作用范围一般为整个文档。
DOM 元素的数量将影响性能；应尽可能避免触发布局。
避免强制同步布局和布局抖动；先读取样式值，然后进行样式更改。

简化绘制的复杂度、减小绘制区域（减少重排 以重绘代替）：
除transform或opacity属性之外，更改任何属性始终都会触发绘制。
通过层的提升和动画的编排来减少绘制区域。

使输入处理程序去抖：
避免长时间运行输入处理程序；它们可能阻止滚动。
不要在输入处理程序中进行样式更改（将触发强制同步布局）。
使滚动处理程序去除抖动。


# 优化

## js脚本放在页面body底部，尽快让页面得到渲染。
## http请求带来额外开销，减少外链脚本数量。
## 动态脚本加载。因为无论何时启动下载，文件的下载和执行都不会阻塞页面其他进程。
```js
function laodScript(url,callback){
    var script = document.createElement('script');
    script.type = 'text/javascript';

    if(script.readyState){  // ie
        script.onreadystatechange = function(){
            if(script.readyState == 'loaded' || script.readyState == 'complete'){
                script.onreadystatechange = null;
                callback()
            }
        }
    }else{ //其他浏览器
        script.onload = function(){
            callback()
        }
    }
    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
}

// 使用
loadScript('./a.js',function(){
    loadScript('./b.js',function(){
        loadScript('./c.js',function(){
            console.log('加载完成')
        })
    })
})
```