


# 
卡顿：页面严重的掉帧现象。卡顿更严重进一步就是崩溃。

前端页面卡顿的原因有很多，从渲染机制和运行上可以分为两大类：
渲染不及时，页面掉帧（js线程长时间占用 页面回流和重绘较多 资源加载阻塞）
网页内存占用过高，运行卡顿（内存泄漏直接爆掉就是页面崩溃）

# 渲染问题
渲染不及时的原因：
浏览器的渲染频率一般是60HZ，即要求1帧的时间为1s / 60 = 16.67ms，浏览器显示页面的时候，要处理js逻辑，还要做渲染，每个执行片段不能超过16.67ms。实际上，浏览器内核自身支撑体系运行也需要消耗一些时间，所以留给我们的时间差不多只有10ms。
常见的优化方式：
采用requestIdleCallback和requestAnimationFrame，任务分片

页面回流和重绘较多：
尽量减少layout
获取scrollTop、clentWidth等维度属性时都会触发layout以获取实时的值，所以在for循环里面应该把这些值缓存一下
资源加载阻塞：
js资源放在body之前
行内script阻塞
css加载会阻塞DOM树渲染（css并不会阻塞DOM树的解析）
资源过大阻塞

# 内存问题
意外的全局变量引起的内存泄漏
闭包引起的内存泄漏
被遗忘的定时器
循环引用
DOM删除时没有解绑事件
没有清理的DOM元素引用

    
# 监控卡顿
Performance

1.在浏览器的DevTools -> Sources -> Ctrl+Shift+P -> 输入FPS，观察网页的fps帧数，是否会有大幅度帧数变化
2.在浏览器的DevTools -> Performance -> 点击中间的圆点开始记录。定位一个页面的运行是否有卡顿，最简单又直接的方式是录制 Performance。Performance 会把耗时长的任务直接标记为红色，我们可以根据这些任务，查找和分析具体产生耗时的脚本是哪些，然后去做优化。

但是，Performance 仅对开发者来说比较方便，在真实用户的使用场景里，未必有条件能提供 Performance 的录制。更多的时候，我们只能粗略地监控用户的卡顿情况，发现这样的场景，并尝试去解决。



requestAnimationFrame
一般来说我们监控卡顿，可以考虑使用window.requestAnimationFrame方法。该方法会在绘制下一帧绘制前被调用，这意味着当前的同步计算任务即将结束。


前面也有说到，卡顿大多数是因为长耗时的计算任务导致的。那么，我们就可以考虑在某个函数执行之前记下时间戳，而在window.requestAnimationFrame的时候再取其中的时间差，判断当前函数的执行耗时是否合理。

当然，该方案并不是完全准确，因为我们常常会在一个函数中间调用另外一个函数，还可能会同步抛出事件通知，执行其他的计算任务。

不过，考虑到真实的线上用户里无法直接使用 Performance，这也算是一个能做卡顿监控的方案。我们可以配合日志、其他不同的监控和上报等，来做更多的问题定位。

或者：
由于浏览器每帧刷新都会调用该回调，那我们可以记录某个时间段帧刷新的次数，然后除以该时间，那就可以得出当前时间段的帧率啦（一般设置1秒比较好计算和理解），把 FPS 存起来，如果连续多次 FPS 低于某个设定的临界值，我们就上报数据，核心内容就是这么简单~

另外要注意的是，由于该函数每秒约被调用60次，属于比较高频的了，不能够为了检测性能问题去引入性能问题，而且我们也没必要时刻去检测，所以可以通过设定一个定时器，在一定时间内只检测一次，这样就可以避免造成额外的负担

```js
const framesMonitor = (() => {
  // const SIXTY_TIMES = 60;
  const requestAnimationFrame = window.requestAnimationFrame;
  if (requestAnimationFrame) {
    return (cb) => {
      const timer = requestAnimationFrame(() => {
        cb();
        window.cancelAnimationFrame(timer);
      });
    };
  // requestAnimationFrame 兼容实现
  }
})();
const ONE_SECOND = 1000

function stuck() {
  const stucksFPS = [];
  const startTime = Date.now();
  const loop = (startCountTime = Date.now(), lastFrameCount = 0) => {
    const now = Date.now();
    // 每一帧进来，计数+1，传参累计
    const accFrameCount = lastFrameCount + 1;
    // console.log('accFrameCount', accFrameCount)
    // 大于等于一秒钟为一个周期；比如如果是正常的fps： 那当第61次时，按最优1秒60帧，即(1/60)*61 = 1017毫秒，这里就满足
    if (now > ONE_SECOND + startCountTime) {
      // 计算经过的时间间隔值，换算成秒
      const timeInterval = (now - startCountTime) / ONE_SECOND;
      // 计算一秒钟的fps： 当前计数总次数 / 经过的时长；
      const fps = Math.round(accFrameCount / timeInterval);
      if (fps > 30) { // fps 小于30 判断为卡顿
        stucksFPS.pop();
      } else {
        stucksFPS.push(fps);
      }
      // 连续三次小于30 上报卡顿（还有一种特殊情况，前面2次卡顿，第三次不卡，接着再连续两次卡顿，也满足）
      if (stucksFPS.length === 3) {
          console.log(new Error(`Page Stuck captured: ${location.href} ${stucksFPS.join(',')} ${now - startTime}ms`));
        // 清空采集到的卡顿数据
        stucksFPS.length = 0;
      }
      // 避免持续采集，休息一个周期（这里定义的是一分钟），重新开启采样
      const timer = setTimeout(() => {
        loop();
        clearTimeout(timer);
      }, 60 * 1000);
      return;
    }
    framesMonitor(() => loop(startCountTime, accFrameCount));
  };
  loop();
};
```