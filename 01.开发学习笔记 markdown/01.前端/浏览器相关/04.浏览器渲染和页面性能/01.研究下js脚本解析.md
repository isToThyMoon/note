
js解析如下：

1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此 时document.readystate为loading

2. HTML解析器遇到没有async和defer的script时，将他们添加到文档中，然后执⾏⾏内 或外部脚本 。这些脚本会同步执⾏， 并且在脚本下载和执⾏时解析器会暂停 。这样就可 以用document.write()把文本插⼊到输⼊流中 。同步脚本经常简单定义函数和注册事件 处理程序，他们可以遍历和操作script和他们之前的文档内容

3. 当解析器遇到设置了async属性的script时， 开始下载脚本并继续解析文档 。脚本会在它 下载完成后尽快执行，但是解析器不会停下来等它下载 。异步脚本禁止使用 document.write()， 它们可以访问自⼰script和之前的文档元素

4. 当文档完成解析，document.readState变成interactive

5. 所有defer脚本会按照在文档出现的顺序执行，延迟脚本能访问完整文档树， 禁止使用 document.write()

6. 浏览器在Document对象上触发DOMContentLoaded事件

7. 此时文档完全解析完成， 浏览器可能还在等待如图片等内容加载， 等这些内容完成载入 并且所有异步脚本完成载入和执行，document.readState变为complete，window触发 load事件

# 几个basic concept：

## 单线程JS
首先，js是单线程的。

历史原因，在创建 JavaScript 这门语言时，多进程多线程的架构并不流行，硬件支持并不好，其次是因为多线程的复杂性，如果 JavaScript 是多线程的方式来操作这些 UI DOM，则可能出现 UI 操作的冲突，在多线程的交互下，处于 UI 中的 DOM 节点就可能成为一个临界资源，假设存在两个线程同时操作一个 DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。

当然我们可以通过锁来解决上面的问题，但为了避免因为引入了锁而带来更大的复杂性，JavaScript 在最初就选择了单线程执行。

但页面中多个script资源是并发下载的（下载线程是单独的，多个script资源肯定是并发下载更有效率），所以说，web中的js默认情况下（非defer async）是**并发下载，同步执行**。

## 渲染线程和JS线程互斥
由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了，因此为了防止渲染出现不可预期的结果，浏览器『设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系』

当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行，浏览器在执行 JavaScript 程序的时候，GUI 渲染线程会被保存在一个队列中，直到 JavaScript 程序执行完成，才会接着执行

因此如果 JavaScript 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

## DOMContentLoaded 与 onload 的区别
当 DOMContentLoaded 事件触发时，仅当 DOM 解析完成后，不包括样式表和图片，
我们在上面提到过，CSS 加载会阻塞 DOM 的渲染和后面 JavaScript 的执行，
JavaScript 会阻塞 DOM 解析

所以我们可以得到结论，当文档中没有脚本时，浏览器解析完文档便能触发 DOMContentLoaded 事件，如果文档中包含脚本，则脚本会阻塞文档的解析，而脚本需要等 CSSOM 构建完成才能执行，在任何情况下，DOMContentLoaded 的触发不需要等待图片等其他资源加载完成

而当 onload 事件触发时，页面上所有的 DOM，样式表，脚本，图片等资源已经加载完毕，所以流程应该是由 DOMContentLoaded 先 onload后

 
# 同步脚本阻塞渲染线程的问题
以下描述里“加载”大致等于“下载”。页面里的js有加载和执行两步。

当浏览器加载 HTML 时遇到 `<script>...</script>` 标签，渲染线程和js线程互斥，渲染线程被挂起，浏览器就不能继续构建 DOM。它必须立刻执行此脚本。对于外部脚本 `<script src="..."></script>` 也是一样的：浏览器必须等脚本下载完，并执行结束，之后重新唤醒渲染线程继续处理剩余的页面。

对于资源下载，其实一般来说浏览器都做了预解析优化，渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前并发下载这些文件。

如果要优化资源下载，也有一些相关的策略来规避，比如使用CDN来加速JavaScript文件的加载，压缩JavaScript文件的体积。

重点是js的执行阻塞渲染引擎。

有两个重要的问题：

- 脚本不能访问到位于它们下面的 DOM 元素，因此，脚本不能给它们添加事件等，访问未解析的dom会出错。
- 如果页面顶部有一个庞大的脚本，它会“阻塞页面”。在脚本下载并执行结束前，用户都不能看到页面内容。

解决方法可以把脚本放在页面底部，此时，它可以访问到它上面的元素，并且不会阻塞页面显示内容。但是这样的方案绝非完美。~~例如：浏览器只有在下载完整的 HTML 文档后才会注意到脚本（并且开始下载它）。对于长的 HTML 文档来说，这样的延迟必须引起注意。（废弃，有预解析下载 不用考虑）~~ 其实页面底部脚本如果执行时间过长，还是会导致渲染引擎得不到时间片执行，页面白屏或者无响应，但这是两线程互斥的设计问题，你得确保js执行不要过分耗时。

另外，如果JavaScript文件中没有操作DOM相关代码，就可以将该JavaScript脚本设置为异步加载，通过async或defer来标记代码，使用方式如下所示：
`<script async type="text/javascript" src='foo.js'></script>`
或者
`<script defer type="text/javascript" src='foo.js'></script>`

async：脚本并行加载，加载完成之后立即执行，执行时机不确定，只要该脚本下载完成了且js引擎有空闲就立马执行，仍有可能阻塞HTML解析。
defer：脚本并行加载，等待HTML解析完成之后，按照加载顺序执行脚本，执行时机在DOMContentLoaded事件派发之前。

注意load事件在所有资源下载完成后触发。
DOMContentLoaded事件将在页面DOM解析完成后触发。

# defer
defer 属性告诉浏览器它应该继续处理页面，并在“后台”下载脚本，然后等页面处理完成后才开始执行此脚本。

具有 defer 属性的脚本不会阻塞页面的加载。
具有 defer 属性的脚本总是要等到 DOM 解析完毕，但在 DOMContentLoaded 事件之前执行。

立即下载但延迟执行，脚本会被延迟到整个页面解析完再运行。

## 脚本加载顺序
Defer 脚本保持他们的相对顺序，就像常规脚本一样。 所以，如果我们有一个长脚本在前，一个短脚本在后，那么后者执行就会等待前者。
```
<script defer src="https://javascript.info/article/script-async-defer/long.js"></script>
<script defer src="https://javascript.info/article/script-async-defer/small.js"></script>
```
短脚本先下载完成，但是后执行
浏览器解析页面找到 script 属性并并行下载它们，以提高性能。因此，在上面的实例中，两个脚本并行下载。small.js 可能会先下载完成。但是规范要求脚本按照文档顺序执行，因此它要等到 long.js 执行结束才会被执行。

defer 属性仅适用于外部脚本
defer 属性会忽略没有 src 属性的 <script> 脚本。

# async
async 属性意味着脚本是完全独立的：
目的是不让页面等待脚本下载和执行，而是异步加载页面其他内容。但仍然保持执行时阻塞渲染的特性，如果下载完成时页面dom还未构建完成，立即执行脚本并且会阻塞dom构建。

页面不会等待异步脚本下载，它会继续处理页面并显示内容，但是会等待脚本执行。（async脚本下载完成后会立即执行 阻塞DOM构建）
DOMContentLoaded 和 async 脚本不会彼此等待：
DOMContentLoaded 可能发生在异步脚本之前（此时异步脚本在页面加载完成后才下载完成）
DOMContentLoaded 也可能发生在异步脚本之后（此时异步脚本可能很短或者是从 HTTP 缓存中加载的）
其他脚本不会等待 async 脚本下载完成，同样 async 脚本也不会等待其他脚本下载。

## 动态脚本（Dynamic scripts）
我们也可以使用 JavaScript 动态地添加脚本：
```
let script = document.createElement('script');
script.src = "/article/script-async-defer/long.js";
document.body.append(script); // (*)
```
当脚本附加到文档 (*) 时，脚本就会开始加载（下载）：

默认情况下，动态脚本表现为“异步”行为。

这也就是说：
它们不会等待其他内容，其他的内容也不会等待它们。
先加载完成的脚本先运行（“加载优先” 顺序）

这么说动态脚本和async几乎无区别，不同点在于动态脚本开始下载的时间点在动态加载它的代码执行时。

# js对dom影响

1、JavaScript 脚本在html页面中 脚本有修改dom的操作（如innerText）
HTML 解析器先解析dom，遇到script标签，这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，脚本如果有修改dom的操作，执行脚本完毕后，dom节点已经修改完毕，脚本执行完成之后，HTML 解析器恢复解析过程，并且先渲染绘制已解析的dom（分布渲染），然后继续解析后续的内容，依次往复，直至生成最终的 DOM。
因为js能够执行修改dom的操作，所以如果js这时修改后面还未解析到的dom就会出错，这也是早期开发推荐将script资源引入放在html的body尾部的原因。

2、html页面中引入 JavaScript 文件 脚本有修改dom的操作（如innerText）
这段代码的功能还是和前面那段代码是一样的，不过这里我把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。
Chrome 浏览器对此做了很多优化，其中一个主要的优化是上面提到的预解析优化操作。

3、html页面中既有js引入，又有css样式

```html
//theme.css
div {color:blue}
​
<html>
    <head>
        <style src='theme.css'></style>
    </head>
<body>
    <div>1</div>
    <script>
        let div1 = document.getElementsByTagName('div')[0]
        div1.innerText = 'time.geekbang' // 需要 DOM
        div1.style.color = 'red' // 需要 CSSOM
    </script>
    <div>test</div>
</body>
</html>
```

这段话很重要：

该示例中，JavaScript 代码出现了 div1.style.color = ‘red' 的语句，它是用来操 纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM的，所以渲染线程在遇到 JavaScript 脚本时，线程挂起，js线程执行，但不管该脚本是否操纵了 CSSOM，都会先等待CSS 文件下载完成，解析CSSOM，再执行 JavaScript 脚本。
所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。
通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，
所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。




# 总结
![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d01aec620d34f0093d6c130380f06f4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image?)

* 没有 Async 和 Defer，浏览器会立即加载并执行指定的脚本，也就是说不等待后续载入的文档元素，读到就加载并执行。

* Async 属性表示异步执行引入的 JavaScript，与 Defer 的区别在于，如果已经加载好，就会开始执行，即无论此刻是 HTML 解析阶段还是 DOMContentLoaded 触发之后，不过需要注意的是，这种方式加载的 JavaScript 依然会阻塞 load 事件，换句话说，async-script 可能在 DOMContentLoaded 触发之前或之后执行，但一定在 load 触发之前执行

* Defer 属性表示延迟执行引入的 JavaScript，即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的，整个 document 解析完毕（dom资源准备就绪）且 defer-script 也加载完成之后（这两件事情的顺序无关），会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件

因此，我们可以得出结论：

* Defer 和 Async 在网络读取（下载）这部分是一样的，都是异步的（相较于 HTML 解析）
* 在加载多个 JavaScript 脚本的时候，Async 是无顺序的加载，而 Defer 是有顺序的加载
* 差别在于脚本下载完之后何时执行，显然 Defer 是最接近我们对于应用脚本加载和执行的要求的
* Async 是乱序执行，它的加载和执行是紧紧挨着的，所以不管声明的顺序如何，只要它加载完了就会立刻执行
* 通常来说，Async 对于应用脚本的用处不大，因为它完全不考虑依赖（哪怕是最低级的顺序执行），不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的