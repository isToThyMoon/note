---
title: 04.网络安全
categories:
  - 01.开发学习笔记 markdown
  - 07.前端
  - 00.网络相关
---


# https加密算法
先非对称加密传输对称的密钥，发送密文的一方使用对方的公钥进行加密处理『对称的密钥』，然后对方用自己的私钥解密拿到『对称的密钥』，这样可以确保交换的密钥是安全的前提下，使用对称加密方式进行通信，所以 HTTPS 采用对称加密和非对称加密两者并用的混合加密机制

# XSS 跨站域脚本攻击
XSS   发JavaScript在页面获取cookies等等 执行有害代码

XSS 全称“跨站脚本”，是注入攻击的一种。其特点是不对服务器端造成任何伤害，而是通过一些正常的站内交互途径，例如发布评论，提交含有 JavaScript 的内容文本。这时服务器端如果没有过滤或转义掉这些脚本，作为内容发布到了页面上，其他用户访问这个页面的时候就会运行这些脚本。

很难通过技术手段完全避免 XSS，但我们可以总结以下原则减少漏洞的产生：

1. 利用模板引擎 开启模板引擎自带的 HTML 转义功能。例如： 在 ejs 中，尽量使用 <%= data %> 而 不是 <%- data %> ； 在 doT.js 中，尽量使用 {{! data } 而不是 {{= data } ； 在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat 。 
2. 避免内联事件 尽量不要使用 onLoad="onload('{{data}}')" 、 onClick="go('{{action}}')" 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML 前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement 、 setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 
3. 时刻保持警惕 在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 
4. 增加攻击难度，降低攻击后果 通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度， 降低攻击的后果。 
5. 主动检测和发现 可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。

# CSRF 跨站请求伪造
Cross-site request forgery
跨站请求伪造，也被称为one-click attack 或者 session riding，通常缩写为CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 跟跨网站脚本相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经被认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

例子：
假如一家银行用以运行转账操作的URL地址如下： `https://bank.example.com/withdraw?account=AccoutName&amount=1000&for=PayeeName`

那么，一个恶意攻击者可以在另一个网站上放置如下代码： `<img src="https://bank.example.com/withdraw?account=Alice&amount=1000&for=Badman" />`

如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。

攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户的浏览器，让其以用户的名义运行操作。

我们知道，绝大多数网站是通过 cookie 等方式辨识用户身份（包括使用服务器端 Session 的网站，因为 Session ID 也是大多保存在 cookie 里面的），再予以授权的。所以要伪造用户的正常操作，最好的方法是通过 csrf 或链接欺骗等途径，让用户在本机（即拥有身份 cookie 的浏览器端）发起用户所不知道的请求。

# arp欺骗：
用户连上网络 首先寻找网关（路由） 黑客回应 我就是网关  那么以后的数据就会先进过黑客 黑客转发给真正的网关 这个不影响用户访问 但其实所有信息都已经泄露了

怎么解决： https 协议  数据经过加密后传输 数学保证其无法被破解 这个加密只有浏览器和服务器可以解析

# 介绍下 HTTPS 中间人攻击

https 协议由 http + ssl 协议构成，
中间人攻击过程如下：

1. 服务器向客户端发送公钥。 

2. 攻击者截获公钥，保留在自己手上。 

3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。 

4. 客户端收到伪造的公钥后，生成加密 hash 值发给服务器。 

5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥。

6. 同时生成假的加密 hash 值，发给服务器。

7. 服务器用私钥解密获得假秘钥。

8. 服务器用加秘钥加密传输信息


防范方法： 服务端在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性。


# 前端加密的常见场景和方法
## 密码传输 
前端密码传输过程中如果不加密，在日志中就可以拿到用户的明文密码，对用户安全不太负责。这种加密其实相对比较简单，
可以使用 PlanA-前端加密、后端解密后计算密码字符串的 MD5/MD6 存入数据库；
也可以 PlanB-直接前端使用一种稳定算法加密成唯一值、后端直接将加密结果进行 MD5/MD6，全程密码明文不出现在程序中。 
PlanA 使用 Base64 / Unicode+1 等方式加密成非明文，后端解开之后再存它的 MD5/MD6 。
PlanB 直接使用 MD5/MD6 之类的方式取 Hash ，让后端存 Hash 的 Hash 。

## 数据包加密 
应该大家有遇到过：打开一个正经网站，网站底下蹦出个不正经广告——比如 X 通的流量浮层，X 信的插入式广告……（我没有针对谁）但是这几年，我们会 发现这种广告逐渐变少了，其原因就是大家都开始采用 HTTPS 了。被人插入 这种广告的方法其实很好理解：你的网页数据包被抓取->在数据包到达你手机 之前被篡改->你得到了带网页广告的数据包->渲染到你手机屏幕。而 HTTPS 进 行了包加密，就解决了这个问题。严格来说我认为从手段上来看，它不算是一 种前端加密场景；但是从解决问题的角度来看，这确实是前端需要知道的事情。 
Plan 全面采用 HTTPS

## 展示成果（网页内容）加密
经常有人开发网页爬虫爬取大家辛辛苦苦一点一点发布的数据成果，有些会影 响你的竞争力，有些会降低你的知名度，甚至有些出于恶意爬取你的公开数据后进行全量公开……比如有些食谱网站被爬掉所有食谱，站点被克隆；有些求职网站被爬掉所有职位，被拿去卖信息；甚至有些小说漫画网站赖以生存的内容 也很容易被爬取。

将文本内容进行展示层加密，利用字体的引用特点，把拿给爬虫的数据变 成“乱码”。举个栗子：正常来讲，当我们拥有一串数字“12345”并将其放在网站 页面上的时候，其实网站页面上显示的并不是简单的数字，而是数字对应的字 体的“12345”。这时我们打乱一下字体中图形和字码的对应关系，比如我们搞成 这样：
图形：1 2 3 4 5 字码：2 3 1 5 4 这时，如果你想让用户看到“12345”，你在页面中渲染的数字就应该是“23154”。 这种手段也可以算作一种加密。