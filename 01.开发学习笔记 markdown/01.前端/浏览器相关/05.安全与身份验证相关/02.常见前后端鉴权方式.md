# 
主流登录方式的实现：

Cookie Session 验证
Token 验证（包含JWT SSO）
OAuth 开放授权 第三方验证

但是其实就两种登录方式：seesion 和 token 方式，其他都是它们的一种架构实现。

## Cookie➕Session登录
Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。

在 B/S 系统中，登录功能通常都是基于 Cookie 来实现的。当用户登录成功后，一般会将登录状态记录到 Session 中。

SessionId作为set-Cookie内容返回给浏览器，并在后续每次请求中作为Cookie携带发送给服务器验证。

优缺点：
cookie因为存储在客户端，容易被客户端篡改，使用前需要验证合法性。
cookie体积限制
cookie无法跨域
移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token

由于服务器端需要对接大量的客户端，也就需要存放大量的 Session，这样会导致服务器压力过大（现代计算机服务器基本没问题）。
如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，无形中增加了服务器端维护成本。
sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？ 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现
由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击。


## Token

为了解决 Cookie + Session 机制暴露出的诸多问题，我们可以使用 Token 的登录方式。

常说的JWT是生成Token的一种方式。决定了Token的自声明格式。

Token 是通过服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。

这个 token 一般是放在一个叫 authorization 的 header 里。

一般会有access token和refresh token两种。refresh token有效期比access token长，用于刷新token。

最常见的 Token 生成方式是使用 JWT（Json Web Token），它是一种简洁的、自包含的方法，用于通信双方之间以 JSON 对象的形式安全的传递信息。

使用 Token 后，服务器端并不会存储 Token，那怎么判断客户端发过来的 Token 是合法有效的呢？
答案其实就在 Token 字符串中，其实 Token 并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串。
JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）。

header 部分指定了该 JWT 使用的签名算法；
playload 部分表明了 JWT 的意图；
signature 部分为 JWT 的签名，主要为了让 JWT 不能被随意篡改。

优缺点：
服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。
通过查询时间来换服务器端不存储token，redis适合应对token查询的需求。
Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性（不需要cookie所以避免csrf攻击问题）。
Token 下发之后，只要在生效时间之内，就一直有效，但是如果服务器端想收回此 Token 的权限，并不容易。

有了 Token 之后，登录方式已经变得非常高效。


## 单点登录SSO
单点登录是指在同一帐号平台下的多个应用系统中，用户只需登录一次，即可访问所有相互信任的应用系统。本质就是在多个应用系统中共享登录状态。比如登录了淘宝后，天猫网站也无需重复验证登录即可访问。

SSO 机制实现方式
单点登录主要有三种实现方式：

父域 Cookie(同域名下的单点登录)
认证中心
LocalStorage 跨域

一般情况下，用户的登录状态是记录在 Session 中的，要实现共享登录状态，就要先共享 Session，但是由于不同的应用系统有着不同的域名，尽管 Session 共享了，但是由于 SessionId 是往往保存在浏览器 Cookie 中的，因此存在作用域的限制，无法跨域名传递，也就是说当用户在 a.com 中登录后，Session Id 仅在浏览器访问 a.com 时才会自动在请求头中携带，而当浏览器访问 b.com 时，Session Id 是不会被带过去的。实现单点登录的关键在于，如何让 Session Id（或 Token）在多个域中共享。

### 父域 Cookie
利用 Cookie 的这个特点，可以将 Session Id（或 Token）保存到父域中就可以了。我们只需要将 Cookie 的 domain 属性设置为父域的域名（主域名），同时将 Cookie 的 path 属性设置为根路径，将 Session ID（或 Token）保存到父域中。这样所有的子域应用就都可以访问到这个 Cookie。

此种实现方式比较简单，但不支持跨主域名。


如果是不同域的情况下，Cookie是不共享的，这里我们可以部署一个认证中心，用于专门处理登录请求的独立的 Web 服务。

### 认证中心
我们可以部署一个认证中心，认证中心就是一个专门负责处理登录请求的独立的 Web 服务。

用户统一在认证中心进行登录，登录成功后，认证中心记录用户的登录状态，并将 Token 写入 Cookie。（注意这个 Cookie 是认证中心的，应用系统是访问不到的）

访问应用系统时，检查当前请求有没有 Token，如果没有，说明用户在当前系统中尚未登录，那么就将页面跳转至认证中心进行登录。由于这个操作会将认证中心的 Cookie 自动带过去，因此，认证中心能够根据 Cookie 知道用户是否已经登录过了。如果认证中心发现用户尚未登录，则返回登录页面，等待用户登录，如果发现用户已经登录过了，就不会让用户再次登录了，而是会跳转回目标 URL ，并在跳转前生成一个 Token，拼接在目标 URL 的后面，回传给目标应用系统。

应用系统拿到 Token 之后，还需要向认证中心确认下 Token 的合法性，防止用户伪造。确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（这个 Cookie 是当前应用系统的，其他应用系统是访问不到的）当用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了。

总结：此种实现方式相对复杂，支持跨域，扩展性好，是单点登录的标准做法。

SSO 机制实现流程：
用户首次访问时，需要在认证中心登录：

1.用户访问网站  a.com 下的 pageA 页面。
2.由于没有登录，则会重定向到认证中心，并带上回调地址 `www.sso.com?return_uri=a.com/pageA`，以便登录后直接进入对应页面。
3.用户在认证中心输入账号密码，提交登录。
4.认证中心验证账号密码有效，将认证中心 sso.com 的登录态写入 Cookie。然后重定向`a.com?ticket=123 `带上授权码 ticket（token）
5.重定向时等于一次携带token的访问页面，在 a.com 服务器中，拿着 ticket 向认证中心确认授权码 ticket 真实有效。
6.确认无误后，应用系统记录用户的登录状态，并将 Token 写入 Cookie，然后给本次访问放行。（注意这个 Cookie 是当前应用系统的）（此时客户端有 2 个 Cookie 分别存有 a.com 和 sso.com 的登录态）。用户再次访问当前应用系统时，就会自动带上这个 Token，应用系统验证 Token 发现用户已登录，于是就不会有认证中心什么事了

认证中心登录完成之后，继续访问 a.com 下的其他页面，这个时候，由于 a.com 存在已登录的 Cookie 信息，所以服务器端直接认证成功。

如果认证中心登录完成之后，访问 b.com 下的页面：这个时候，由于认证中心存在之前登录过的 Cookie，所以也不用再次输入账号密码，直接返回第 4 步，下发 ticket 给 b.com 即可。


### LocalStorage 跨域
单点登录的关键在于，如何让 Session Id（或 Token）在多个域中共享。但是 Cookie 是不支持跨主域名的，而且浏览器对 Cookie 的跨域限制越来越严格。
在前后端分离的情况下，完全可以不使用 Cookie，我们可以选择将 Session Id （或 Token ）保存到浏览器的 LocalStorage 中，让前端在每次向后端发送请求时，主动将 LocalStorage 的数据传递给服务端。这些都是由前端来控制的，后端需要做的仅仅是在用户登录成功后，将 Session Id （或 Token ）放在响应体中传递给前端。
在这样的场景下，单点登录完全可以在前端实现。前端拿到 Session Id （或 Token ）后，除了将它写入自己的 LocalStorage 中之外，还可以通过特殊手段将它写入多个其他域下的 LocalStorage 中。

就是postMessage跨页面通信：
```
// 发送消息
const childWindow = document.getElementById("child").contentWindow;
childWindow.postMessage("Hello from parent!", "https://child.example.com");

// 接收消息
window.addEventListener("message", function(event) {
  if (event.origin === "https://child.example.com") {
    console.log("Received message from child: " + event.data);
  }
});
```
具体实现：
```
// 获取 token
var token = result.data.token;
 
// 动态创建一个不可见的iframe，在iframe中加载一个跨域HTML
var iframe = document.createElement("iframe");
iframe.src = "http://app1.com/localstorage.html";
document.body.append(iframe);
// 使用postMessage()方法将token传递给iframe
setTimeout(function () {
    iframe.contentWindow.postMessage(token, "http://app1.com");
}, 4000);
setTimeout(function () {
    iframe.remove();
}, 6000);
 
// 在这个iframe所加载的HTML中绑定一个事件监听器，当事件被触发时，把接收到的token数据写入localStorage
window.addEventListener('message', function (event) {
    localStorage.setItem('token', event.data)
}, false);
```
前端通过 iframe+postMessage() 方式，将同一份 Token 写入到了多个域下的 LocalStorage 中，前端每次在向后端发送请求之前，都会主动从 LocalStorage 中读取 Token 并在请求中携带，这样就实现了同一份 Token 被多个域所共享


总结：此种实现方式完全由前端控制，几乎不需要后端参与，同样支持跨域。


## SSO 单点登录退出
目前我们已经完成了单点登录，在同一套认证中心的管理下，多个产品可以共享登录态。现在我们需要考虑退出了，即：在一个产品中退出了登录，怎么让其他的产品也都退出登录？
原理其实不难，可以在每一个产品在向认证中心验证 ticket(token) 时，其实可以顺带将自己的退出登录 api 发送到认证中心。
当某个产品 c.com 退出登录时：

清空 c.com 中的登录态 Cookie。
请求认证中心 sso.com 中的退出 api。
认证中心遍历下发过 ticket(token) 的所有产品，并调用对应的退出 api，完成退出。


## OAuth2.0
oauth流程:
浏览器请求，跳转授权服务器oauth认证，
完成认证，授权服务器颁发一个授权码（authorization code）并重定向用户回到应用程序。
浏览器重新请求koa/express服务器，服务器向oauth请求双token（使用这个授权码和自己的client id/secret向认证服务器申请访问令牌/刷新令牌（access token/refresh token）。授权服务器对这些信息进行校验，如果一切OK，则颁发access token/refresh token）
oauth返回access_token给koa/express服务。
服务器拿到token并生成存储session
给浏览器返回请求，通过set-cookie，向浏览器写入cookie。