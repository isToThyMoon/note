# 
# http版本（只在面试常问）
HTTP（Hypertext Transfer Protocol，超文本传输协议）是用于在网络上传输超文本（例如网页、图像、视频等）的协议。HTTP 的不同版本有不同的特性和性能改进。以下是一些主要的 HTTP 版本：

1. **HTTP/1.0**：
   - 发布于1996年。
   - 最早的 HTTP 版本。
   - 使用短连接，每个请求/响应对都需要单独的连接。
   - 性能相对较低，因为建立和关闭连接需要额外的时间。
   - 不支持请求的流水线处理，即一个请求必须等待前一个请求的响应。

2. **HTTP/1.1**：
   - 发布于1999年。
   - 引入了持久连接，允许多个请求/响应对共享同一个连接，减少了连接建立和关闭的开销。
   - 支持请求的流水线处理，允许多个请求在不等待响应的情况下发送。
   - 支持虚拟主机（Virtual Hosts），允许多个域名共享同一个 IP 地址。
   - 支持分块传输编码，用于传输大文件或流式数据。

3. **HTTP/2.0**：
   - 发布于2015年。
   - 引入了多路复用，允许多个请求/响应对同时在一个连接上传输。
   - 支持头部Header压缩，减小了请求和响应头的大小。
   - 二进制传输，取代了文本传输，提高了效率。
   - 服务器推送，允许服务器预测客户端请求的资源并主动推送。
   - 优化了性能和加载速度。

4. **HTTP/3.0**：
   - HTTP/3 是 HTTP/2 的继任者，也称为 HTTP over QUIC（Quick UDP Internet Connections）。
   - 使用 UDP 协议，而不是 TCP，以减少连接建立的延迟。
   - 引入了快速的流控制和差错恢复机制。
   - 更安全，因为使用了 TLS 1.3 加密协议。
   - 目的是进一步提高性能和安全性。

需要注意的是，HTTP/1.1 和 HTTP/2.0 是目前最常用的 HTTP 版本。HTTP/2 和 HTTP/3 带来了显著的性能改进，特别是在加载大量资源的现代网站中，因此它们被广泛采用。不同的版本可能在浏览器和服务器之间有一些配置和兼容性方面的差异，所以了解你的应用所使用的 HTTP 版本是很重要的。


# HTTP1.0和HTTP1.1的一些区别

1. 缓存处理，HTTP1.0中主要使用Last-Modified，Expires 来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略：ETag，Cache-Control
2. 长连接，HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点
3. 带宽优化及网络连接的使用，HTTP1.1支持断点续传，即返回码是206（Partial Content）
4. Header新增Host字段，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没 有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）
5. 错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…
 
# HTTP2.0和HTTP1.X相比的新特性

1. 新的二进制格式（Binary Format），HTTP1.x的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合，基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮
2. header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
3. 服务端推送（server push），例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了
4. 多路复用。代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。 在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。

# http的一些特性
## Keep-Alive
HTTP/1.1 的 "Keep-Alive" 是一项特性，它允许在单个 TCP 连接上进行多次 HTTP 请求和响应，而不必为每个请求都建立和关闭一个新的连接。这有助于减少延迟和提高性能，因为连接的建立和关闭涉及额外的开销。

以下是有关 HTTP/1.1 Keep-Alive 的一些关键信息：

1. **持久连接**：HTTP/1.1 默认启用了持久连接，也称为 Keep-Alive 连接。这意味着在单个 TCP 连接上可以执行多个 HTTP 请求和响应。

2. **Connection 头字段**：为了启用 Keep-Alive 连接，请求和响应中通常包含 "Connection: keep-alive" 头字段。这告诉服务器和客户端保持连接开启。

3. **超时时间**：Keep-Alive 连接不会永远保持打开状态，通常会在一段时间后自动关闭，以释放资源。服务器和客户端可以通过 "Keep-Alive" 头字段指定连接的超时时间。一旦连接被保持了一段时间而没有新的请求，它将被关闭。

4. **多请求响应**：使用 Keep-Alive 连接，客户端可以发送多个 HTTP 请求并在同一连接上接收多个响应，而无需重新建立连接。

5. **性能优势**：Keep-Alive 连接有助于减少延迟，因为避免了频繁建立和关闭连接的开销。这对于在单个页面加载过程中获取多个资源非常有用，如图像、样式表和脚本。

HTTP/1.1 Keep-Alive 对于提高性能和减少资源浪费非常有帮助。然而，它并非永远适用，因为持久连接的数量受到服务器和客户端的配置限制。过多的持久连接可能会消耗服务器资源。因此，配置 Keep-Alive 的超时时间和连接数量是很重要的，以确保最佳性能。

### 和多路复用的区别
HTTP/1.1 的 "Keep-Alive" 和 HTTP/1.1 的 "多路复用"（HTTP/2）都涉及到在单个连接上执行多个 HTTP 请求和响应，但它们之间有一些关键区别：

1. **HTTP 版本**:
   - "Keep-Alive" 是指 HTTP/1.1 中的持久连接特性。
   - "多路复用" 是指 HTTP/2 中的一种特性。

2. **连接数量**:
   - "Keep-Alive" 允许在一个持久连接上执行多个 HTTP 请求和响应，但每个请求和响应仍按顺序发送和接收。一次只能处理一个请求。
   - "多路复用" 允许在一个连接上并行发送多个请求和接收多个响应。这意味着多个请求和响应可以同时传输，而不必等待之前的请求和响应完成。

3. **性能优势**:
   - "Keep-Alive" 提供了减少连接建立和关闭开销的好处，但仍受到请求和响应的串行性能限制。在高延迟的网络环境下，仍可能存在性能瓶颈。
   - "多路复用"通过同时处理多个请求和响应，显著提高了性能，特别是在高延迟网络中。它减少了因等待请求和响应而浪费的时间。

4. **协议复杂性**:
   - "Keep-Alive" 是 HTTP/1.1 中的一项相对简单的特性，只涉及持久连接的创建和超时管理。
   - "多路复用" 是 HTTP/2 中的一项更复杂的特性，它涉及到分帧、流优先级、头部压缩等多个概念，以支持同时传输多个请求和响应。

总之，"Keep-Alive" 和 "多路复用" 都涉及在单个连接上执行多个 HTTP 请求和响应，以提高性能和降低延迟。但 "多路复用" 在 HTTP/2 中引入了更多的高级特性，使得它在处理多个请求时更加高效。 "多路复用" 是 HTTP/2 的一项关键特性，有助于改进现代 Web 应用程序的性能。