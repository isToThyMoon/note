---
title: 19.http缓存
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 00.浏览器相关
---

http缓存
算web性能优化的一部分。但所谓的web性能优化，其实是常识。 

HTTP1.0中主要使用Last-Modified（对比缓存），Expires（强缓存） 来做为缓存判断的标准，
HTTP1.1则引入了更多的缓存控制策略：ETag（对比缓存），Cache-Control（强缓存）

# 如何更新缓存
如果我们的代码更新了，如react.js版本迭代，如何更新浏览器的缓存呢？
注意，缓存只对相同的url生效，稍微改动下url即可。
如：`<link rel="stylesheet" href="./css/default.css?v=2">`加一个查询参数。
这一点可以配合前端的自动化来实现自动更新js css版本

# 对比缓存last-modified和Etag

## Last-Modified If-Modified-Since
响应头：Last-Modified：日期及时间
下次请求头：If-Modified-Since:日期及时间

Last-Modified  是一个响应首部，其中包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  ETag 要低，所以这是一个备用机制。

对应的请求头字段为If-Modified-Since

当浏览器第一次请求一个资源时,服务端返回状态码200,返回请求的资源的同时HTTP响应头会有一个Last-Modified标记着文件在服务端最后被修改的时间.

浏览器第二次请求上次请求过的资源时,浏览器会在HTTP请求头中添加一个If-Modified-Since的标记,用来询问服务器该时间之后文件是否被修改过

如果服务器端的资源没有变化,则自动返回304状态,使用浏览器缓存,从而保证了浏览器不会重复从服务器端获取资源,也保证了服务器有变化时,客户端能够及时得到最新的资源.

也是服务器端做控制，代码就不展示了。

## Etag 和 If-None-Match
响应头：Etag：md5
下次请求头：If-None-Match:md5
```
let string = fs.readFileSync('./js/main.js', 'utf8')
response.setHeader('Content-type', "aaplication/javascript;charset=utf8")
let fileMd5 = md5(string)
if(request.headers['if-None-Match'] === fileMd5){
    response.statusCode = 304
}
response.setHeader('Etag', fileMd5)
response.write(string)
response.end() 
```

Etag也是http返回头 value是一串此请求返回内容的md5
下次请求此url时浏览器请求的请求头If-None-Match值是上次返回的Etag值md5
服务器收到If-None-Match的值，与这次要返回文件的md5比较，如果一致，说明服务器端的资源文件未发生更新，是同样的内容，不需要二次发送，那么在响应里设置响应状态码为304 不返回响应体。

对比缓存Etag和Last-Modified同时存在时，则Etag会覆盖Last-Modified，Last-Modified不会生效。即：ETag优先级 > Last-Modified优先级

# 强缓存 expires和cache-control
expires是旧的http1.0头 cache-control是新的http1.1头
nginx设置了expires 1d
浏览器得到的是
expires: Wed, 21 Oct 2020 07:20:00 GMT
这里的日期是本地时间，如果浏览器的时间错乱了，那么所有缓存就难以控制了。
很不靠谱，所以优先使用新的http头：cache-control

如果expires和cache-control同时存在，cache-control会覆盖expires

## cache-control 
cache-control也是http响应头的一部分
设置了cache-control: max-age = 30 表示当前返回文件如`react.js`30秒内取用缓存好的文件，不需要再次请求。

nginx配置： 
add_header    Cache-Control  max-age=3600;

注意：chrome不允许给首页 html 设置缓存。


cache-control还有下面 几个比较常用的设置值：
no-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之 前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下 载。

no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都 会下载完整的资源。

public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。

private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高。
