## 泛型

对类型编程：
对函数入参和返回值的类型 
或者 
类的方法和属性
进行更灵活的约束

创建可重用的组件支持多种类型的数据


```
// 例子:构造一个函数 功能是填充一个数组并返回 利用泛型同时约束传入参数类型和返回的数组类型
// 函数泛型：
// function关键字写法：
function createArray<T>(length: number, value: T): Array<T> {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}

createArray<string>(3, 'x'); // ['x', 'x', 'x']
// createArray(3, 'x'); // ['x', 'x', 'x'] //或者不手动指定，而让类型推论自动推算出来

// 箭头函数写法：
const createArray = <T>(length: number, value: T): Array<T> => {
    let result: T[] = [];
    for (let i = 0; i < length; i++) {
        result[i] = value;
    }
    return result;
}
```

### 函数中的泛型约束
```
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);
    return arg;
}
```
上例中，我们使用了 extends 约束了泛型 T 必须符合接口 Lengthwise 的形状，也就是必须包含 length 属性。

此时如果调用 loggingIdentity 的时候，传入的 arg 不包含 length，那么在编译阶段就会报错了。

### 类中的泛型约束

```ts
class Queue<T> {
  private data = [];
  push(item: T) {
    return this.data.push(item)
  }
  pop(): T {
    return this.data.shift()
  }
}

// 约束为number
const queue = new Queue<number>()
queue.push(1)
console.log(queue.pop().toFixed())

// 约束为string
const queue2 = new Queue<string>()
queue2.push('str')
console.log(queue2.pop().length)
```

### interface中的泛型约束

```
interface KeyPair<T, U> {
  key: T;
  value: U;
}

let kp1: KeyPair<number, string> = { key: 123, value: "str" }
let kp2: KeyPair<string, number> = { key: 'test', value: 123 }

let arr: number[] = [1, 2, 3]
let arrTwo: Array<number> = [1, 2, 3]
```

```
interface IPlus<T> {
  (a: T, b: T) : T
}
function plus(a: number, b: number): number {
  return a + b;
}
function connect(a: string, b: string): string {
  return a + b
}
const a: IPlus<number> = plus
const b: IPlus<string> = connect
```




