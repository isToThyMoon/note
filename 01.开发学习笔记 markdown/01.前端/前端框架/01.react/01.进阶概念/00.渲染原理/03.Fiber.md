
# Fiber架构
在React Conf 2017上，React Fiber在React16版本发布。

React Fiber可以理解为：React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。
其中每个任务更新单元为React Element对应的Fiber节点。

就是为了实现concurrent模式，可见上一节。

## 改造思路
异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。

其实，浏览器原生就支持类似的实现，这就是Generator。但是Generator的一些缺陷使React团队放弃了他：
类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。
Generator执行的中间状态是上下文关联的。

代数效应与Fiber：
Fiber并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。
在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。
所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。


Fiber要解决的问题： 
（1）能够将可中断的任务拆分成块。 
（2）能够对进程中的工作划分优先级、重新设定基址（Rebase）、恢复。
（3）能够在父子之间来回反复，借此为 React 的 Layout 提供支持。
（4）能够通过 render() 返回多个元素。 
（5）为错误边界提供了更好的支持。

新的数据结构是由fiberNode节点构成的链式结构。
每个fiberNode有：
child:⽗节点指向第⼀个⼦元素的指针；
sibling：从第⼀个⼦元素往后，指向下⼀个兄弟元素；
return：所有⼦元素都有的指向⽗元素的指针；
等等。

有了这⼏个指针后，我们可以在任意⼀个元素中断遍历并恢复，
Fiber这个结构外形看着还是棵树，但是没有了指向所有⼦元素的指针，⽗节点只指向第⼀个⼦节点，然后⼦节点有指向其他⼦节点的指针，这其实是个链表。

遍历的时候从根节点出发，先找⼦元素，如果⼦元素存在，直接返回，如果没有⼦元素了就找兄弟
 元素，找完所有的兄弟元素后再返回⽗元素，然后再找这个⽗元素的兄弟元素。整个遍历过程其实
 是个深度优先遍历（DFS），从上到下，然后最后⼀⾏开始从左到右遍历；
 
 
# Fiber的含义
Fiber包含三层含义：

1. 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。

2. 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。

3. 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

 
## fiber的数据结构
一个fiber就是一个js对象，包含了元素的信息、该元素的更新操作队列、类型等，数据结构如下：

```js
// ReactElement作为jsx返回的数据结构，描述了jsx的结构，核心是type key props。
// 可见它无法表达节点之间的关系，也没有保存状态。
// 为了实现fiber功能，我们需要定义一个新的数据结构，FiberNode
// 它介于ReactElement与真实UI节点之间
// 能够表达节点之间的关系
// 方便拓展（不仅作为数据存储单元，也能作为工作单元）
// 这就是FiberNode（虚拟DOM在React 新架构中的实现）

export class FiberNode {
	// 作为静态数据结构的属性
	// tag, 哪种类型的节点
	// Fiber对应组件的类型 FunctionComponent/ClassComponent/Host...
	tag: WorkTag;
	// ReactElement里的key
	key: Key;
	// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
	// 是ReactElement.type，调用createElement的第一个参数
	elementType: null;
	// FiberNode的类型
	// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
	type: any;
	// Fiber对应的真实DOM节点
	// 对于HostComponent这种tag。例如是div,stateNode就保存了这个div的dom
	stateNode: any;

	// 用于连接其他Fiber节点形成Fiber树
	// 每个Fiber节点有个对应的ReactElement，多个Fiber节点靠以下属性连接形成树
	// return指向父FiberNode
	// 为什么用return这种关键字名，因为我们是把FiberNode作为一个工作单元，当它工作完毕就轮到处理父工作单元了。
	// return指节点执行完completeWork后会返回的下一个节点，子Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用return指代父级节点。
	return: FiberNode | null;
	// 右边的兄弟FiberNode
	sibling: FiberNode | null;
	// 第一个子FiberNode
	child: FiberNode | null;
	// 在父级中的顺序
	index: number;

	ref: Ref; // null | (((handle: mixed) => void) & { _stringRef: ?string }) | RefObject,

	// 作为动态的工作单元的属性
	// 保存本次更新造成的状态改变相关信息 刚开始工作时的props是什么
	// 是当前处理过程中的组件props对象
	pendingProps: Props | null;
	// 工作完成时，稳定下来的props是什么
	// 上一次渲染完成之后的props
	memoizedProps: Props | null;
	// 在每次状态更新，都会创建保存一个更新状态的相关的对象，称为Update对象，在render的beginwork中会根据Update得到新的state。
	// 多个setState调用 就会产生多个Update 放到这个queue中
	// 该Fiber对应的组件产生的Update会存放在这个队列里
	// 它其实是一个对象，只是有指针可以形成一个链表 具体见《render commit流程》这个md中状态更新流程里的介绍
	updateQueue: null;
	// 上一次渲染时的state
	memoizedState: null;
	dependencies: null;
   
   // 一个列表 存放这个Fiber依赖的context
   firstContextDependency: ContextDependency<mixed> | null
	mode: null;
	
	// 保存本次更新会造成的DOM操作，用来记录side Effect
	// 当render的工作结束后会commit，通知Renderer需要执行的DOM操作。要执行DOM操作的具体类型（插入 更新 删除节点）就保存在fiber.effectTag中。
   // 除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。
	effectTag: null;
	// 单链表 用来快速查看下一个side Effect
	nextEffect: null;
   
   // 子树中第一个side Effect
	firstEffect: null;
	// 子树中最后一个side Effect
	lastEffect: null;
   
	// 调度优先级相关
	lanes: null;
	// 快速确定子树中是否有不在等待的变化
	childLanes: null;

	// 所谓的双缓冲技术，所有ReactElement比较完成后，生成一棵fiberNode树，存在current tree和workInProgress Tree两棵fiberNode树
	// alternate 控制这两种状态的切换
	// 如果目前的的FiberNode是current，那么它的alternate就指向它的workInprogress，反之亦然。
	alternate: FiberNode | null;

	// 副作用
	// 保存状态更新时 比较ReactElement后在FiberNode打上的增删改dom的标记
	flags: Flags;

	constructor(tag: WorkTag, pendingProps: Props, key: Key) {
		// 作为静态数据结构的属性
		this.tag = tag;
		this.key = key;
		this.elementType = null;
		this.type = null;
		this.stateNode = null;

		// 用于连接其他Fiber节点形成Fiber树
		this.return = null;
		this.child = null;
		this.sibling = null;
		this.index = 0;

		this.ref = null;

		// 作为动态的工作单元的属性
		this.pendingProps = pendingProps;
		this.memoizedProps = null;
		this.updateQueue = null;
		this.memoizedState = null;
		this.dependencies = null;

		// this.mode = mode;

		// this.effectTag = NoEffect;
		this.nextEffect = null;

		this.firstEffect = null;
		this.lastEffect = null;

		// 调度优先级相关 和Scheduler相关
		// this.lanes = NoLanes;
		// this.childLanes = NoLanes;

		// 指向该fiber在另一次更新时对应的fiber
		this.alternate = null;
		this.flags = NoFlags;
	}
}
```

## 为什么hooks不能在if分支中
hooks 产生的 hook 对象依次排列,形成hooks链表到函数组件 fiber.memoizedState 上
每次调用 hooks 都会生成 hook 对象，其结构如下
```js
export type Hook = {|
  memoizedState: any,
  baseState: any,
  baseQueue: Update<any, any> | null,
  queue: UpdateQueue<any, any> | null,
  next: Hook | null,
|};
```

着重关注memoizedState和next属性，不同 hooks 的 hook 对象的memoizedState保存着不同对象

```js
useState：hook.memoizedState =  state;
useEffect ：hook.memoizedState = effect
useMemo：hook.memoizedState = [nextValue, nextDeps];
useCallback：hook.memoizedState = [callback, nextDeps];
useRef：hook.memoizedState = ref;
```

一般我们会在函数组件中多次使用hooks，这会产生多个 hook 对象，这些对象通过next属性连接形成链表，连接是在挂载时进行的，主要函数是 mountWorkInProgressHook

```js
function mountWorkInProgressHook() {
  const hook = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  if (workInProgressHook === null) {
    // This is the first hook in the list
    currentlyRenderingFiber.memoizedState = workInProgressHook = hook;
  } else {
    // Append to the end of the list
    workInProgressHook = workInProgressHook.next = hook;
  }
  return workInProgressHook;
}
```

挂载时，hooks 都会调用该函数生成 hook 对象并连接。
如果 workInProgressHook === null，说明是hook链中的第一个，
将其赋值给currentlyRenderingFiber.memoizedState并更新workInProgressHook，
这说明函数组件的Fiber的memoizedState保存着第一个hook的引用。
当workInProgressHook !== null，
则将新生成的 hook 赋值给上个hook的next属性并更新workInProgressHook。

更新时，hooks 都会调用 updateWorkInProgressHook 函数生成新的hook对象并连接形成hook链以供下次更新时使用。

```js
function updateWorkInProgressHook(): Hook {
  let nextCurrentHook: null | Hook;
 
  if (currentHook === null) { // currentHook === null 说明当前是hook链的第一个
    // current 为上次更新的组件对应的Fiber
    const current = currentlyRenderingFiber.alternate;
    if (current !== null) {
      // current.memoizedState保存着hook链的第一个hook
      nextCurrentHook = current.memoizedState;
    } else {
      nextCurrentHook = null;
    }
  } else {
    // 取出 currentHook.next，即上次更新中hook链的下一个hook
    nextCurrentHook = currentHook.next;
  }
  // 此时nextCurrentHook代表着本hooks在上次更新中的hook对象
  
  let nextWorkInProgressHook: null | Hook;
  if (workInProgressHook === null) { //workInProgressHook === null 说明当前是hook链的第一个
    nextWorkInProgressHook = currentlyRenderingFiber.memoizedState;
  } else {
    nextWorkInProgressHook = workInProgressHook.next;
  }
  // 此时nextWorkInProgressHook绝大多数时候为null，因为 renderWithHooks 函数在执行函数组件前会将
  // currentlyRenderingFiber.memoizedState置为null，workInProgressHook.next也为null
  
  if (nextWorkInProgressHook !== null) { // 忽略这条分支
    // There's already a work-in-progress. Reuse it.
    workInProgressHook = nextWorkInProgressHook;
    nextWorkInProgressHook = workInProgressHook.next;
    currentHook = nextCurrentHook;
  } else {
    // 绝大多数时候会进入此分支
    
    // currentHook即上次更新中相应顺序的hook对象
    currentHook = nextCurrentHook;
    
    // 复用上次更新的hook对象的属性，生成新的hook对象
    const newHook: Hook = {
      memoizedState: currentHook.memoizedState,
      baseState: currentHook.baseState,
      baseQueue: currentHook.baseQueue,
      queue: currentHook.queue,
      next: null,
    };
    
    //形成新的hook链，和挂载时一样
    if (workInProgressHook === null) {
      // This is the first hook in the list.
      currentlyRenderingFiber.memoizedState = workInProgressHook = newHook;
    } else {
      // Append to the end of the list.
      workInProgressHook = workInProgressHook.next = newHook;
    }
  }
  return workInProgressHook;
}
```
一切都是按照链表的顺序。如果出现if分支，可能就对不上了。

## Fiber工作原理


### 什么是“双缓存”
当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。

如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。

为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。

这种在内存中构建并直接替换的技术叫做双缓存 。

### 双缓存Fiber树
React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。

在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树存在于**render阶段**，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。

已构建完的workInProgress Fiber树在**commit阶段**渲染到页面。workInProgress Fiber树被切换成current Fiber树。

current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。

React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。

即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。

每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。

在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，决定是否复用的算法就是diff。


## Fiber的diff过程
使用fiber架构进行diff工作和之前有所不同。

在render函数中创建的React Element树在第一次渲染的时候会创建一颗结构一模一样的Fiber节点树。
不同的React Element类型对应不同的Fiber节点类型。一个React Element的工作就由它对应的Fiber节点来负责。

一个React Element可以对应不止一个Fiber，因为Fiber在update的时候，会从原来的Fiber（我们称为current）clone出一个新的Fiber（我们称为alternate）。
两个Fiber diff出的变化（**side effect**）记录在wip 的fiber上。
所以一个组件在更新时最多会有两个Fiber与其对应，在更新结束后通过切换current指针切换wip和current两颗树。

上面提到时间分片的计算方法，React会记录diff操作时间，如果大于一帧的渲染时间则暂停，然后等待下个渲染间隙再继续执行diff操作，直到diff完成。这个机制由调度器来完成。

基于requestIdleCallback实现的。关于该API可以参考另一篇文章。（实际上React为了照顾绝大多数的浏览器，自己实现了requestIdleCallback。）
Fiber的基本规则：更新任务分成两个阶段，Reconciliation Phase和Commit Phase。

Reconciliation Phase的任务干的事情是，找出要做的更新工作（Diff Fiber Tree），就是一个计算阶段，计算结果可以被缓存，也就可以被打断；

Commmit Phase 需要提交所有更新并渲染，为了防止页面抖动，被设置为不能被打断。

注意，这种改动带来的问题是，有些生命周期钩子可能被执行多次，因此使用时候需要保证这些生命周期钩子中执行的方法多次调用不会影响逻辑。
React团队提供了替换的生命周期方法。建议如果使用以上方法，尽量用纯函数。

简单地说，diff过程是

1 首次渲染时候构建一个和虚拟dom树一样结构的fiber树
2 组件更新时候，遍历新旧fiber树，diff区别，diff操作是分片进行，16ms内如果没完成，就先暂停等待下个渲染空闲时间再继续。
3 diff完成之后进行commit，将变化提交，进行对应的dom操作，为防止界面抖动，commit是一次性完成的。

## diff如何循环遍历Fiber结构的链表
diff的工作就是遍历虚拟dom树，因此让diff工作能够支持断点重启，就是让遍历操作能够支持断点重启。
为此，React设计了fiber tree数据结构，每个fiber tree的node都有3个属性：return（指向父节点）、sibling（指向右兄弟节点）、child（指向第一个子节点）。

如何通过这几个属性遍历呢？

首先我们看之前的递归遍历方式。

```js
walk(a1);

function walk(instance) {
    doWork(instance);
    const children = instance.render();
    children.forEach(walk);
}

function doWork(o) {
    console.log(o.name);
}
```

使用fiber之后如何遍历？先看下fiber数据结构
```
class Node {
    constructor(instance) {
        this.instance = instance;
        this.child = null;
        this.sibling = null;
        this.return = null;
    }
}
```

访问虚拟dom节点，并遍历生成fiber树

```js
// 访问虚拟dom节点，并遍历、构造fiber树
function walk(o) {
    let root = o;
    let current = o;

    while (true) {
        // perform work for a node, retrieve & link the children
        let child = doWork(current);

        // if there's a child, set it as the current active node
        if (child) {
            current = child;
            continue;
        }

        // if we've returned to the top, exit the function
        if (current === root) {
            return;
        }

        // keep going up until we find the sibling
        while (!current.sibling) {

            // if we've returned to the top, exit the function
            if (!current.return || current.return === root) {
                return;
            }

            // set the parent as the current active node
            current = current.return;
        }

        // if found, set the sibling as the current active node
        current = current.sibling;
    }
}

// 访问节点，并生成child node
function doWork(node) {
    console.log(node.instance.name);
    const children = node.instance.render();
    return link(node, children);
}

// 创建fiber节点、并初始化return、child、sibling属性，并返回子节点
function link(parent, elements) {
    if (elements === null) elements = [];

    parent.child = elements.reduceRight((previous, current) => {
        const node = new Node(current);
        node.return = parent;
        node.sibling = previous;
        return node;
    }, null);

    return parent.child;
}
```

通过上面的分析可以看出，fiber tree并非通过严格的链表来进行遍历，它也是一个树的结构，它的遍历过程和深度优先遍历一个树没有区别，区别在于加了几个属性指向相关节点，让遍历可以暂停和重启，很方便地找到一个节点的DFS下一个节点。
fiber可以理解是一种数据结构，是一个树的结构，fiber节点记录的是操作，包括将要进行的操作和已经完成的操作。而fiber架构是包含数据结构和调度机制的一个整体。
A Fiber is work on a Component that needs to be done or was done. There can be more than one per component.







