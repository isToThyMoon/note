# 为什么采用并发更新

js引擎和⻚⾯渲染引擎两个线程是互斥的，当其中⼀个线程执⾏时，另⼀个线程只能挂起。如果js长期占据，渲染引擎长期等待就会让页面响应变差。如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化，一些DOM操作，内部也会对reflow进行修正。而过长时间占用主进程，会导致性能下降。

这就是React15的stack reconciler面对的问题，React16 以前（可以认为采用Fiber架构前）的React只支持一种优先级：同步优先级，即所有更新是“同步、不可中断”的形式。

当一次更新或者一次加载开始以后，diff virtual dom并且渲染的过程（render ➕ commit）是一口气完成的。如果组件层级比较深，相应的栈也会很深，长时间占用浏览器主线程，一些类似用户输入、鼠标滚动等操作得不到响应。

解决方案是时间分片，即利用浏览器的渲染空余时间来执行diff工作，当执行时间过长时候（浏览器无空闲时间），停止diff工作，把执行机会让给渲染，然后等渲染间隙再继续执行diff工作，直到diff完成，再执行commit。这样不仅避免了渲染工作被js执行阻塞导致的卡顿，还让浏览器有时间对代码优化从而提升执行性能。

这就是**并发更新模式**。

接收到多个更新任务按任务优先级进入update更新队列，高优先级可以打断低优先级任务。每个任务在规定时间内（timeslice 时间分片 5ms）运行， 到时间会探出头去看是否有高优先级任务或者浏览器是否没有了空闲时间（一帧渲染时机到了）（shouldYield为true），如果是的话，不再执行当前任务的 render 流程，进入下一个高优先级任务或者响应浏览器事件。高优先级任务执行完毕，再去任务队列中取更新任务执行render commit。

# 并发更新的核心
并发更新的核心就是时间分片和任务可中断重启。

以是否开启时间切片来区分是否是并发更新。


# react18的createRoot修改
https://juejin.cn/post/7031375070882693150?from=search-suggest

曾经在react17版本是可以手动开启concurrent模式的，react18开始全部采用createRoot api来开启渲染，不再有手动开启concurrent Mode的选项，其实它是**渐进升级**策略的产物。

由于策略调整，根据[What happened to concurrent mode?](https://github.com/reactwg/react-18/discussions/64)，在v18中将不会有Concurrent Mode手动开启了。

没有Concurrent Mode，那该如何使用**并发更新**呢？

一句话总结：在v18中，不再有三种模式，而是以**是否使用并发特性**作为**是否开启并发更新**的依据。

# React有多少种架构？
从最老的版本到当前的v18，市面上有多少个版本的React？
可以从架构角度来概括下，当前一共有两种架构：

采用不可中断的**递归**方式更新的Stack Reconciler（老架构）
采用可中断的**遍历**方式更新的Fiber Reconciler（新架构）

新架构可以选择是否开启**并发更新**，所以当前市面上所有React版本一定属于如下一种情况：

1. 老架构（v15及之前版本）
2. 新架构，未开启并发更新，与情况1行为一致（v16、v17默认属于这种情况）
3. 新架构，未开启并发更新，但是启用了一些新功能（比如Automatic Batching）
4. 新架构，开启并发更新

# 渐进升级
## 理想与现实的差距
React团队的愿景是：
> 使用老版本的开发者可以逐步升级到新版，即从情况1、2、3向情况4升级。

但是这中间存在极大的阻力，因为情况4的React一些行为异于情况1、2、3。

比如如下三个生命周期函数在情况4的React下是“不安全的”（render阶段可中断重启导致重复执行）：
componentWillMount
componentWillReceiveProps
componentWillUpdate

贸然升级可能造成老代码不兼容。
为了让广大开发者能够平滑过渡，React团队采用了**渐进升级**方案。

## 渐进升级第一步
渐进升级方案的第一步是规范代码。

v16.3新增了StrictMode，对开发者编写的不符合并发更新规范的代码作出提示，逐步引导开发者写出规范代码。

比如，使用上述不安全的生命周期函数时会产生如下报错信息：
```
Warning: unsafe lifecycle methods were found within a strict-mode tree:
....
componentWillMount: ...
```

## 渐进升级第二步
下一步，React团队让不同情况的React可以在同一个页面共存，借此可以让情况4的React逐步渗入原有的项目。
具体做法是提供三种开发模式：

1. **Legacy**模式，通过`ReactDOM.render(<App />, rootNode)`创建的应用遵循该模式。默认关闭**StrictMode**，表现同情况2 

2. **Blocking**模式，通过`ReactDOM.createBlockingRoot(rootNode).render(<App />)`创建的应用遵循该模式，作为从**Legacy**向**Concurrent**过渡的中间模式，默认开启**StrictMode**，表现同情况3

3. **Concurrent**模式，通过`ReactDOM.createRoot(rootNode).render(<App />)`创建的应用遵循该模式，默认开启**StrictMode**，表现同情况4

![三种mode](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1a3bcdc20f54b18ae4ebcbe6fd05655~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

为了让不同模式的应用可以在同一个页面内工作，需要调整一些底层实现。

比如：调整之前，大多数事件会统一冒泡到HTML元素，调整后事件会冒泡到应用所在根元素。(为什么修改事件机制的原因)

![事件机制调整](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/86d734f2982c4529955bdad0ca920b09~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp)

这些调整工作发生在v17，所以v17也被称作为开启并发更新做铺垫的垫脚石版本。

## 最新的渐进升级策略
时间前进到2021年6月8日，v18工作组成立。

在与社区进行大量沟通后，React团队意识到当前的渐进升级策略存在两方面问题。

## 原因一
首先，由于模式影响的是整个应用，所以无法在同一个应用中完成渐进升级。
举个例子，开发者将应用中`ReactDOM.render`改为`ReactDOM.createBlockingRoot`，从Legacy模式切换到Blocking模式，这会自动开启StrictMode。
此时，整个应用的并发不兼容警告都会上报，开发者还是需要修改整个应用。
从这个角度看，并没有起到渐进升级的目的。


## 原因二
其次，React团队发现：开发者从新架构中获益，更多是由于使用了并发特性（Concurrent Feature）。
并发特性指开启并发更新后才能使用的特性，比如：

* useDeferredValue
* useTransition

所以，可以默认情况下仍使用同步更新，在使用了并发特性后再开启并发更新。


在v18中运行如下代码：
```js
const App = () => {
  const [count, updateCount] = useState(0);
  const [isPending, startTransition] = useTransition();

  const onClick = () => {
    // 使用了并发特性useTransition
    startTransition(() => {
      // 本次更新是并发更新
      updateCount((count) => count + 1);
    });
  };
  return <h3 onClick={onClick}>{count}</h3>;
};
```

由于updateCount在startTransition的回调函数中执行（使用了并发特性），所以updateCount会触发并发更新。


如果updateCount没有作为startTransition的回调函数执行，那么updateCount将触发默认的同步更新。

你可以观察这两种情况是否开启时间切片来区分是否是并发更新。

```js
import React, { useState, useTransition } from "react";
import ReactDOM from "react-dom";

const App = () => {
  const [count, updateCount] = useState(0);
  const [isPending, startTransition] = useTransition();

  const onClick = () => {
    // 试试不作为startTransition回调执行
    startTransition(() => {
      updateCount((count) => count + 1);
    });
  };

  return <h3 onClick={onClick}>{count}</h3>;
};

const rootElement = document.getElementById("root");

ReactDOM.createRoot(rootElement).render(<App />);**
```

# 结论
在v18中，不再有三种模式，而是以是否使用并发特性作为是否开启并发更新的依据。

具体来说，在v18中统一使用ReactDOM.createRoot创建应用。

当不使用并发特性时，表现如情况3。使用并发特性后，表现如情况4。