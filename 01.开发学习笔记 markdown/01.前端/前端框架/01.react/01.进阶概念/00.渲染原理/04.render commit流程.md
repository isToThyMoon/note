
```js
创建fiberRootNode、rootFiber、updateQueue（`legacyCreateRootFromDOMContainer`）

    |
    |
    v

创建Update对象（`updateContainer`）

    |
    |
    v

从fiber到root（`markUpdateLaneFromFiberToRoot`）从触发状态更新的fiber一直向上遍历到rootFiber

    |
    |
    v

调度更新（`ensureRootIsScheduled`）

    |
    |
    v

render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）

    |
    |
    v

commit阶段（`commitRoot`）
```
![](https://static001.geekbang.org/infoq/21/21b64a96bf72a141cb53c80773e0fd2c.webp?x-oss-process=image%252Fresize%252Cp_80%252Fformat%252Cpng)



# render阶段和commit阶段（结合生命周期的流程图来看本节）

有了之前大段的架构铺垫终于到了render和commit阶段的解释。在render阶段，在内存中构建workInProgress Fiber树。在commit阶段将已完成构建的workInProgress Fiber树从reconciler提交到renderer，并由renderer映射到真实dom，执行dom操作，由渲染引擎渲染到页面。同时将workInProgress Fiber树通过current指针切换成current Fiber树。

react组件渲染分2个阶段 render和commit。

render阶段：Scheduler和reconciler工作，调和对比构建fiber树。

commit阶段：renderer工作（浏览器环境时reactDOM），根据fiber树的tag执行DOM操作，映射真实DOM。更新DOM（如果需要得话）细分三个阶段：**before mutation**；**mutation**；**layout**。

render阶段的开始，开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新，render结束完后会进入commit
commit阶段的开始，开始于commitRoot方法的调用。其中rootFiber会作为传参。

## render阶段
render阶段的工作是在内存中进行，当工作结束后会commit，通知Renderer需要执行的DOM操作。我们知道，render阶段的工作是在内存中进行，具体就是为fiber树打tag，
插入DOM节点（Placement）
更新DOM节点（Update）
删除DOM节点（Deletion）
当工作结束后会通知Renderer需要执行的DOM操作。要执行DOM操作的具体类型就保存在**fiber.effectTag**中。
**除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。**

render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。

我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：
```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

可以看到，他们唯一的区别是是否调用**shouldYield**。如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历。这就是concurrent模式的异步的可中断更新。

`workInProgress`代表当前已创建的`workInProgress fiber`树。
`performUnitOfWork`方法会创建下一个Fiber节点并赋值给`workInProgress`，并将`workInProgress`与已创建的Fiber节点连接起来构成Fiber树。
我们知道Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。

### “递”阶段
首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用[beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法。

该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。

当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。

组件执行beginWork后会创建子Fiber节点，节点上可能存在effectTag。

### “归”阶段
在“归”阶段会调用[completeWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理Fiber节点。

和beginWork一样，completeWork根据current === null ?判断是mount还是update。当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：onClick、onChange等回调函数的注册，处理style prop，处理children prop。

当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。

如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。

“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。在performSyncWorkOnRoot函数中rootFiber被传递给commitRoot方法，开启commit阶段工作流程。

在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为**effectList**的单向链表中。effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。
除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。

注意这里的effect和react提供的effect hook并不是一个概念 有点复杂。

## commit阶段（重点 此处涉及到页面何时出现用户可感知的变更，并且执行一些生命周期和effect）
commitRoot方法是commit阶段工作的起点。fiberRootNode会作为传参。 `commitRoot(root);`

在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props。这些effect（不习惯这个词 或许叫修改好理解点）对应的DOM操作在commit阶段执行。

除此之外，在commit阶段会触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）

commit阶段的主要工作（即Renderer的工作流程）分为三部分：before mutation；mutation；layout。

**在before mutation阶段之前和layout阶段之后**
有一些额外工作，涉及到比如useEffect的触发、优先级相关的重置、ref的绑定/解绑。这些对我们当前属于超纲内容，为了内容完整性，先简单介绍。
before mutation之前主要做一些变量赋值，状态重置的工作。们只需要关注最后赋值的**firstEffect**，在commit的三个子阶段都会用到他。

layout之后主要包括三点内容：
useEffect相关的处理。
性能追踪相关。
触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）


**before mutation(操作dom前)**
before mutation阶段的代码很短，整个过程就是遍历effectList并调用commitBeforeMutationEffects函数处理。
```js
function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      // ...focus blur相关
    }

    const effectTag = nextEffect.effectTag;

    // 调用getSnapshotBeforeUpdate
    if ((effectTag & Snapshot) !== NoEffect) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }

    // 调度useEffect
    if ((effectTag & Passive) !== NoEffect) {
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
         // 触发useEffect
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```
这个函数主要做的事情：
1. 处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。
2. 调用**getSnapshotBeforeUpdate**生命周期钩子。
3. **调度useEffect**。

（严格来说这是precommit阶段 可以读取dom）: 调用类组件生命周期函数getSnapshotBeforeUpdate(prevProps, prevState),并且把旧的props和旧的states传递进去。getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题。

调度useEffect：scheduleCallback方法由Scheduler模块提供，用于以某个优先级异步调度一个回调函数。
在此处，被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects。（这里非常重要非常巧妙，之前对react16fiber架构的解释详细介绍了scheduler和reconciler配合工作，这里以scheduleCallback异步调度这个任务就是在本次render commit结束之后插入了一个NormalSchedulePriority的任务，实现在每次渲染到页面后执行useEffect这个功能。）

跟着flushPassiveEffects我们可以找到最终调用 useEffect 的地方是 commitRootImpl ，所以就是在这里面对 useEffect 进行了调度，在完成渲染工作以后去异步执行了 useEffect。

注意这里是调度了useEffect，而useEffect销毁函数和回调函数的调度在下面layout阶段讲解，这两个调度不是一个概念。

我们接下来讨论useEffect如何被异步调度，以及为什么要异步（而不是同步）调度。

如何异步调度？
在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。

在completeWork一节我们讲到，effectList中保存了需要执行副作用的Fiber节点。其中副作用包括
插入DOM节点（Placement）
更新DOM节点（Update）
删除DOM节点（Deletion）

除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。
在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

如果在此时直接执行，rootWithPendingPassiveEffects === null。
那么rootWithPendingPassiveEffects会在何时赋值呢？
在上一节**layout之后**的代码片段中会根据rootDoesHavePassiveEffects是否true决定是否赋值rootWithPendingPassiveEffects。
```js
// layout之后
// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}
```
整个useEffect异步调用分为三步：
before mutation阶段在scheduleCallback中调度flushPassiveEffects
layout阶段之后将effectList赋值给rootWithPendingPassiveEffects
页面渲染完成之后scheduleCallback触发flushPassiveEffects，在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

为什么需要异步调用：
文档介绍：与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。
可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。

**mutation阶段（执行dom操作）**：获取对象的effects 根据不同的effectTag执行不同的操作，插入、更新、删除。将workInProgress fiber树变成current Fiber树。
插入节点： commitPalcement
更新节点：commitWork
删除节点：commitDeletion

类似before mutation阶段，mutation阶段也是遍历effectList，执行函数。这里执行的是commitMutationEffects
commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作：
根据ContentReset effectTag重置文字节点
更新ref
根据effectTag分别处理，其中effectTag包括(Placement | Update | Deletion | Hydrating)。我们关注步骤三中的Placement | Update | Deletion。Hydrating作为服务端渲染相关，我们先不关注。

这里就是一些具体的dom操作了。 先不做详细理解。

Placement effect：意味着该Fiber节点对应的DOM节点需要插入到页面中。调用的方法为commitPlacement。

Update effect：当Fiber节点含有Update effectTag，意味着该Fiber节点需要更新。调用的方法为commitWork，他会根据Fiber.tag分别处理。
主要关注在这个类型度tag下，当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有**useLayoutEffect hook的销毁函数**（这也是hook中每次渲染先执行上一个销毁函数再执行effect的逻辑）。你不需要很了解useLayoutEffect，我们会在下一节详细介绍。你只需要知道在mutation阶段会执行useLayoutEffect的销毁函数。

Deletion effect：当Fiber节点含有Deletion effectTag，意味着该Fiber节点对应的DOM节点需要从页面中删除。调用的方法为commitDeletion。
该方法会执行如下操作：
递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount 生命周期钩子，从页面移除Fiber节点对应DOM节点
解绑ref
**调度useEffect的销毁函数**


**layout阶段（执行dom操作之后）**：
该阶段之所以称为layout，因为该阶段的代码都是在DOM渲染完成（mutation阶段完成）后执行的。
该阶段触发的生命周期钩子和hook可以直接访问到已经改变后的DOM，即该阶段是可以参与DOM layout的阶段。（前两个阶段其实对生命周期和hook已经做了一些准备工作）

与前两个阶段类似，layout阶段也是遍历effectList，执行函数。
具体执行的函数是commitLayoutEffects。主要工作为“根据effectTag调用不同的处理函数处理Fiber并更新ref。
commitLayoutEffects一共做了两件事：
commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）
commitAttachRef（赋值 ref）代码逻辑很简单：获取DOM实例，更新ref。

commitLayoutEffectOnFiber方法会根据fiber.tag对不同类型的节点分别处理。（commitLayoutEffectOnFiber为别名，方法原名为commitLifeCycles）

对于ClassComponent，他会通过current === null?区分是mount还是update，调用**componentDidMount** 或**componentDidUpdate**
**触发状态更新的this.setState如果赋值了第二个参数回调函数**，也会在此时调用。

对于FunctionComponent及相关类型，他会**调用useLayoutEffect hook的回调函数**，**调度useEffect的销毁与回调函数**。

```js
  switch (finishedWork.tag) {
    // 以下都是FunctionComponent及相关类型
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // 执行useLayoutEffect的回调函数
      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      // 调度useEffect的销毁函数与回调函数 注意这里调度的是useEffect的两个函数
      schedulePassiveEffects(finishedWork);
      return;
    }
```
先useLayoutEffect后useEffect，其实这里代码顺序也无所谓先后，before mutation阶段解释过useEffect的前期准备工作，schedulePassiveEffects的调用是一个异步调用。这个函数作用是从函数组件对应的 fiber 上获取上面挂载的 effect，然后将 effect 和 fiber 推到 pendingPassiveHookEffectsUnmount 和 pendingPassiveHookEffectsMount 这个两个队列中。
```js
function schedulePassiveEffects(finishedWork: Fiber) {
  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      const {next, tag} = effect;
      if (
        (tag & HookPassive) !== NoHookEffect &&
        (tag & HookHasEffect) !== NoHookEffect
      ) {
        // 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        // 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }
      effect = next;
    } while (effect !== firstEffect);
  }
}
```

结合之前before mutation提到的scheduleCallback中调度flushPassiveEffects，在layout阶段之后将effectList赋值给rootWithPendingPassiveEffects，渲染完成后执行useEffect的销毁函数和回调函数。
```js
// layout之后
// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}
```

这里dom操作已经完成，可以取到dom信息做一些effect修改。

注意useLayoutEffect的销毁函数是在mutation阶段Update effectTag类型时调用的。
结合这里我们可以发现，useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。

而useEffect则需要先调度，在Layout阶段完成后再异步执行。这就是useLayoutEffect与useEffect的区别。

对于useEffect的销毁函数和回调函数，调用上一次render的销毁函数，调用本次render的回调函数。
在v16中第一版是同步执行的，在官方博客中提到：
副作用清理函数（如果存在）在 React 16 中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。
基于这个原因，在v17.0.0中，useEffect的两个阶段会在页面渲染后（layout阶段后）异步执行。
事实上，从代码中看，v16.13.1中已经是异步执行了。

useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。
这是因为多个组件间可能共用同一个ref。

如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。

在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。

所以useEffect执行分两个阶段，销毁函数的全部执行和回调函数的全部执行。

layout阶段通过schedulePassiveEffects调度useEffect的销毁函数和回调函数，从函数组件对应的 fiber 上获取上面挂载的 effect，然后将 effect 和 fiber 堆到 pendingPassiveHookEffectsUnmount 和 pendingPassiveHookEffectsMount 这个两个队列中。

在阶段一，会遍历并执行所有useEffect的销毁函数。
```js
// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect
const unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];
  for (let i = 0; i < unmountEffects.length; i += 2) {
    const effect = ((unmountEffects[i]: any): HookEffect);
    const fiber = ((unmountEffects[i + 1]: any): Fiber);
    const destroy = effect.destroy;
    effect.destroy = undefined;

    if (typeof destroy === 'function') {
      // 销毁函数存在则执行
      try {
        destroy();
      } catch (error) {
        captureCommitPhaseError(fiber, error);
      }
    }
  }
```
在阶段二，会遍历并执行所有useEffect的回调函数。
```js
// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect
const mountEffects = pendingPassiveHookEffectsMount;
pendingPassiveHookEffectsMount = [];
for (let i = 0; i < mountEffects.length; i += 2) {
  const effect = ((mountEffects[i]: any): HookEffect);
  const fiber = ((mountEffects[i + 1]: any): Fiber);
  
  try {
    const create = effect.create;
   effect.destroy = create();
  } catch (error) {
    captureCommitPhaseError(fiber, error);
  }
}
```


整个layout阶段逻辑就是这些。
注意到current Fiber树切换代码是在layout阶段的第一行。
在双缓存机制一节我们介绍过，workInProgress Fiber树在commit阶段完成渲染后会变为current Fiber树。这行代码的作用就是切换fiberRootNode指向的current Fiber树。

那么这行代码为什么在这里呢？（在mutation阶段结束后，layout阶段开始前。）

我们知道componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的。componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的。

要注意到，mutation阶段构建了新的dom树，layout阶段的componentDidMount之前其实只是完成了渲染树，执行了一些生命周期和effect，最终渲染树定型，这时候所有数据有了，但是控制权还在js线程手中，这时候在componentDidMount中执行setState或者其他一些dom修改，最后浏览器只会保留最终的结果，layout之后应当就是paint，将控制权交给渲染线程，渲染线程根据document，完成屏幕真正的绘制工作。


# 状态更新
https://juejin.cn/post/7230754517914091576
详细描述 update 优先级 setState等

## 创建Update对象

在每次状态更新，都会创建保存一个更新状态的相关的对象，称为Update对象，在render的beginwork中会根据Update得到新的state。
在React中，通过ReactDOM.createBlockingRoot和ReactDOM.createRoot创建的应用会采用并发的方式更新状态；
高优更新中断正在进行中的低优更新，先完成render - commit流程；
待高优更新完成后，低优更新基于高优更新的结果重新更新；（有点类似git版本控制中的修复bug分支后rebase）

### Update的分类
触发方法                组件
ReactDOM.render     （HostRoot）
this.setState       （ClasssComponent）
this.forceUpdate    （ClassComponent）
useState            （FunctionComponent）
useReducer          （FunctionComponent）

共有三种组件支持Update：HostRoot 、ClassComponent、FunctionComponent，
其中，ClassComponent与HostRoot共用一套Update结构，
FunctionComponent单独使用一种Update结构。
虽然他们的结构不同，但是工作机制与工作流程大体相同。在这里介绍前一种Update，FunctionComponent对应的Update在后面介绍。

### Update结构
ClassComponent与HostRoot（即rootFiber.tag对应类型）共用同一种Update结构
```js
const update: Update<*> = {
  eventTime, // 任务时间，通过performance.now() 获取的毫秒数；
  lane, // 优先级相关字段；
  suspenseConfig, // Suspense相关；
  tag: UpdateState, // 更新的类型，包括UpdateState | ReplaceState | ForceUpdate | CaptureUpdate；
  payload: null, // 更新挂载的数据，不同类型组件挂载的数据不同。对于ClassComponent，payload为this.setState的第一个传参。对于HostRoot，payload为ReactDOM.render的第一个传参；
  callback: null, //commit layout中支持的回调函数。

  next: null, // commit layout中支持的回调函数。
};
```

### Update与Fiber联系
Fiber节点组成Fiber树，页面中最多同时存在两颗Fiber树：

代表当前页面状态的current Fiber树
代表正在render阶段的workInProgress Fiber树

类似Fiber节点组成Fiber树，Fiber节点上的多个Update会组成链表并被包含在fiber.updateQueue中。

什么情况下，一个Fiber节点会有多个Update
```js
onClick() {
  this.setState({
    a: 1
  })

  this.setState({
    b: 2
  })
}
```
Fiber节点最多同时存在两个updateQueue：

current fiber保存的updateQueue即current updateQueue
workInProgress fiber保存的updateQueue即workInProgress updateQueue

在commit阶段完成页面渲染后，workInProgress Fiber树变为current Fiber树，workInProgress Fiber树内Fiber节点的updateQueue就变成current updateQueue。

### updateQueue
ClassComponent与HostRoot使用的UpdateQueue结构如下：
```js
const queue: UpdateQueue<State> = {
    baseState: fiber.memoizedState, // 本次更新前该Fiber节点的state，Update基于该state计算更新后的state，可以将baseState类比心智模型中的master分支；
    firstBaseUpdate: null,
    lastBaseUpdate: null, // 本次更新前该Fiber节点已保存的Update。以链表形式存在，链表头为firstBaseUpdate，链表尾为lastBaseUpdate。之所以在更新产生前该Fiber节点内就存在Update，是由于某些Update优先级较低所以在上次render阶段由Update计算state时被跳过，可以将baseUpdate类比心智模型中执行git rebase基于的commit（节点D）；
    shared: {
      pending: null,
    }, // 触发更新时，产生的Update会保存在shared.pending中形成单向环状链表。当由Update计算state时这个环会被剪开并连接在lastBaseUpdate后面，可以将shared.pending类比心智模型中本次需要提交的commit（节点ABC）。
    effects: null, // 数组。保存update.callback !== null的Update；
  };
```
保存在fiber节点UpdateQueue属性上。

### 更新demo
假设有一个fiber刚经历commit阶段完成渲染。

该fiber上有两个由于优先级过低所以在上次的render阶段并没有处理的Update。他们会成为下次更新的baseUpdate。

我们称其为u1和u2，其中u1.next === u2。
```
fiber.updateQueue.firstBaseUpdate === u1;
fiber.updateQueue.lastBaseUpdate === u2;
u1.next === u2;
```
我们用-->表示链表的指向：
`fiber.updateQueue.baseUpdate: u1 --> u2`

现在我们在fiber上触发两次状态更新，这会先后产生两个新的Update，我们称为u3和u4。
每个 update 都会插入到 updateQueue 队列上
当插入u3后：
```
fiber.updateQueue.shared.pending === u3;
u3.next === u3;
```
shared.pending的环状链表，用图表示为：
```js
fiber.updateQueue.shared.pending:   u3 ─────┐ 
                                     ^      |                                    
                                     └──────┘
```
接着插入u4之后：
```js
fiber.updateQueue.shared.pending = u4;
u4.next === u3;
u3.next === u4;

```
shared.pending是环状链表，用图表示为：

```
fiber.updateQueue.shared.pending:   u4 ──> u3
                                     ^      |                                    
                                     └──────┘
```

shared.pending 会保证始终指向最后一个插入的update

**更新调度完成后进入render阶段**。（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）。

此时shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面：

`fiber.updateQueue.baseUpdate: u1 --> u2 --> u3 --> u4`

接下来遍历updateQueue.baseUpdate链表，以fiber.updateQueue.baseState为初始state，依次与遍历到的每个Update计算并产生新的state；

在遍历时如果有优先级低的Update会被跳过；
当遍历完成后获得的state，就是该Fiber节点在本次更新的state

state的变化在render阶段产生与上次更新不同的JSX对象，通过Diff算法产生effectTag，在commit阶段渲染在页面上，同时，渲染完成后workInProgress Fiber树变为current Fiber树，整个更新流程结束。



## 从fiber到root
render阶段是从rootFiber开始向下遍历。那么如何从触发状态更新的fiber得到rootFiber呢？

调用markUpdateLaneFromFiberToRoot方法。
该方法做的工作可以概括为：从触发状态更新的fiber一直向上遍历到rootFiber，并返回rootFiber。

因为rootFiber需要被传递给commitRoot方法，开启commit阶段工作流程。

## 调度更新 转入render commit
现在有一个rootFiber，该rootFiber对应的Fiber树中某个Fiber节点包含一个Update。接下来通知Scheduler根据更新的优先级，决定以同步还是异步的方式调度本次更新。这里调用的方法是ensureRootIsScheduled。
ensureRootIsScheduled判断当前是否存在饥饿任务和更高优先级的任务。如果有更高优先级的任务，会中断当前任务执行，转而开始执行高优先级的任务。
```
if (newCallbackPriority === SyncLanePriority) {
  // 任务已经过期，需要同步执行render阶段
  newCallbackNode = scheduleSyncCallback(
    performSyncWorkOnRoot.bind(null, root)
  );
} else {
  // 根据任务优先级异步执行render阶段
  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
    newCallbackPriority
  );
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```

进入render阶段（`performSyncWorkOnRoot` 或 `performConcurrentWorkOnRoot`）。
至此，状态更新的流程已经通了。




# 疑问
## render阶段可能会被中断，如何保证updateQueue中的Update不会丢失？
在render阶段，shared.pending的环被剪开并连接在updateQueue.lastBaseUpdate后面。
实际上shared.pending会被同时连接在workInProgress updateQueue.lastBaseUpdate与current updateQueue.lastBaseUpdate后面。

当render阶段被中断后重新开始时，会基于current updateQueue克隆出workInProgress updateQueue。由于current updateQueue.lastBaseUpdate已经保存了上一次的Update，所以不会丢失。

当commit阶段完成渲染，由于workInProgress updateQueue.lastBaseUpdate中保存了上一次的Update，所以 workInProgress Fiber树变成current Fiber树后也不会造成Update丢失。


## 如何保证状态依赖的连续性？
当某个Update由于优先级低而被跳过时，保存在baseUpdate中的不仅是该Update，还包括链表中该Update之后的所有Update。
考虑如下例子：
```
baseState: ''
shared.pending: A1 --> B2 --> C1 --> D2
```

其中字母代表该Update要在页面插入的字母，数字代表优先级，值越低优先级越高。
第一次render，优先级为1。
```
baseState: ''
baseUpdate: null
render阶段使用的Update: [A1, C1]
memoizedState: 'AC'

```
其中B2由于优先级为2，低于当前优先级，所以他及其后面的所有Update会被保存在baseUpdate中作为下次更新的Update（即B2 C1 D2）。
这么做是为了保持状态的前后依赖顺序。
第二次render，优先级为2。

```
baseState: 'A'
baseUpdate: B2 --> C1 --> D2
render阶段使用的Update: [B2, C1, D2]
memoizedState: 'ABCD'
```

此时，React能保证最终的状态一定和用户触发的交互一致，但是中间过程状态无法保证。