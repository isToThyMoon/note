
https://mp.weixin.qq.com/s/dcPiKDGhMgX6VJ9IK413Ww

# concurrent并发渲染模式（时间分片和任务可中断重启）
React团队花了2年时间重构成Fiber架构，目的就是为了Concurrent Mode做铺垫。

Concurrent Mode（并发更新）是React一种新的更新模式，包含一组新的功能特性，其中最重要的特性就是： 异步可中断更新。

将大量的更新任务 (Batch update task) 拆分成一个个小的 task，从而让 event loop 有机会处理用户交互的 callback。

递归diff改成循环遍历 (while loop)，同时在每次循环结束做过期（expire) 判断（workInProgress !== null && !shouldYield()），如果过期就标记下当前的位置，break 出来，让 main thread 有机会完成高优先级的 work。

这个特性带来的好处就是让应用一直保持响应，也就是让用户不会觉得页面卡顿，带来更好的交互体验。

Fiber要在React16将递归的无法中断的更新重构为异步的可中断更新，需要解决两个问题：
1. 新的任务的异步调度。有⾼优先级任务的时候将浏览器让出来，等浏览器空了再继续执⾏；React在scheduler里实现了功能完备的requestIdleCallbackpolyfill (源码中叫scheduleCallback)；把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块（scheduler），看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 维护每一个工作分片的数据结构，就是Fiber。 
2. 支持中断的新的数据结构。由于曾经用于递归的虚拟DOM数据结构已经无法满足需要，新的数据结构，可以随时中断，下次进来可以接着执⾏；react16中虚拟DOM在react中有个正式的称呼 fiber。
3. 任务优先级

# 实现

所以实现concurrent模式的异步可中断更新需要完成三部分内容。
新数据结构支持render任务可中断可恢复。（fiber结构）
定义任务的重要程度和执行顺序。一种任务打断另一种任务，一定有优先级区别（lane模型）
怎么异步调度更新任务，何时中断（自实现的scheduler，是浏览器requestIdleCallback的polyfill）

## Fiber结构
fiber是react自定义的一种数据结构，也是代表新的更新工作流程。
颗粒化更新节点构成链表遍历更新，解决递归不可中断问题。

在重构Fiber架构之前，React是没办法解决这些问题的。因为在此之前，React的渲染更新主要是diff通过对比更新前后的虚拟DOM，找出不同进行更新，而对比的过程因为虚拟DOM树结构的限制，只能采用递归更新，我们知道递归一旦开始，中途就无法中断。

Fiber架构为什么能解决这个问题：

**每个Fiber节点对应一个React Element，保存有该组件的所有基本状态信息；**
**每个Fiber节点保存有该组件的更新信息；**

因为Fiber节点承载了基本状态和更新信息，这样React就可以将Fiber节点视为最小的工作单元，可以实现Fiber节点这种粒度的更新，因为粒度的细化也就使得异步可中断更新成为了可能。
fiber中有sibling child return指针指向对应兄 子 父节点，整体可以看作链式结构，diff时就可以链式遍历，可随时中断。

## lane模型 
划分更新任务优先级，实现任务执行顺序。

### 任务优先级
lane模型主要解决的是任务优先级问题。

采用Fiber架构后的React支持包括同步优先级在内的多种优先级，或者说新架构支持**并发更新**。
所以新架构可以模拟老架构的运行机制(即不开启并发更新)。

我们想中断渲染的本质是想让有更高优先级的任务可以中断低优先级任务来插队执行。那怎么定义任务优先级呢，lane模型通过31位的位运算符来定义：

```js
// lane使用31位二进制来表示优先级车道共31条, 位数越小（1的位置越靠右）表示优先级越高
export const TotalLanes = 31;

// 没有优先级
export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;

// 同步优先级，表示同步的任务一次只能执行一个，例如：用户的交互事件产生的更新任务
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;

// 连续触发优先级，例如：滚动事件，拖动事件等
export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
export const InputContinuousLane: Lanes = /*            */ 0b0000000000000000000000000000100;

// 默认优先级，例如使用setTimeout，请求数据返回等造成的更新
export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
export const DefaultLane: Lanes = /*                    */ 0b0000000000000000000000000010000;

// 过渡优先级，例如: Suspense、useTransition、useDeferredValue等拥有的优先级
const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;
const TransitionLane2: Lane = /*                        */ 0b0000000000000000000000010000000;
const TransitionLane3: Lane = /*                        */ 0b0000000000000000000000100000000;
...

```
可以看到React定义任务的优先级：

同步任务 > 连续触发事件任务 > setTimeout，
请求更新任务 > 过渡任务（React18新特性）


#### 具体同步任务和连续触发事件任务

```js
export function getEventPriority(domEventName: DOMEventName): * {
  switch (domEventName) {
    case 'cancel':
    case 'click':
    case 'copy':
    case 'dragend':
    case 'dragstart':
    case 'drop':
    ...
    case 'focusin':
    case 'focusout':
    case 'input':
    case 'change':
    case 'textInput':
    case 'blur':
    case 'focus':
    case 'select':
      // 同步优先级
      return DiscreteEventPriority;
    case 'drag':
    case 'mousemove':
    case 'mouseout':
    case 'mouseover':
    case 'scroll':
    ...
    case 'touchmove':
    case 'wheel':
    case 'mouseenter':
    case 'mouseleave':
      // 连续触发优先级
      return ContinuousEventPriority;
   ...
    default:
      return DefaultEventPriority;
  }
}

```

#### 调度优先级
调度优先级分为四种：

Immediate：立即执行，最高优先级。（同步优先级的任务开启）

render-blocking：会阻塞渲染的优先级，优先级类似 requestAnimationFrame。如果这种优先级任务不能被执行，就可能导致 UI 渲染被 block。（连续触发优先级的任务开启）

default：默认优先级，普通的优先级。优先级可以理解为 setTimeout(0) 的优先级。（默认优先级的任务开启）

idle：比如通知等任务，用户看不到或者不在意的。

```js
switch (lanesToEventPriority(nextLanes)) {
      case DiscreteEventPriority:
        schedulerPriorityLevel = ImmediateSchedulerPriority;
        break;
      case ContinuousEventPriority:
        schedulerPriorityLevel = UserBlockingSchedulerPriority;
        break;
      case DefaultEventPriority:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
      case IdleEventPriority:
        schedulerPriorityLevel = IdleSchedulerPriority;
        break;
      default:
        schedulerPriorityLevel = NormalSchedulerPriority;
        break;
    }
```

React根据lane模型来给不同的任务分配优先级，具体做法是： React更新主要是创建一个update对象，而update的lane会记录任务更新的优先级

### 任务饥饿
任务饥饿是讲一个低优先级的任务一直被高优先级的任务插队，导致这个任务已经过了执行期限依然没有得到执行，在这种情况下，React会将该任务置为同步渲染任务，在下次更新时立即执行。

### 任务插队
当执行任务调度之前，会调用ensureRootIsScheduled()。它会判断当前是否存在饥饿任务和更高优先级的任务。如果有更高优先级的任务，会中断当前任务执行，转而开始执行高优先级的任务。
```js
if (newCallbackPriority === SyncLanePriority) {
  // 任务已经过期，需要同步执行render阶段
  newCallbackNode = scheduleSyncCallback(
    performSyncWorkOnRoot.bind(null, root)
  );
} else {
  // 根据任务优先级异步执行render阶段
  var schedulerPriorityLevel = lanePriorityToSchedulerPriority(
    newCallbackPriority
  );
  newCallbackNode = scheduleCallback(
    schedulerPriorityLevel,
    performConcurrentWorkOnRoot.bind(null, root)
  );
}
```
低优先级任务如果被高优先级的任务插队，低优先级任务会直接被取消掉。因为高优先级的任务执行结果可能会影响到低优先级任务。

低优先级任务会再次加入任务队列。当高优先级任务执行完，页面重新渲染会再次走render，commit流程。



## scheduler任务调度 
https://xie.infoq.cn/article/76a0aea529c6b31b5a25da315

实现任务调度 任务中断 任务恢复。时间分片。


### 任务队列
scheduler中有两种任务队列，taskQueue和timerQueue。

timerQueue：依据任务的过期时间（expirationTime）排序，过期时间越早，说明越紧急，过期时间小的排在前面。过期时间根据任务优先级计算得出，优先级越高，过期时间越早。

taskQueue：依据任务的开始时间（startTime）排序，开始时间越早，说明会越早开始，开始时间小的排在前面。任务进来的时候，开始时间默认是当前时间，如果进入调度的时候传了延迟时间，开始时间则是当前时间与延迟时间的和。

在创建新的 task 时，如果发现这个任务的执行时间并不紧急，则会将其先放入 timerQueue 队列
优先执行的 task 在 taskQueue 队列中
在不同的执行阶段会通过 advanceTimers 方法，从 timerQueue 中将快过期的任务让如到 taskQueue 队列

在开始调度的时候，timerQueue快过期任务，会先清空timerQueue，将它们加入到taskQueue中。
```js
let timer = peek(timerQueue);
  while (timer !== null) {
    if (timer.callback === null) {
      // Timer was cancelled.
      pop(timerQueue);
    } else if (timer.startTime <= currentTime) {
      // Timer fired. Transfer to the task queue.
      pop(timerQueue);
      timer.sortIndex = timer.expirationTime;
      push(taskQueue, timer);
      if (enableProfiling) {
        markTaskStart(timer, currentTime);
        timer.isQueued = true;
      }
    } else {
      // Remaining timers are pending.
      return;
    }
    timer = peek(timerQueue);
}
```


前面讲到任务调度优先级分为四种，因此他们对应的timeout也不同：
```js
// Times out immediately
var IMMEDIATE_PRIORITY_TIMEOUT = -1;
// Eventually times out
var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
var NORMAL_PRIORITY_TIMEOUT = 5000;
var LOW_PRIORITY_TIMEOUT = 10000;
```

调度优先级反应到任务身上就是过期时间，过期时间的计算就是：

`expirationTime = currentTime + timeout`

很明显，立即执行任务的timeout是-1，所以它在添加的那一刻就已经过期了，React就视为它应该立即执行。

```js
// 如果delay大于0，startTime = currentTime + delay
startTime = currentTime 

expirationTime = startTime + timeout

  if (startTime > currentTime) {
    // This is a delayed task.
    newTask.sortIndex = startTime;
    push(timerQueue, newTask);
    
  } else {
    newTask.sortIndex = expirationTime;
    push(taskQueue, newTask);
  }
```

```js
unstable_scheduleCallback(priorityLevel, callback, options)
// 这里的options对象就是{delay: number}，
// 传delay就表示需要延迟执行的任务，会加入timerqueue排队，等delay时间到了就会取出来加入taskqueue
```




### 时间切片
如何实现时间分片呢？

时间切片的基本原理如下：
* React Fiber 会将渲染任务划分成多个小任务，每个小任务一般只负责一小部分 DOM 更新。
* React Fiber 将这些小任务保存到任务队列中，并按照优先级进行排序和调度。
* 当浏览器处于空闲状态时，React Fiber 会从任务队列中取出一个高优先级的任务并执行，直到任务完成或者时间片用完。
* 如果任务完成，则将结果提交到 DOM 树上并开始下一个任务。
* 如果时间片用完，则将任务挂起，并将未完成的工作保存到 Fiber 树中，返回控制权给浏览器。
* 当浏览器再次处于空闲状态时，React Fiber 会再次从任务队列中取出未完成的任务并继续执行，直到所有任务完成。

首先分片大小和渲染频率有关，浏览器的一般帧率是60fps，即一帧16.7ms。因此每个js任务不能大于16.7ms，否则就会出现帧卡顿。如果执行时间大于16.7ms，就要停止，然后让浏览器先执行渲染操作，渲染空余时候再继续执行。

这就要求React拥有暂定和重启diff操作的能力。为了性能，实际代码中react采用的时间分片时间并不是16.7ms。


React根据浏览器的requestIdleCallback写了一个库scheduler。

它规定一个时间切片为5ms

`export const frameYieldMs = 5;`

正常情况下，在一个时间切片里，任务循环调度，每调度完成一个任务都会检查时间片，当到达时间切片长度中断渲染交出控制权。

交出控制权的前提是：当前任务队列中没有过期任务；

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5451147a56f3441381264abc45deb422~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

Concurrent Mode只能中断render阶段任务，不能中断commit阶段任务。

因为commit阶段会直接进行DOM更新，DOM更新是无法中断的，必须一次性执行完成。



#### 禁用时间切片
* 存在阻塞渲染的任务； 
* 存在饥饿任务；
当存在上面两种情况时，直接走同步渲染，而不是Concurrent Mode。


### 任务中断和恢复
基于React16及之前的版本的架构很难实现断电重启功能，因为虚拟dom天然是嵌套结构，diff是递归操作。因此React团队称React16之前的调度器为栈调度器。
栈的问题，首先递归结构每次创建函数需要生成执行上下文、变量对象，性能消耗较大。另一方面，递归结构不方便进行中断重启。比如深度优先遍历的话，遍历到某个节点时候中断，再重启时候，如果没有复杂的辅助数据结构，是不知道下一个要遍历哪个节点的。
鉴于栈结构的问题，React需要新的架构来支持断点重启。

Fiber架构应运而生。
将虚拟dom树结构改成链表结构，链表结构利于暂停和重启，比如遍历到某个节点时候需要暂停，那么只要记录当前指针，等到重启时候指向下一个就可以了。

如果在 reconciler 中的 workLoopConcurrent 被中断了，则会返回一个 performConcurrentWorkOnRoot 方法，在 scheduler 中的 workLoop 发现 continuationCallback 返回的值为一个方法，则会存下当前中断的回调，且不让当前执行的任务出栈，也就意味着当前的 task 没有执行完，下一次循环时可以继续执行，而执行的方法便是 continuationCallback 。



# 其他

当新架构开启并发更新后，就能使用React为了解决CPU的瓶颈、IO的瓶颈而设计的并发特性(Concurrent Feature)，比如：

useDeferredValue
useTransition
全功能的Suspense

# Suspense原理
浏览器阻塞渲染有两个来源，一个是js执行阻塞浏览器渲染，另一个是网络请求阻塞界面渲染。

js执行阻塞浏览器渲染，通过并发更新模式的优先级调度来协调资源，可中断渲染来解决。

网络请求阻塞界面渲染通过suspense方案解决，其实网络请求阻塞界面渲染可以开发者自己手动实现，基本逻辑就是某个组件如果在代码或者数据还没有准备好时候，先渲染一个loading，等准备好了之后再渲染组件，suspense为这种场景提供了比较通用和使用方便的解决方案。

Suspense组件用来实现组件未准备好时候的loading。
某个组件如果是异步加载的（动态import），或者依赖一些业务数据，当异步代码未加载完成或者业务数据网络请求未到达时候，该组件应该渲染一个loading，等组件准备好后再替换掉loading。
整个过程大概是一个组件或者一个路由界面在准备好之前，先渲染loading，组件在内存中准备好后再渲染，这种处理方式看起来像是React可以在内存中并行地渲染，因此也是并发模式（concurrent mode）中的一部分。
看下面示例代码
```js
import React, {Suspense} from 'react';
const AsyncComp = React.lazy(() => import('./comp'));

export default () => (
	<div>
    <Suspense fallback={<div>loading Comp</div>}>
    	<AsyncComp />
    </Suspense>
  </div>
);
```
当一个组件处于“挂起”状态时候，React 会显示出距其上游最近的 的 fallback。
什么是“挂起”状态呢？Suspense类似ErrorBoundary，它规定其内部组件如果throw了一个promise，则是处于挂起状态，见下面示例，这个示例展示如何让一个组件告诉Suspense自己是否已经准备好可以渲染，它的场景是数据未准备好时候的渲染。

```js
import React, { Suspense, lazy } from 'react';
 
let data = '';
let promise = '';

function requestData() {
  if (data) {
  	return data;
  }
  if (!promise) {
    promise = new Promise(resolve => {
      setTimeout(() => {
        data = 'Data resolved';
        resolve();
      }, 2000);
    });
  }
  throw promise;
}
 
function SuspenseComp() {
  const data = requestData();
 
  return <p>{data}</p>;
}
 
export default () => (
  <Suspense fallback="loading data">
    <SuspenseComp />
  </Suspense>
);
```

如果一个组件是异步的（数据或者代码），可以通过suspense包裹它来实现异步更新渲染。
被包裹的组件首次渲染时候，数据/异步组件代码还未ready，所以会throw一个promise，Suspence会catch子组件throw的promise，然后将任务添加到更新队列中，React后面会异步处理更新队列，取出promise执行，当promise resolve之后，会再次渲染组件，这时候组件有了数据，不再throw promise，就会正常渲染。

Suspense在React16中已经支持，主要用在异步加载组件。

# React.lazy原理
React.lazy核心逻辑就是throw一个异步加载组件的promise，加载好后return这个组件（所以如果其外部不包裹Suspense，也没有ErrorBoundary的话，页面就会崩溃）。
React.lazy接收一个函数作为参数，这个函数需要返回一个thenable对象。React.lazy会先执行方法，得到异步加载组件的promise，然后throw这个promise。promise被Suspense捕获后进入异步处理队列，等组件加载好后，React.lazy就返回thenable对象resolve的对象的default属性，这个default属性就是异步加载的组件。

```js
// 引用MyComponent
const AsyncComponent = React.lazy(() => import('./MyComponent'));

// MyComponent.js
...
export default class MyComponent extends React.Component {
  ...
}
```
这里我们用到了webpack的动态import，动态import会返回一个promise，组件加载完成后会resolve模块，使用ESM模块规范，resolve的模块的default属性就是组件MyComponent本身。