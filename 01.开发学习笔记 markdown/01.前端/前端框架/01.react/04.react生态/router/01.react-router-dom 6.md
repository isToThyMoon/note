
react-router-domv6官方推荐安装：

```bash
npm create vite@latest myproject -- --template react
cd myproject
npm install react-router-dom localforage match-sorter sort-by
npm run dev
```

配合react18的更新，react-router6.x
[官方文档和示例](https://reactrouter.com/en/6.4.3/start/overview)

HashRouter和BrowserRouter的区别：
HashRouter 只会修改URL中的哈希值部分；而 BrowserRouter 修改的是URL本身
HashRouter 是纯前端路由，可以通过输入URL直接访问，一切由前端控制；www.xxx.com/dada/map#/mainpage
使用时 BrowserRouter 直接输入URL会显示404，除非配置Nginx将请求指向对应的HTML文件。初次进入 / 路径时或点击 Link 组件跳转时不会发送请求。

BrowserRouter需要服务端配合配置，对所有路由匹配到index.html，react已经对路由做了处理：


```
server {
	server_name react.thinktxt.com;
	listen 80;

	root /Users/txBoy/WEB-Project/React-Demo/dist;
	index index.html;
	location / {
    	try_files $uri /index.html;
  	}
}
```

通过配置Nginx，访问任何URI都指向index.html，浏览器上的path，会自动被React-router处理，进行无刷新跳转。


# 升级到react-router v6
6.4开始支持data api，也就是loader和action写法，让react router dom获得获取数据的能力。
In v6.4, new routers were introduced that support the new data APIs:
```js
createBrowserRouter
createMemoryRouter
createHashRouter
```

The following routers do not support the data APIs:
```js
<BrowserRouter>
<MemoryRouter>
<HashRouter>
<NativeRouter>
<StaticRouter>
```

新版的react-router使用函数式创建router方式，可以支持最新的data api，以前的jsx嵌套形式的根路由HashRouter等是不支持data api的，所以如果使用新版react-router，务必使用新方式创建路由。
必须结合`<RouterProvider>`一起使用。

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import {
  createBrowserRouter,
  RouterProvider,
  Route,
} from "react-router-dom";
import "./index.css";

const router = createBrowserRouter([
  {
    path: "/",
    element: <div>Hello world!</div>,
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```

当然官方也提供了createRoutesFromElements这个api让你能够非常容易地从旧版jsx方式迁移，route object的配置方式不是必须，借助createRoutesFromElements，jsx方式和route object的方式是可选的。

```jsx
import {
  createBrowserRouter,
  RouterProvider,
} from "react-router-dom";

const router = createBrowserRouter(
  createRoutesFromElements(
    <Route path="/" element={<Root />}>
      <Route path="dashboard" element={<Dashboard />} />
      {/* ... etc. */}
    </Route>
  )
);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```
据体验来说，vue3也采用了新函数式的router创建方式，但是它们创建内嵌路由的思路不一样，其他地方也有差别，可使用时具体体悟。


# 不用data api 仍采用标签式创建路由
```js
import { BrowerRouter, HashRouter, Routes, Route } from "react-router-dom";
import App from "./app";

const RootRouter:React.FC<any> = () => {

  return(
    <HashRouter>
      <Routes>  // v5版本的Switch变成Routes
        <Route path="/" element={<App/>}/>
        //element：这个是新增的，用于决定路由匹配时，渲染哪个组件。在v5的时候，我们通常会用到component这个属性，或者是render；v6中component/render被element替代
      </Routes>
    </HashRouter>
  )
}

export default RootRouter;
```

BrowerRouter, HashRouter最好放最顶层。

# 路由跳转
路由跳转时，/开头是绝对路由，否则是相对路由，即相对当前URL进行改变

NavLink和Link组件功能是一致的，区别在于可以判断起to属性是否是当前匹配到的路由
navLink组件的style或className可以接收一个函数，函数接收一个含有isActive字段的对象为参数，可根据该参数调整样式

```js
import { NavLink } from "react-router-dom";

function Foo() {
  return (
    <NavLink style={({ isActive }) => ({ color: isActive ? "red" : "#fff" })}>
      Click here
    </NavLink>
  );
}
```

redirect
路由重定向，当这个组件出现时，就会执行跳转到对应to的路径：
`{name ? <Redirect to='/'/> : null}`

switch
匹配第一个组件时，后面就不再匹配。

## 编程式跳转
使用useNavigate钩子函数生成navigate函数，可以通过 JS 代码完成路由跳转

> useNavigate取代了原先版本中的useHistory

// v5
const history = useHistory();
history.push('/home');
history.replace('/home');

// v6
const navigate = useNavigate();
navigate('/home');
navigate('/home', {replace: true});

```
import { useNavigate } from 'react-router-dom';

function Foo(){
    const navigate = useNavigate();
    return (
        // 上一个路径：/a；    当前路径： /a/a1
        <div onClick={() => navigate('/b')}>跳转到/b</div>
        <div onClick={() => navigate('a11')}>跳转到/a/a1/a11</div>
        <div onClick={() => navigate('../a2')}>跳转到/a/a2</div>
        <div onClick={() => navigate(-1)}>跳转到/a</div>
    )
}
```
可以直接传入要跳转的目标路由（可以使用相对路径，语法和 JS 相同）
传入-1表示后退




-------
# hooks

## useHistory
让函数组件内部直接访问history对象
```js
...
const history = useHistory();

....


<button onClick={()=>{history.push('/')}}></button>
```
## useLocation

```js
const {pathname} = useLocation();
```

## 使用 useLocation() 钩子通过 React Router 获取当前路由
函数内部直接访问location对象
```js
const location = useLocation();
 
// useLocation也可以获得编程跳转携带的参数
navigate('/your-route-path', { state: { name: 'dada' }});
const location = useLocation();
const { name } = location.state; // 'dada'
```
 
-------

