
# 动态路由参数

## useParams使用路径参数params
在Route组件中的path属性中定义路径参数
在组件内通过useParams hook 访问路径参数
```
<BrowserRouter>
  <Routes>
    <Route path="/foo/:id" element={<Foo />} />
  </Routes>
</BrowserRouter>;

import { useParams } from "react-router-dom";
export default function Foo() {
  const params = useParams();
  return (
    <div>
      <h1>{params.id}</h1>
    </div>
  );
}
```
### 路径匹配规则
当URL同时匹配到含有路径参数的路径和无参数路径时，优先匹配没有参数的”具体的“（specific）路径。

<Route path="teams/:teamId" element={<Team />} />
<Route path="teams/new" element={<NewTeamForm />} />
如上的两个路径，将会匹配 teams/new 。

路径的正则匹配已被移除。

### 兼容类组件
在以前版本中，组件的props会包含一个match对象，在其中可以取到路径参数。

但在最新的 6.x 版本中，无法从 props 获取参数。

并且，针对类组件的 withRouter 高阶组件已被移除。因此对于类组件来说，使用参数有两种兼容方法：

1.将类组件改写为函数组件
2.自己写一个 HOC 来包裹类组件，用 useParams 获取参数后通过 props 传入原本的类组件


## useSearchParams使用search参数query
查询参数不需要在路由中定义
使用 useSearchParams hook 来访问和修改查询参数。其用法和 useState 类似，会返回当前对象和更改它的方法
使用 setSearchParams 时，必须传入所有的查询参数，否则会覆盖已有参数
```js
import { useSearchParams } from "react-router-dom";

// 当前路径为 /foo?id=12
function Foo() {
  const [searchParams, setSearchParams] = useSearchParams();
  console.log(searchParams.get("id")); // 12
  setSearchParams({
    name: "foo",
  }); // /foo?name=foo
  return <div>foo</div>;
}
```

## 传入对象
通过location获取







# 路由传递参数 v6

params   
 '/home/:id'   
 直接拼到url，刷新地址栏后参数依然存在，但是只能传递字符串，只适合短小url
 
query（search）
"/home?id=123"   
类似常规网页的query，刷新地址栏后参数会丢失，适合key value形式传递

state
存储在location中的对象


# params
子路由携带 params形式传递 需要路由协助配置

路由配置代码：
```
function App() {
    return (
        <BrowserRouter>
            <Routes>
                <Route path={'/'} element={<Login/>} />
                <Route path={'/home/:id'} element={<Home/>} />
            </Routes>
        </BrowserRouter>
    )
}
```

原页面跳转代码：
```
//路由链接(携带参数)：
<Link to={{ pathname:`/home/${id}` }}>Child1</Link>
```

```js
// js跳转
const navigate = useNavigate()

const goHome = () => {
    navigate("/home/123")
}

```

接收参数：
```js
const params = useParams()

const back = () => {
    console.log(params.id)  //打印结果为 123
}

```



# query形式传参（search）

这种形式不需要再配置路由代码

原页面跳转代码
```
//路由链接(携带参数)：
 <Link className="nav" to={`/home?id=123`}>Child2</Link>
```

```js
// js跳转
const navigate = useNavigate()
const goHome = () => {
    navigate("/home?id=123")
}
```

跳转页面处理代码：

查询参数不需要在路由中定义

接收参数方法1：
使用useLocation，但是需要qs来解析
```
import { useLocation } from "react-router-dom";
import qs from "query-string";
const { search } = useLocation();

```

使用 useSearchParams hook 来访问和修改查询参数。其用法和 useState 类似，会返回当前对象和更改它的方法
使用 setSearchParams 时，必须传入所有的查询参数，否则会覆盖已有参数
```js
import { useSearchParams } from "react-router-dom";

// 当前路径为 /foo?id=123
function Foo() {
  const [searchParams, setSearchParams] = useSearchParams();
  console.log(searchParams.get("id")); // 123
  setSearchParams({
    name: "foo",
  }); // /foo?name=foo
  return <div>foo</div>;
}
```



# 通过state传参
可以传对象
但`<HashRouter>`下刷新页面，参数会丢失

原页面跳转代码：
```
//通过Link的state属性传递参数
 <Link
     className="nav"
     to={`/home`}
     state={{ id:123 }} 
 >
    Child2
</Link>
```

```js
// js跳转
const navigate = useNavigate()

const goHome = () => {
    navigate("/home",{state:{ id:123 }})
}
```

目标页面处理代码
```js
//接收参数：
import { useLocation } from "react-router-dom";
const { state } = useLocation();
//state参数 => {id: 123 }

const back = () => {
// 说明state是location对象中的数据
    console.log(location.state.id) //打印结果为123
}
```