npx create-react-app my-app
初始化默认安装了`react` `react-dom` 和`react-scripts`

# 为什么要分为react react-dom两个包？（把react看作react-core）

其实react包名字定为react-core可能会更好，会避免很多混乱。

React不仅能用在Web页面，还能用在服务器端SSR，移动端和桌面端，而ReactDOM只负责和Web页面的DOM打交道

react在v0.14之前是没有react-dom包的，所有功能都包含在react包里。
从v0.14(2015-10)开始，react才被拆分成react和react-dom。
为什么要把react和react-dom分开呢？因为有了react-native。
react只包含了Web和Mobile通用的核心部分，负责Web-Dom操作的分到react-dom中，负责Mobile的包含在react-native中。

react-dom只做和浏览器或DOM相关的操作，例如ReactDOM.render()和ReactDOM.findDOMNode()。如果是服务器端渲染，可以ReactDOM.renderToString()。除这些以外的其他所有的事情都是react做的。

例如Web端的React代码：
```js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import IRouter from './router.js';
import * as serviceWorker from './serviceWorker';

ReactDOM.render(<IRouter />, document.getElementById('root'));
```

移动端的ReactNative代码：

```js
import React from 'react'; 
import {Text, View} from 'react-native'; 
const WelcomeScreen = () => 
    <View> 
        <Text style={header}>Step One</Text> 
        <Text> 
            Edit App.js to change this screen and turn it into your app. 
        </Text> 
        <Text style={header}>See Your Changes</Text> 
        <Text> 
            Press Cmd + R inside the simulator to reload your app’s code. 
        </Text> 
        <Text style={header}>Debug</Text> 
        <Text> 
            Press Cmd + M or Shake your device to open the React Native Debug Menu. 
        </Text> 
        <Text style={header}>Learn</Text> 
        <Text> 
            Read the docs to discover what to do next: 
        </Text>
    </View>
```
都需要 import React from 'react';
而Web应用还要 import ReactDOM from ‘react-dom’; 用ReactDOM来把jsx编译渲染到浏览器。
Mobile应用还要 import {Text, View} from 'react-native';

# 当我们要使用路由功能 router（router4.0）


## react-router：
是跨平台的，内置通用组件和通用Hooks。实现了路由的核心功能。

## react-router-dom：
基于react-router，加入了在浏览器运行环境下的一些功能，例如：
Link组件，会渲染一个a标签，Link组件源码a标签行; 
BrowserRouter和HashRouter组件，前者使用pushState和popState事件构建路由，后者使用window.location.hash和hashchange事件构建路由。（详细区别见浏览器 BOM）

react-router-dom依赖react-router，所以我们使用npm安装依赖的时候，只需要安装相应环境下的库即可，不用再显式安装react-router。基于浏览器环境的开发，只需要安装react-router-dom

react-router-dom的HashRouter, Route, Switch Link负责路由管理，它的withRouter方法和react-loadeable配合使用

（react-loadable    能够异步加载组件）

## react-router-native
基于react-router加入RN运行环境下的一些功能

## react-router-config
用于配制静态路由的工具库


# redux:
react是视图层框架，redux则是数据层框架，他不属于react，但是是react的生态库。

redux         基础包

react-redux   提供Provider组件 和connect方法 连接所有组件和store

redux-thunk   异步组件 异步请求和其他复杂逻辑放在容器组件里显得臃肿 统一移到Redux-thunk管理 是把异步逻辑放在action里执行
redux-saga    是把异步逻辑单独放在一个文件里统一管理 

redux-immutable  提供immutable的combineReducers 来拆分reducer    

immutable     提供 fromJS getIn set等方法 将对象变为不可变对象 在actionCreator 和UI组件中使用

axios   ajax请求 不支持跨域
jsonp   支持跨域


# 

获取按需加载组件 async-loadable

样式 公用样式使用sass引入在入口文件 页面级样式使用styled-components

DLL将公用依赖库封装为一个独立文件

# 不可变数据

数据控制 不可变数据 immutableJs -> immer

首先确定的必用生态库是immerJs，也是mobx作者的作品。

就算不用也应当了解它解决了什么问题。immerJs实现的目标就是不可变数据。

通过proxy方式实现（vue3也通过这种方式实现双向数据绑定）数据修改的侦听，每一次针对state的修改都会返回一个全新的值或者引用地址。没有多余api。

除了最开始需要通过`const newState = prduce(state)`接管数据，后续一切数据修改的语法都是js原生的语法。为什么通过proxy的方式而不是观察者模式，是为了让使用者能够以mutable的写法完成immutable式的数据更新，文档看10分钟就能明白。
produce函数入参1是原始数据，入参1是mutable函数，该函数的入参其实就是原始数据，你可以在mutable函数中对原始数据做任何你想的修改，而且语法是完全纯js的，最终produce函数会将修改的结果会以一个新的引用返回。
```js
let state =  { x: 1 }
state = produce(state, draft => {
	draft.x = 2;
	draft.y = 2;
    }
)
```

# 请求
axios自己封装
react query
最好使用swr.js

# 组件库
antd + postcss + sass + css module
后续可以尝试更新Mui + css in js
css in js方案目前主要有styled Component和tailwind

# 多平台
react生态两大强力方案next.js和React Native 
一个ssr 一个移动端。

 小程序taro标配，vant写h5移动。

# 移动端
考虑react native 写rn最好学习下kotlin或者swift其中一种，事半功倍，会写rn省去写dart和flutter这些技术。