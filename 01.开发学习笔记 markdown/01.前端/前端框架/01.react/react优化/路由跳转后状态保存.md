

react跳转页面后回跳保存之前的状态

“路由页面跳转后状态保存”指的是在开发业务需求过程中经常会碰到的一种情况——在一个页面（通常是表格页）进行一顿猛如虎的操作之后，点击某一项详情进入另外一个页面之后再返回（点击后退按钮），上一页还可以保持原先的状态不变（页面、搜索词等）。
但是在React中目前并不存在这个功能，此前曾经有人提出过相关的Issues(github.com/facebook/re…

<keep-alive> 是用在其一个直属的子组件被切换的情形。如果你在其中有 v-for 则不会工作。如果有上述的多个条件性的子元素，<keep-alive> 要求同时只有一个子元素被渲染。React官方不希望引入这种只在某些特定情况下才能工作的API，他们的设计理念希望React中的API在所有情况下都能够以相同的方式工作。这样，用户只需要学习一次API就能够在任何地方使用。
<keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。React官方认为这种行为是一种内存泄漏，当用户在不同页面间导航时会使得内存占据不断变大。这种内存占据在一开始时可能不会引起开发者的关注，然而当应用越来越大，越来越复杂，直到内存占据成为问题时，开发者会发现所有页面都依赖这种工作方式，此时再去修改很可能已经悔之晚矣。因此React官方认为这是一种“不负责任的内存使用”。

因此，React官方暂时没有实现<keep-alive>类似的功能。为了达到状态保存的效果，官方推荐以下两种手动保存状态的方式：

将需要保存状态组件的state提升至父组件中保存。
使用css visible属性来控制需要保存状态组件的渲染，而不是使用if/else，避免React将其卸载。


虽说手动保存状态是React官方推荐的最佳实现方式，然而我们在实际开发中将所有页面的状态都手动保存几乎是不现实的，为了不需要每次都关心如何对数据进行保存恢复，我们还是需要某些方式来自动实现状态保存。


自动状态保存库主要从两方面下手：

改变路由机制，通常基于React-Router二次开发。React-Router在路由切换时默认卸载非活动组件，因此这些库通过重写React-Router中的部分功能或者将其拓展的方式使得在路由切换时相关组件不被直接卸载，而是缓存下来。这种实现方式决定了状态保存的粒度只能具体到SPA的页面级别。
改变React组件被移除的方式。React在组件被移除时默认是被卸载的，这些库通过某些方式阻止或欺骗React使相关组件在移除时不被直接卸载，而是缓存下来。通过这种实现方式，状态保存的粒度可以精细到组件级别。

可以看到，无论对于哪种实现，最最最重要的思想就是阻止组件卸载，将相关组件移出页面展示，但是保存在内存之中。在之后需要恢复状态时直接将内存中的组件挂载在页面之中。

为什么不unmount 时储存状态，re-mount 时取回状态呢？

需要自己选择要存储的信息。
父组件无法拿到子组件的状态进行保存。
会重新 unmount 和 re-mount，这其实是不应该发生的，被隐藏的列表页应该是“潜伏”在详情页的下面，等到重新进入列表页时才出现，而不是已经被 unmount 了。


1. 重写路由库，如react-keeper
React-Keeper不单单实现了页面缓存，还提供了3种不同的页面缓存方式：


永久缓存，只要根组件不卸载，页面将永久缓存。
父组件缓存，在父组件不卸载的情况下会维持缓存状态。
临时缓存，作用在页面跳转时，打开新页面后会临时缓存链接的来源页面，当返回时至之前页面（或路由状态变更）时，提取缓存页面展示，并清除缓存。非常适合于列表页的缓存。

其好处是不仅可以实现状态保存，还可以更进一步的提供一些强大缓存管理机制。但是React-Keeper直接替换了React-Router，这样做风险比较大，可能需要踩坑。

2. 重写 <Route> 组件，如react-live-route
React-Live-Router中重写并导出了一个LiveRoute组件，通过LiveRouter包裹的页面可以自动保存状态。
其大致原理是根据路由匹配情况来隐藏/显示对应页面。
相比于重写路由库，这种方案的实现成本和使用成本都低一些，但是其缺陷也是非常明显的，开发者需要考虑其与React-Router版本的兼容情况，库作者也需要跟随React-Router的升级而升级库。React-Live-Router目前只支持4版本的React-Router（截止2022-01-11，React-Router已经更新到6版本）。


改变React组件被移除的方式
基于ReactDom.createPortal实现，如react-keep-alive
React-Keep-Alive有两个主要的组件 <Provider> 和 <KeepAlive>；<Provider> 负责保存组件的缓存，并在处理之前通过 React.createPortal API 将缓存的组件渲染在应用程序的外面。缓存的组件必须放在 <KeepAlive> 中，<KeepAlive> 会把在应用程序外面渲染的组件挂载到真正需要显示的位置。
React-Keep-Alive原理大致为将<KeepAlive>的children 提取出来渲染到<Provider> 节点下，而非 <KeepAlive>之下，这也导致 <KeepAlive>中的组件无法被 React认为是在其所处的上下文之中，会对Context 造成破坏。
目前React-Keep-Alive基本处于弃更状态了，它存在着以下几个问题：


内嵌自定义context中读取不到consumer数据。
事件冒泡失效。
KeepAlive 内部依赖于外部数据的 children 更新失效。



基于Dom操作实现，如react-activation
React-Activation使用上非常简单，直接用其导出的 <KeepAlive>组件包裹希望保存状态的组件即可。React-Activation与React-Router-Cache-Route作者一致，因此也提供了useActivate和useUnactivate生命周期钩子。
React-Activation的实现受到了React-Keep-Alive的启发，不过移除了对 React.createPortal API的使用，改为直接DOM操作，实现方式更优雅。并且，React-Activation解决了React-Keep-Alive中的一些问题。

```js
import React, {
	createContext,
	useState,
	useEffect,
	useRef,
	useContext,
	useMemo,
	useCallback
} from "react";

const Context = createContext();

// 缓存的虚拟DOM元素会储存在AliveScope 组件中，所以它不能被卸载
export function AliveScope(props) {
	// state用来存储keepalive组件的id与其children
	const [state, setState] = useState({});
	// ref只创建一次，用来存储子组件渲染后的实例
	const ref = useMemo(() => {
		return {};
	}, []);

	const keep = useCallback((id, children) =>
		new Promise((resolve) => {
			// 存储KeepAlive中的id与children对应关系，用于在AliveScope中渲染
			setState(state => ({
				...state,
				[id]: { id, children },
			}));
			// 将渲染后的实例dom ref[id]返回KeepAlive中，便于其移动到真实需要展示的位置
			setTimeout(() => {
				//需要等待setState渲染完拿到实例返回给子组件。
				resolve(ref[id]);
			});
		}), [ref]);

	return (
		<Context.Provider value={keep}>
			{props.children}
			{/* 这里react对KeepAlive组件的children进行渲染，渲染完成后会被appendChild移动至其真实需要渲染的位置 */}
			{Object.values(state).map(({ id, children }) => (
				<div
					key={id}
					ref={(node) => {
						ref[id] = node;
					}}
				>
					{children}
				</div>
			))}
		</Context.Provider>
	);
}

export function KeepAlive(props) {
	const ref = useRef(null);
	const keep = useContext(Context);

	useEffect(() => {
		const init = async ({ id, children }) => {
			// 通过keep函数将KeepAlive中的信息传递给父组件AliveScope处理
			// AliveScope帮助渲染children,并将渲染后的实例dom realContent返回
			const realContent = await keep(id, children);
			// 将渲染后的realContent移动到KeepAlive中展示
			if (ref.current) {
				ref.current.appendChild(realContent);
			}
		};
		init(props);
	}, [props, keep]);

	return <div ref={ref} />;
}

export default KeepAlive;
```

```js
import React, { useState } from 'react';
import KeepAlive, { AliveScope } from './ActivationKeepAlive';

function Counter() {
  const [count, setCount] = useState(0);
  return (
    <div>
      count: {count}
      <button style={{marginLeft: 20}} onClick={() => setCount((count) => count + 1)}>add</button>
    </div>
  );
}

export default function Page() {
  const [show, setShow] = useState(true);
  return (
      <AliveScope>
        <div>
          <button onClick={() => setShow((show) => !show)}>Toggle</button>
          <p>无 KeepAlive</p>
          {show && <Counter />}
          <p>有 KeepAlive</p>
          {show && (
            <KeepAlive id="Test">
              <Counter />
            </KeepAlive>
          )}
        </div>
      </AliveScope>
  );
}
```
当然，以上只是其大致原理，React-Activation中对于其它的一些由于打破了React原有层级关系而造成的问题做了一些修复，包括：
渲染延迟（已修复）
Context 上下文功能失效（已修复）
Error Boundaries 失效（已修复）
React.Suspense & React.lazy 失效（已修复）
React 合成事件冒泡失效（未修复）
其他未发现的功能


如果项目中需要状态缓存处理的数据量较小，那最好还是按照React官方的建议，手动解决状态缓存问题。
如果处理数据量较大，且缓存粒度为页面级别，那么推荐使用react-router-cache-route。
如果处理数据量较大，且缓存粒度为组件级别，或者你的项目框架采用了umi（无法直接触及react-router），或者干脆没有使用react-router路由，那么推荐使用react-activation。此外umi中使用react-activation可以直接使用其封装插件umi-plugin-keep-alive。

最后的最后，React官方在一些关于strict mode的回复中提到了其正在开发的<Offscreen> 组件，并且预计其在react@18.X（非18早期版本）中可能会出现，其功能与vue<keep-alive>类似。如果React官方能够支持的话想必是自动状态保存最好的出路。


# unmount 时储存状态，re-mount 时取回
既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：

前组件会被卸载
前组件不会被卸载

那么我们可以按照这两种情况分别得到以下几个方法：

A 组件会被卸载：
1. 全局 store (redux/dva)
毫无疑问，这是最通用的方法。将过滤选项放置到全局的 redux store 中，如果你在项目中使用了 redux 的话。

2. 将状态储存在 LocalStorage / SessionStorage
兼容性好，不需要额外库或工具。
简单快捷，基本可以满足大部分需求。

这个方法很简单，只需要在组件即将被销毁的声明周期 componentWillUnmount 中在 LocalStorage / SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。
比如我们从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果我们从别的组件跳转到 B 组件的时候，实际上我们是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。
所以我们需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。

2. 路由传值
 
简单快捷，不会污染 LocalStorage / SessionStorage。
可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify / parse 的不足）

通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。
to 接受一个对象，参数可以包括：

pathname: A string representing the path to link to.
search: A string representation of query parameters.
hash: A hash to put in the URL, e.g. #a-hash.
state: State to persist to the location

在这里我们需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存之。返回 A 组件时再次携带 state 达到路由状态保持的效果。


A 组件不会被卸载
1. 单页面渲染
要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。

代码量少
不需要考虑状态传递过程中的错误

缺点
增加 A 组件维护成本
需要传入额外的 prop 到 B 组件
无法利用路由定位页面

2. 单页面渲染 + 路由匹配

不需要传入额外的 prop 到 B 组件
可以使用路由定位页面
但组件存在耦合
```js
const A = ({ history }) => {
  const [count, setCount] = useState(0);
  const handleChangeStatus = () => setCount(count + 1);

  const { pathname } = history.location;

  const isPage = (path) => {
    const regExp = new RegExp(`^${path}`);
    return regExp.test(pathname);
  };

  if (isPage("/B")) {
    return <B />;
  }

  if (isPage("/")) {
    return (
      <div className="App">
        <header className="App-header">
          <h1>这里是 A 组件</h1>
          <p>当前计数：{count}</p>
          <br />
          <button onClick={handleChangeStatus}>点我 +1</button>
          <br />
          <button>
            <Link to="/B">跳转到 B 组件</Link>
          </button>
        </header>
      </div>
    );
  }

  return null;
};

const B = () => {
  return (
    <div className="App">
      <header className="App-header">
        <h1>这里是 B 组件</h1>
        <br />
        <button>
          <Link to="/">点我返回</Link>
        </button>
      </header>
    </div>
  );
};
```