# 

reconciler从renderRoot方法出发，递归比对消费ReactElement，产出FiberNode构成FiberNode树。

可以想到，调用renderRoot方法的就是那些触发更新的api，只有它们才会使组件生成jsx产出ReactElement，继而产出current tree和workInProgress tree。

常见的触发更新的方式：

ReactDOM.createRoot().render（或老版的ReactDOM.render） 根组件触发

this.setState 不一定是根组件触发，可以是任意地方触发
useState的dispatch方法

我们希望实现一套统一的更新机制，他的特点是：

兼容上述触发更新的方式
方便后续扩展（优先级机制...）(同步不可中断，到异步不可中断)


更新机制的组成部分

代表更新的数据结构 —— Update
消费update的数据结构 —— UpdateQueue

该部分在updateQueue.ts中实现。

接下来的工作包括：

实现mount时调用的API
将该API接入上述更新机制中

需要考虑的事情：

更新可能发生于任意组件，而更新流程是从根节点递归的
需要一个统一的根节点保存通用信息

发生更新的组件向上递归到根节点


```
ReactDOM.createRoot(rootElement).render(<App/>)

ReactDOM.createRoot创建当前应用的一个统一根节点：fiberRootNode

current 和stateNode链接两者

rootElement也有自己对应的fiber节点：hostRootFiber 它是hostRoot类型的Fiber

child 和return链接

App对应也生成一个fiberNode，

```

![](https://wechatapppro-1252524126.cdn.xiaoeknow.com/appjiz2zqrn2142/image/b_u_622f2474a891b_tuQ1ZmhR/lb1kqa1h0lrm.png?imageView2/2/q/80%257CimageMogr2/ignore-error/1)
