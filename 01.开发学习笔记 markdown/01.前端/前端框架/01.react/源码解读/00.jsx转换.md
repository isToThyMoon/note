# React项目结构：

react（宿主环境无关的公用方法）
react-reconciler（协调器的实现，宿主环境无关）react的核心原理
各种宿主环境的包 如react-dom
shared（公用辅助方法，宿主环境无关）

JSX转换属于react包。


# 什么是jsx转化

手写一端jsx
```
<div>123</div>
```
react将他转换为一个方法调用的结果。
```
import { jsx as _jsx } from "react/jsx-runtime";

/*#__PURE__*/_jsx("div", {
  children: "123"
});

// 或
/*#__PURE__*/React.createElement("div", null, "123");
```
可以认为react17之前都是createElement，17之后都是_jsx这个方法了。


jsx转化包括两个部分。
编译时：把jsx语法编译成上面方法调用的语法，也就是语法转换，想到了什么？babel。

运行时：jsx方法或React.createElement方法的实现（包括dev、prod两个环境）


编译时由babel编译实现，目前社区已经实现了，所以我们来实现运行时，工作量包括：

实现jsx方法（jsx方法或React.createElement方法）
实现打包流程
实现调试打包结果的环境（验证打包结果是否正确）


# 实现jsx方法
packages/react/src/jsx.ts

包括：

jsx方法（prod环境）
jsxDEV方法（dev环境）（dev环境）（实际上在react的真实源码中，dev环境的jsx和生产环境的jsx是同的实现，dev环境的jsx可以做一些额外的检查和debug，目前我们没必要，先全部一致。）
React.createElement方法 (在导出时直接指向jsx方法)

## jsx jsxDEV createElement异同，注意点
在源码中jsx的key属性是第三个传参，但实现createElement时是从config参数中获取。造成这些区别的原因如下：

在测试用例（后续会实现）中使用的是createElement，在打包后代码中使用的是jsx。虽然这两者最后都是生成ReactElement，但他们的传参是不同的。
jsx的参数如下：

对于开发环境，jsxDEV参数依次为type、props、key、source、self。其中后两者为开发环境用于调试的参数

对于生产环境，jsx参数依次为type、props、key

key作为一个单独的传参，为了体现了他的特殊性（与节点稳定相关），所以与其他props区分开。

createElement的参数依次为type、props、...children。其中children及后续其他传参经过转换都会作为children属性，比如：
```js
// 对于jsx：

<ul>
  <li>1</li>
</ul>

<ul>
  <li>1</li>
  <li>2</li>
</ul>

// 转换结果为：

React.createElement("ul", null, 
  React.createElement("li", null, "1")
);

React.createElement("ul", null, 
  React.createElement("li", null, "1"), 
  React.createElement("li", null, "2")
);
```

createElement与jsx之所以会有这些区别更详细的原因可以参考[createlement-rfc](https://github.com/reactjs/rfcs/blob/createlement-rfc/text/0000-create-element-changes.md#dev-only-transforms)

```jsx
function createElement(type, props, ...children){
// ...

return {
    type: '',
    props: {
    ...props,
    children
    }
}


}

```

# 实现打包流程

对应上述两3方法，打包对应文件：

react/jsx-dev-runtime.js（dev环境）

react/jsx-rumtime.js（prod环境）

React（就是正常使用时通过import from React使用的React包）

打包流程中需要安装的rollup plugin与node包：
```
pnpm i -D -w rimraf rollup-plugin-generate-package-json rollup-plugin-typescript2 @rollup/plugin-commonjs
```

rimraf:重新打包时删除dist用的（如果是mac可以直接加上rm -rf命令，这里为了多平台兼容就用rimraf）
rollup-plugin-generate-package-json(打包产物中生成package.json)
rollup-plugin-typescript2 将ts代码转化成js代码
@rollup/plugin-commonjs 用于解析commonjs规范的plugin，rollup原生支持ESM格式，所以对于CJS格式的包，我们需要先将它用该插件转为ESM格式

# 如何调试打包结果
第一种调试方式：
通过pnpm link或者npm link将本地的包链接到全局，然后在要使用的包中将对应要使用的库指向全局的已link 的库。

这种方式的优点：可以模拟实际项目引用React的情况
缺点：对于我们当前开发big-react来说，略显繁琐。对于开发过程，更期望的是热更新效果。



# 补充知识
## @rollup/plugin-commonjs插件的作用
rollup原生支持ESM格式，所以对于CJS格式的包，我们需要先将它用该插件转为ESM格式。

这里使用该插件是因为他是rollup中最常见的插件，加上有备无患。

## 执行pnpm link --global时报错
如果报如下错误：
ERROR  Unable to find the global bin directory

结局方案参考[解决pnpm 升级之后全局安装出现异常问题](https://juejin.cn/post/7147206776838946823)



# 简单的render函数

```
function render(vDom, container) { 
    let dom; 
    // 检查当前节点是⽂本还是对象
    if(typeof vDom !== 'object') { 
        dom = document.createTextNode(vDom) 
    } else { 
        dom = document.createElement(vDom.type); 
    } 

    // 将vDom 上除了 children 外的属性都挂载到真正的DOM 上去
    if(vDom.props) {
        Object.keys(vDom.props) 
        .filter(key => key != 'children') 
        .forEach(item => { 
         dom[item] = vDom.props[item]; 
        }) 
    } 
     
    // 如果还有⼦元素，递归调⽤
    if(vDom.props && vDom.props.children && vDom.props.children.length) { 
        vDom.props.children.forEach(child => render(child, dom)); 
    } 
     
    container.appendChild(dom); 
}
```

简单的实现了虚拟DOM渲染到⻚⾯上的代码，这部分⼯作被React官⽅称为 renderer.