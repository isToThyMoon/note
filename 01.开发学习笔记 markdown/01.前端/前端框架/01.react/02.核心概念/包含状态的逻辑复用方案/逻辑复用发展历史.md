react的发展进化有两条主线。

一条是践行函数式编程，不可变数据，UI=f(state)，从class组件转变到了hooks函数式组件。
一条是寻找开发中合理的逻辑复用方案。

这两条主线目前都走到了hooks函数组件这种开发模式。

# 逻辑复用
React 团队从一开始就很注重 React 的代码复用性

他们对代码复用性的解决方案历经：Mixin, HOC, Render Props，直到现在的 Custom Hook

所以 Custom Hook 并不是一拍脑门横空出世的产物，即使是很多对 Custom Hook 有丰富开发经验的开发者，也不了解 Hook 到底是怎么来的，以及在 React 里扮演什么角色。

不理解这段设计思路是无法深刻的理解 Custom Hook 的。

## 1. Mixin
官方已经不推荐使用 Mixins，因为它们会引入一些复杂性和不稳定性，并且在新的 React 版本中已经被移除。

优点：
1. 简单粗暴，符合直觉，也确实起到了重用代码的作用
缺点：
1. 它是隐式依赖，隐式依赖被认为在 React 中是不好的
2. 名字冲突问题
3. 只能在 `React.createClass`里工作，不支持 ES6 的 Class Component
4. 实践下来发现：难以维护

在 React 官网中已经被标记为 '不推荐使用'，官方吐槽点[这里](https://zh-hans.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html)

```jsx
var SetIntervalMixin = {
  componentWillMount: function() {
    this.intervals = [];
  },
  setInterval: function() {
    this.intervals.push(setInterval.apply(null, arguments));
  },
  componentWillUnmount: function() {
    this.intervals.forEach(clearInterval);
  }
};

var createReactClass = require('create-react-class');

var TickTock = createReactClass({
  mixins: [SetIntervalMixin], // 使用 mixin
  getInitialState: function() {
    return {seconds: 0};
  },
  componentDidMount: function() {
    this.setInterval(this.tick, 1000); // 调用 mixin 上的方法
  },
  tick: function() {
    this.setState({seconds: this.state.seconds + 1});
  },
  render: function() {
    return (
      <p>
        React has been running for {this.state.seconds} seconds.
      </p>
    );
  }
});

ReactDOM.render(
  <TickTock />,
  document.getElementById('example')
);
```

## 2. HOC（higher-order component）

2015 年开始，React 团队宣布不推荐使用 Mixin，推荐大家使用 HOC 模式

HOC 采用了 '装饰器模式' 来复用代码便于组件的复用。允许你在不修改现有组件代码的情况下，动态地添加功能或责任。

**在高阶组件中，你会创建一个函数，该函数接受一个组件并返回一个新的组件，类似于装饰器模式中的装饰器。**

HOC本身并不是React API，它就是一个写组件的方法。

HOC接收一个组件作为参数，并返回一个增强的组件。

将几个功能相似的组件里面的方法和react特性（如生命周期里面的副作用）提取到HOC中，然后向HOC传入需要封装的组件。最后将公用的方法传给组件。

组件是 React 中代码复用的基本单元。但你会发现某些模式并不适合传统组件。

```jsx
function withWindowWidth(BaseComponent) {
  class DerivedClass extends React.Component {
    state = {
      windowWidth: window.innerWidth,
    }

    onResize = () => {
      this.setState({
        windowWidth: window.innerWidth,
      })
    }

    componentDidMount() {
      window.addEventListener('resize', this.onResize)
    }

    componentWillUnmount() {
      window.removeEventListener('resize', this.onResize);
    }

    render() {
      return <BaseComponent {...this.props} {...this.state}/>
    }
  }
  return DerivedClass;
}

const MyComponent = (props) => {
  return <div>Window width is: {props.windowWidth}</div>
};

```
经典的 容器组件与展示组件分离 (separation of container presidential) 就是从这里开始的。

下面是最最经典的 HOC 容器组件与展示组件分离 案例 - Redux中的connect 的实例代码。

```jsx
export const createInfoScreen = (ChildComponent, fetchData, dataName) => {
  class HOComponent extends Component {
    state = { counter: 0 }
    handleIncrementCounter = () => {
       this.setState({ counter: this.state.counter + 1 });
    }
componentDidMount() {
      this.props.fetchData();
    }

    render() {
      const { data = {}, isFetching, error } = this.props[dataName]; 
      if (isFetching) {
        return (
          <div>Loading</div>
        );
      }

      if (error) {
        return (
          <div>Something is wrong. Please try again!</div>
        );
      }

      if (isEmpty(data)) {
        return (
          <div>No Data!</div>
        );
      }

      return (
        <ChildComponent 
          counter={this.state.counter}
          onIncrementCounterClick={this.handleIncrementCounter}
          {...this.props}
        />
      );
    }
  }

  const dataSelector = state => state[dataName];
  const getData = () => createSelector(dataSelector, data => data);
  const mapStateToProps = state => {
    const data = getData();
    return {
      [dataName]: data(state),
    };
  };

  HOComponent.propTypes = {
    fetchData: PropTypes.func.isRequired,
  };

  HOComponent.displayName = `createInfoScreen(${getDisplayName(HOComponent)})`;

  return connect(
    mapStateToProps,
    { fetchData },
  )(HOComponent);
};

```


优点：

1. 可以在任何组件包括 Class Component 中工作
2. 它所倡导的 容器组件与展示组件分离 原则做到了：关注点分离

缺点：

1. 不直观，难以阅读
2. 名字冲突
3. 组件层层层层层层嵌套



再看一个HOC派生出多个组件的例子。
例如：我们有个计时器和日志记录组件。

```js
class LogTimeComponent extends React.Component{
    constructor(props){
        super(props);
        this.state = {
            index: 0
        }
    }
    componentDidMount(){
        this.timer = setInterval(()=>{
            this.setState({
                index: ++index
            })
        },1000)
        console.log('组件渲染完成----')
    }
    componentDidUpdate(){
       // console.log(`我背更新了${++Welcome to this.show}`)
    }
    componentWillUnmount(){
        clearInterval(this.timer)
        console.log('组件即将卸载----')
    }
    render(){
        return(
            <div>
                <span>{`我已经显示了：${this.state.index}s`}</span>
            </div>
        )
    }
}

```

上面就实现了简单的日志和计时器组件。那么问题来了，假如有三个组件分别是LogComponent(需要记录日志)、SetTimeComponent(需要记录时间)、LogTimeShowComponent(日志和时间都需要记录)，怎么处理呢？把上面逻辑 Ctrl+C 然后 Ctrl+V 吗？如果记录日志的文案改变需要每个组件都修改么？官方给我们提供了高阶组件(HOC)的解决方案：

```js
function logTimeHOC(WrappedCompoent,options={time:true,log:true}){
    return class extends React.Component{
        constructor(props){
            super(props);
            this.state = {
                index: 0
            }
        }
        componentDidMount(){
            options.time&&this.timer = setInterval(()=>{
                this.setState({
                    index: ++index
                })
            },1000)
            options.log&&console.log('组件渲染完成----')
        }
        componentDidUpdate(){
           //ptions.log&&console.log(`我背更新了${++Welcome to this.show}`)
        }
        componentWillUnmount(){
            this.timer&&clearInterval(this.timer)
            options.log&&console.log('组件即将卸载----')
        }
        render(){
            return(<WrappedComponent {...this.state} {...this.props}/>)
        }
    }
}

```

logTimeHOC就是一个函数，接受一个组件返回一个新的组件（其实高阶组件就是一个函数）。我们用这个高阶组件来构建我们上面的三个组件：

LogComponent：打印日志组件

```js
class InnerLogComponent extends React.Component{
    render(){
        return(
            <div>我是打印日志组件</div>
        )
    }
}
// 使用高阶组件`logTimeHOC`包裹下 
export default logTimeHOC(InnerLogComponent,{log:true})

```

SetTimeComponent：计时组件

```js
class InnerSetTimeComponent extends React.Component{
    render(){
        return(
            <div>
                <div>我是计时组件</div>
                <span>{`我显示了${this.props.index}s`}</span>
            </div>
        )
    }
}
// 使用高阶组件`logTimeHOC`包裹下 
export default logTimeHOC(InnerSetTimeComponent,{time:true})

```

LogTimeShowComponent：计时+打印日志组件

```js
class InnerLogTimeShowComponent extends React.Component{
    render(){
        return(
            <div>
                <div>我是日志打印+计时组件</div>
            </div>
        )
    }
}
// 使用高阶组件`logTimeHOC`包裹下 
export default logTimeHOC(InnerLogTimeShowComponent)

```

这样不仅复用了业务逻辑提高了开发效率，同时还方便后期维护。当然上面的案例只是为了举例而写的案例，实际场景需要自己去合理抽取业务逻辑。高阶组件虽然很好用，但是也有一些自身的缺陷： 
高阶组件的props都是直接透传下来，无法确定子组件的props的来源。 
可能会出现props重复导致报错。 
组件的嵌套层级太深。 
会导致ref丢失。


## 3. Render Props
2017 年开始，Render Prop 流行了起来
Render Prop 采用了 '代理模式' 来复用代码

```jsx
class WindowWidth extends React.Component {
  propTypes = {
    children: PropTypes.func.isRequired
  }

  state = {
    windowWidth: window.innerWidth,
  }

  onResize = () => {
    this.setState({
      windowWidth: window.innerWidth,
    })
  }

  componentDidMount() {
    window.addEventListener('resize', this.onResize)
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.onResize);
  }

  render() {
    return this.props.children(this.state.windowWidth);
  }
}

const MyComponent = () => {
  return (
    <WindowWidth>
      {width => <div>Window width is: {width}</div>}
    </WindowWidth>
  )
}

```

React Router 也采用了这样的API设计：

```
<Route path = "/about" render= { (props) => <About {...props} />}>

```

优点：

1. 灵活

缺点：

1. 难以阅读，难以理解


组件也可以不是children里，直接通过props
传入。
https://zh-hans.reactjs.org/docs/render-props.html

**在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术**

具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。

```
<DataProvider render={data => (
  <h1>Hello {data.target}</h1>
)}/>
```

使用 render prop 的库有 React Router、Downshift 以及 Formik。

例子：
```js
class Cat extends React.Component {
  render() {
    const mouse = this.props.mouse;
    return (
      <img src="/cat.jpg" style={{ position: 'absolute', left: mouse.x, top: mouse.y }} />
    );
  }
}

class Mouse extends React.Component {
  constructor(props) {
    super(props);
    this.handleMouseMove = this.handleMouseMove.bind(this);
    this.state = { x: 0, y: 0 };
  }

  handleMouseMove(event) {
    this.setState({
      x: event.clientX,
      y: event.clientY
    });
  }

  render() {
    return (
      <div style={{ height: '100vh' }} onMouseMove={this.handleMouseMove}>

        {/*
          使用 `render`prop 动态决定要渲染的内容，
          而不是给出一个 <Mouse> 渲染结果的静态表示
        */}
        {this.props.render(this.state)}
      </div>
    );
  }
}

class MouseTracker extends React.Component {
  render() {
    return (
      <div>
        <h1>移动鼠标!</h1>
        <Mouse render={mouse => (
          <Cat mouse={mouse} />
        )}/>
      </div>
    );
  }
}
```

Cat组件通过render props使用了Mouse内部的state，但是无需在Mouse内部硬编码引入Cat组件。Mouse组件实现了复用。

这也是 render prop 的来历：相比于直接将 `<Cat>` 写死在 `<Mouse>` 组件中，并且有效地更改渲染的结果，我们可以为 <Mouse> 提供一个函数 prop 来动态的确定要渲染什么 —— 一个 render prop。


## 4. Hook ✅

2018 年，React 团队宣布推出一种全新的重用代码的方式 - React Hook（在此之前，请看recompose和hooks的渊源）

它的核心改变是：允许函数式组件存储自己的状态，在这之前函数式组件是不能有自己的状态的

这个改变使我们可以像抽象一个普通函数一样抽象React组件中的逻辑

实现的原理：闭包

```jsx
import { useState, useEffect } from "react";

const useWindowsWidth = () => {
  const [isScreenSmall, setIsScreenSmall] = useState(false);

  let checkScreenSize = () => {
    setIsScreenSmall(window.innerWidth < 600);
  };
  useEffect(() => {
    checkScreenSize();
    window.addEventListener("resize", checkScreenSize);

    return () => window.removeEventListener("resize", checkScreenSize);
  }, []);

  return isScreenSmall;
};

export default useWindowsWidth;

```

```
import React from 'react'
import useWindowWidth from './useWindowWidth.js'

const MyComponent = () => {
  const onSmallScreen = useWindowWidth();

  return (
    // Return some elements
  )
}

```

优点：

1. 提取逻辑出来非常容易
2. 非常易于组合
3. 可读性非常强
4. 没有名字冲突问题

缺点：

1. Hook有自身的用法限制: 只能在组件顶层使用，只能在组件中使用
2. 由于原理为闭包，所以极少数情况下会出现难以理解的问题


自定义Hook是目前最好的重用React逻辑的方法，它和普通的函数很像很像，自定义Hook的特殊之处在于，它是有状态的，它返回的也是状态。所以在什么时候我们应该用到自定义Hook？那就是，我们想要抽象出处理状态的逻辑的时候。

举一个例子

```jsx
const Comp = () => {
  const [arr, setArr] = useState([1, 2])
  return <button onClick={() => setArr([...arr, value])}>add</button>
}

```

如果你发现你的app里有好几处这种数组处理，你可以

```jsx
export const useArray = <T>(initialArray: T[]) => {
  const [value, setValue] = useState(initialArray);
  return {
    value,
    setValue,
    add: (item: T) => setValue([...value, item]),
    clear: () => setValue([]),
    removeIndex: (index: number) => {
      const copy = [...value];
      copy.splice(index, 1);
      setValue(copy);
    },
  };
};

```

用这样一个自定义的Hook，不仅返回了状态，也返回了处理这个状态的方法

这个例子也展示了，自定义Hook可以以状态为核心，并将它和与它相关的东西封装在一起。这也符合我们编程的seperation of concert，也就是关注点分离的原则。关注点分离是大家写代码时一定要注意的事情，也就是说无关的代码不要放在一起，不然关注点混在一起，会让维护难度大大加大。

有很多面条代码其实是可以用hook抽象出来的，再举个例子

```jsx
const Comp = () => {
  const [id, setId] = useState(0)
  const [assets, setAssets] = useState()

    useEffect(() => {
      fetch(`https://google.com?id=${id}`).then(async response => {
       const data = await response.json();
        if (response.ok) {
          setAssets(data)
        } else {
          return Promise.reject(data);
        }
        })
      }, [])

  return <div>{assets.map(a => a.name)}</div>
}

```

这里的fetch的内容和这个组件关系大吗？不大，因为这个组件其实不怎么在乎fetch的细节，它只在乎拿到result.data，那么我们就可以用hook来抽象

```jsx
// util.ts
const useAssets = (id) => {
    const [assets, setAssets] = useState()

    useEffect(() => {
      fetch(`https://google.com?id=${id}`).then(async response => {
       const data = await response.json();
        if (response.ok) {
          setAssets(data)
        } else {
          return Promise.reject(data);
        }
        })
      }, [])
    return assets
}

// comp.tsx
const Comp = () => {
  const [id, setId] = useState(0)
  const assets = useAssets(id)

  return <div>{assets.map(a => a.name)}</div>
}

```

这样就实现了逻辑的分离。



## one more：
以上的逻辑方案，确实一定程度实现了逻辑服用，但即使是自定义hook，也会牵涉到react相关的api

想实现更干净的分离，你需要考虑整洁架构，依赖倒置原则，适配器模式等的组合使用。

你明白我在说什么。
