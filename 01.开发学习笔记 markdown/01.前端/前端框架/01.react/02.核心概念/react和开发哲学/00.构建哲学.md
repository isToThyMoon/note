
# 怎么入手编写一个react前端项目
分解设计稿 划分组件或者层级
提取复用部分

将渲染 UI 和添加交互这两个过程分开。
这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。

组件化、组件拆分和合并、解耦和复用等等是组织代码绕不开的问题。
react其实已经要求通过组件化的方式初步为前端编写页面提供了一层代码分割的参考方式，但这远远不够。

可以看出官方react哲学介绍中，
**“到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。”**，
也是将数据模型和UI模型分离来帮你理解开发思想，

而react库，其实只是帮助你更好构建UI模型，并且从数据模型中声明式更新UI模型。

永远记得react对自己的定位，一个视图层library。
慢慢理解这一点，把UI层做薄。react其实只接管了之前需要我们通过命令式操作dom来完成页面UI修改的繁重工作。它提出一种新的前端页面开发思想，声明式组件化开发，以数据驱动UI变更，也就是UI = f(state)。

-------

# react哲学
react官方文档中核心概念最后单独一节，介绍[react哲学](https://zh-hans.reactjs.org/docs/thinking-in-react.html)。主要内容就是介绍如何组织react代码，和基础的组件化使用。

* 组件化的自上而下和自下而上。
* 数据模型（组件状态），状态的存放位置，状态提升，

## 自上而下和自下而上组件化
“你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写，当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。”

这两种都是组件化，

**“到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。”**

“通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 root.render()，UI 就会相应地被更新。数据模型变化、调用 render() 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React 单向数据流（也叫单向绑定）的思想使得组件模块化，易于快速开发。”

“在 React 中，有两类“模型”数据：props 和 state。清楚地理解两者的区别是十分重要的；如果你不太有把握，可以参阅 [React 官方文档](https://zh-hans.reactjs.org/docs/state-and-lifecycle.html)。你也可以查看 [FAQ: state 与 props 的区别是什么？](https://zh-hans.reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props)”

在构建了UI模型之后，“想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 state 来完成这个任务。” 需要开发者“确定 UI state 的最小（且完整）表示。”

“
通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
”

## 数据模型（组件状态）
“已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。”

“
注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，对初学者来说往往是最难理解的部分。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：

对于应用中的每一个 state：

找到根据这个 state 进行渲染的所有组件。
找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。
该共同所有者组件或者比它层级更高的组件应该拥有该 state。
如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。
”

总结来说就是单独属于该组件的state由该组件自身把持，和其他组件共用的state应该寻找他们的父级组件来掌控该state，如果找不到合适的位置，应该新建一个组件作为高于共有者层级的父级，也就是**状态提升**。

如此子组件需要修改state时就要考虑反向数据流，“React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。” 也就是子组件调用父组件传递来的可以修改state的回调函数。

如此结束。

-------
