---
title: 08.props和state
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
tags:
  - react项目
date:
---
# 组件

定义组件最简单的方式就是编写 JavaScript 函数：

```javascript 
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。

同时还可以使用 ES6 的 class 来定义组件，因为es6 class语法本质就是创建了一个构造函数。

这里接受唯一带有数据的props 返回一个React元素，就是所谓的纯函数，唯一的输入对应唯一的返回，没有副作用。

```javascript

import React from 'react';

//定义一个组件
//新建一个App类继承自React.Component 它就是一个React的组件了
class App extends React.Component {
  render() {
    return (
      //jsx语法
      <div>
      hello world
      </div>
    );
  }
}

export default App;
-----------------
// app.js 定义App组件   index.js作为入口 引用并渲染这些组件
-----------------
另一种写法：

import React, { Component } from 'react';  // 结构赋值

// import { Component } from 'react';
// //等价于
// import React from 'react';
// const Component = React.Component;
class App extends Component {
  render() {
    return (
      <div>
      hello world
      </div>
    );
  }
}

export default App;

```

# 受控与非受控组件
官方解释：
受控及非受控组件的边界划分取决于当前组件对于子组件值的变更是否拥有控制权。

在受控组件中, 数值的展示与变更则分别由组件的 state 与 setState 接管。
在非受控组件中, 通常业务调用方只需传入一个初始默认值便可使用该组件。数据的展示与变更都由 dom 自身接管。

## 完全受控组件
在 HTML 中，表单元素（如<input>、 <textarea> 和 <select>）通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新。

我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。

input：
`<input type="text" value={this.state.value} onChange={this.handleChange} />`

由于在表单元素上设置了 value 属性，因此显示的值将始终为 this.state.value，这使得 React 的 state 成为唯一数据源。由于 handlechange 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。

对于受控组件来说，输入的值始终由 React 的 state 驱动。你也可以将 value 传递给其他 UI 元素，或者通过其他事件处理函数重置，但这意味着你需要编写更多的代码。

textarea：
在 HTML 中, <textarea> 元素通过其子元素定义其文本:
```html
<textarea>
  你好， 这是在 text area 里的文本
</textarea>
```
而在 React 中，<textarea> 使用 value 属性代替。这样，可以使得使用 <textarea> 的表单和使用单行 input 的表单非常类似：
`<textarea value={this.state.value} onChange={this.handleChange} />`

select：
在 HTML 中，<select> 创建下拉列表标签。例如，如下 HTML 创建了水果相关的下拉列表：
```html
<select>
  <option value="grapefruit">葡萄柚</option>
  <option value="lime">酸橙</option>
  <option selected value="coconut">椰子</option>
  <option value="mango">芒果</option>
</select>
```

请注意，由于 selected 属性的缘故，椰子选项默认被选中。
React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它。
```js
<select value={this.state.value} onChange={this.handleChange}>
    <option value="grapefruit">葡萄柚</option>
    <option value="lime">酸橙</option>
    <option value="coconut">椰子</option>
    <option value="mango">芒果</option>
</select>
```
总的来说，这使得 <input type="text">, <textarea> 和 <select> 之类的标签都非常相似—它们都接受一个 value 属性，你可以使用它来实现受控组件。

### 受控输入空值
在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null。
`<input value={null} />`

下面的代码演示了这一点。（输入最初被锁定，但在短时间延迟后变为可编辑。）
```js
ReactDOM.createRoot(mountNode).render(<input value="hi" />);

setTimeout(function() {
  ReactDOM.createRoot(mountNode).render(<input value={null} />);
}, 1000);
```
### 受控组件的替代品
有时使用受控组件会很麻烦，因为你需要为数据变化的每种方式都编写事件处理函数，并通过一个 React 组件传递所有的输入 state。当你将之前的代码库转换为 React 或将 React 应用程序与非 React 库集成时，这可能会令人厌烦。在这些情况下，你可能希望使用非受控组件, 这是实现输入表单的另一种方式。

### 成熟的解决方案
如果你想寻找包含验证、追踪访问字段以及处理表单提交的完整解决方案，使用 Formik 是不错的选择。然而，它也是建立在受控组件和管理 state 的基础之上 —— 所以不要忽视学习它们。


## 非受控组件
在大多数情况下，我们推荐使用 受控组件 来处理表单数据。在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。

要编写一个非受控组件，而不是为每个状态更新都编写数据处理函数，你可以 使用 ref 来从 DOM 节点中获取表单数据。

例如，下面的代码使用非受控组件接受一个表单的值：
```js
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.input = React.createRef();
  }

  handleSubmit(event) {
    alert('A name was submitted: ' + this.input.current.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={this.input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```
因为非受控组件将真实数据储存在 DOM 节点中，所以在使用非受控组件时，有时候反而更容易同时集成 React 和非 React 代码。如果你不介意代码美观性，并且希望快速编写代码，使用非受控组件往往可以减少你的代码量。否则，你应该使用受控组件。

### 默认值defaultValue
在 React 渲染生命周期时，表单元素上的 value 将会覆盖 DOM 节点中的值。在非受控组件中，你经常希望 React 能赋予组件一个初始值，但是不去控制后续的更新。 在这种情况下, 你可以指定一个 defaultValue 属性，而不是 value。在一个组件已经挂载之后去更新 defaultValue 属性的值，不会造成 DOM 上值的任何更新。

```js
render() {
  return (
    <form onSubmit={this.handleSubmit}>
      <label>
        Name:
        <input
          defaultValue="Bob"
          type="text"
          ref={this.input} />
      </label>
      <input type="submit" value="Submit" />
    </form>
  );
}
```
同样，<input type="checkbox"> 和 <input type="radio"> 支持 defaultChecked，<select> 和 <textarea> 支持 defaultValue。

所以受控组件就不要使用defaultValue，通过给value设置的state赋给初始值实现组件默认值功能。

### 文件输入
在 HTML 中，`<input type="file">` 可以让用户选择一个或多个文件上传到服务器，或者通过使用 File API 进行操作。
在 React 中，`<input type="file" />` 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。

您应该使用 File API 与文件进行交互。下面的例子显示了如何创建一个 DOM 节点的 ref 从而在提交表单时获取文件的信息。

```js
class FileInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
    this.fileInput = React.createRef();
  }
  handleSubmit(event) {
    event.preventDefault();
    alert(
      `Selected file - ${this.fileInput.current.files[0].name}`
    );
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Upload file:
          <input type="file" ref={this.fileInput} />
        </label>
        <br />
        <button type="submit">Submit</button>
      </form>
    );
  }
}

const root = ReactDOM.createRoot(
  document.getElementById('root')
);
root.render(<FileInput />);
```


# State和Props

## state
state是组件自己管理数据，控制自己的状态，可变；
state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。
在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。

## props

React 元素也可以是用户自定义的组件：
`const element = <Welcome name="Sara" />;`
当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。

例如，这段代码会在页面上渲染 “Hello, Sara”：

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性(不可内部修改)，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

没有state的叫做无状态组件，有state的叫做有状态组件；
多用props，少用state。也就是多写无状态组件。


当组件的state或者props发生改变时render函数就会重新执行
当父组件的render函数被运行时 子组件的render都将被重新运行一次

### props类型和默认props
一个组件的propTypes 和 defaultProps:

父组件向子组件传值 子组件不知道传来的是props还是直接手写的内容 但是可以在子组件中校验。
子组件要确认传的值是固定类型 用propTypes作传值的强校验

``` javascript

import React, { Component } from 'react';
import PropTypes from 'prop-types';

class Todoitem extends Component {

	constructor(props) {
		super(props);
		this.handleClick = this.handleClick.bind(this);
	}

	render() {
		const { content } = this.props;
		return (
			<div onClick = {this.handleClick}>
				{content}
			</div>
		)
	}


	handleClick() {
		const { deleteItem, index } = this.props;
		deleteItem(index);

	}

}


Todoitem.propTypes = {
	content: PropTypes.string.isRequired,   //isRequired表示必须要传递
	deleteItem: PropTypes.func,
	index: PropTypes.number
}

TodoItem.defaultProps = {
  test: 'hello world',
}

export default Todoitem;

// defaultProps 表示如果没有接受到传递的值 给一个默认的值

```
事实上有了ts和hooks组件之后几乎没人这么写class组件了。

## props 和state区别？ 

都是用来保存信息的，用来控制组件的渲染输出，props是传递给组件的（类似于函数的形参），而state是在组件内部被组件自己管理的。

TL；DR：
If a Component needs to alter one of its attributes at some point in time, that attribute should be part of its state, otherwise it should just be a prop for that Component.

When a component needs to keep track of information between renderings the component itself can create, update, and use state.

props contains information set by the parent component (although defaults can be set) and should not be changed.state contains “private” information for the component to initialise, change, and use on it’s own.

Should this Component have state?

state is optional. Since state increases complexity and reduces predictability, a Component without state is preferable. Even though you clearly can't do without state in an interactive app, you should avoid having too many Stateful Components.

Stateless Component — Only props, no state. There's not much going on besides the render() function and all their logic revolves around the props they receive. This makes them very easy to follow (and test for that matter). We sometimes call these dumb-as-f*ck Components (which turns out to be the only way to misuse the F-word in the English language).

纯props提供数据模型，没有自身state的组件，react称之为无状态组件，官方是推崇这种组件的，易于跟踪数据流，测试用例编写简单，只要能写无状态组件，那一定是首选。

Stateful Component — Both props and state. We also call these state managers. They are in charge of client-server communication (XHR, web sockets, etc.), processing data and responding to user events. These sort of logistics should be encapsulated in a moderate number of Stateful Components, while all visualization and formatting logic should move downstream into as many Stateless Components as possible.

其实就是容器组件和UI组件的分别。
有状态的组件（容器组件）没有渲染，有渲染的组件（UI组件）没有状态。
展示组件+容器组件这样的实践一直都是社区提倡的最佳实践，这样的模式有几个好处：

更好的关注分离：
关注点分离是一个在编程中广泛使用的概念。它指的是执行不同操作的逻辑不应被分组或结合在一起。例如我们把获取数据和展示数据放在了同一个组件中就违反了关注点分离。

若要解决这个问题，并且遵循关注点分离，我们应该将两块（即：获取数据和在 UI 上展示）逻辑分开放置在不同的组件。

更好的复用性：
展示和容器分离能达到更好的复用性（HOC一直倡导的容器组件和UI组件分离），相同的展示组件可以同不同的状态组合在一起进一步转化成可复用的容器组件。也就是带状态的逻辑复用方案。

react hook自定义hook实现了对容器组件/UI组件分离方案的替代。

-------

为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 DRY: Don’t Repeat Yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。

通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

1.该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
2.该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
3.你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。


# JSX

在js文件中写html标签
render() return 里只能有一个大的整体标签  
可用fragment占位包裹return的内容 最后在html中不会显示fragment

``` JavaScript
<Content dangerouslySetInnerHTML = {{__html : this.props.content}}> 
// 不转义显示li标签内内容
```

Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。

以下两种示例代码完全等效：

```js
const element = (
  <h1 className="greeting">
    Hello, world!
  </h1>
);
const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
```

React.createElement() 会预先执行一些检查，以帮助你编写无错代码，但实际上它创建了一个这样的对象：
```js
// 注意：这是简化过的结构
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
```

这些对象被称为 “React 元素”。它们描述了你希望在屏幕上看到的内容。React 通过读取这些对象，然后使用它们来构建 DOM 以及保持随时更新。



# React事件机制
React基于浏览器的事件机制⾃身实现了⼀套事件机制，包括事件注册、事件的合成、事件冒泡、事件派发等。
当我们在组件上设置事件处理器时，React并不会在该DOM元素上直接绑定事件处理器，而是在React内部自定义一套事件系统，在这个系统上进行统一的事件订阅和分发。
React利用事件委托机制在document上统一监听DOM事件，再根据触发的target将事件分发到具体的组件实例，所以实际上我们在事件里面拿到的event其实并不是原始的DOM事件对象，而是一个合成事件对象。

## 合成事件 syntheticEvent
SyntheticEvent 实例将被传递给你的事件处理函数，它是浏览器的原生事件的跨浏览器包装器。除兼容所有浏览器外，它还拥有和浏览器原生事件相同的接口，包括 stopPropagation() 和 preventDefault()。

如果因为某些原因，当你需要使用浏览器的底层事件时，只需要使用 nativeEvent 属性来获取即可。合成事件与浏览器的原生事件不同，也不会直接映射到原生事件。例如，在 onMouseLeave 事件中 event.nativeEvent 将指向 mouseout 事件。每个 SyntheticEvent 对象都包含以下属性：

```js
boolean bubbles
boolean cancelable
DOMEventTarget currentTarget
boolean defaultPrevented
number eventPhase
boolean isTrusted
DOMEvent nativeEvent
void preventDefault()
boolean isDefaultPrevented()
void stopPropagation()
boolean isPropagationStopped()
void persist()
DOMEventTarget target
number timeStamp
string type
```

React定义一套事件体系的原因： 
* 抹平不同浏览器之间的兼容性差异。这最主要的动机。 
* 事件"合成"，即事件自定义。事件合成既可以处理兼容性问题，也可以用来自定义事件（例如 React 的 onChange 事件）。 
* 可以做更多优化。例如利用事件委托机制，几乎所有事件的触发都代理到了 document，而不是 DOM 节点本身，简化了 DOM 事件处理逻辑，减少了内存开销。（React 自身模拟了一套事件冒泡的机制）
* 提供一个抽象跨平台事件机制。类似 VirtualDOM 抽象了跨平台的渲染方式，合成事件（SyntheticEvent）提供一个抽象的跨平台事件机制。
* 可以干预事件的分发。V16引入 Fiber 架构，React 可以通过干预事件的分发以优化用户的交互体验。

## react事件体系中处理取消事件冒泡
因为采用事件委托机制由一个最顶层的dom统一处理所有事件，当不同版本的 React 组件嵌套使用时，e.stopPropagation()无法正常工作（两个不同版本的事件系统是独立的，都到document已经太晚了

不过在新版 ReactV17 及以后，不再将事件委托到 document 上，而是委托在渲染 React 应用的根 DOM 容器中，使用 rootNode.addEventListener() 监听事件动作去执行相关事件回调。

例如一次button click事件默认冒泡触发顺序是：
rootNode绑定监听器触发；
react事件体系处理合成事件，派发事件，具体dom button的绑定click事件回调触发；
react事件体系结束处理，往上冒泡，根DOM之上的绑定事件触发，如document绑定click事件；

 e.stopPropagation()在没有涉及到原生事件注册只有react事件时使用。用来阻止 React 模拟的事件冒泡，具体dom button绑定事件之后的父级监听事件、document监听事件都不会执行。
 
 react组件代码中绑定的DOM 事件冒泡到document（react17之后改为根组件）上才会触发React的合成事件，所以React 合成事件对象的e.stopPropagation，只能阻止 React 模拟的事件冒泡，并不能阻止真实的 DOM 事件冒泡。
 
e.nativeEvent.stopImmediatePropagation(); 原生事件对象的用于阻止 DOM 事件的进一步捕获或者冒泡，且该元素的后续绑定的相同事件类型的事件也被一并阻止。
e.nativeEvent.stopPropagation();  原生事件对象的用于阻止 DOM 事件的进一步捕获或者冒泡，但react根DOM上绑定的事件体系还是会执行。

从 v0.14 开始，事件处理器返回 false 时，不再阻止事件传递。你可以酌情手动调用 e.stopPropagation() 或 e.preventDefault() 作为替代方案。

## 事件池
17版本之前：react使用事件池管理事件，

Web 端的 React 17 不使用事件池。

SyntheticEvent 对象会被放入池中统一管理。这意味着 SyntheticEvent 对象可以被复用，当所有事件处理函数被调用之后，其所有属性都会被置空。例如，以下代码是无效的：
```js
function handleChange(e) {
  // This won't work because the event object gets reused.
  setTimeout(() => {
    console.log(e.target.value); // Too late!
  }, 100);
}
```
如果你需要在事件处理函数运行之后获取事件对象的属性，你需要调用 e.persist()：

```js
function handleChange(e) {
  // Prevents React from resetting its properties:
  e.persist();

  setTimeout(() => {
    console.log(e.target.value); // Works
  }, 100);
}
```

### 去除事件池
React 17 中移除了 “event pooling（事件池）“。它并不会提高现代浏览器的性能，甚至还会使经验丰富的开发者一头雾水：

function handleChange(e) {
  setData(data => ({
    ...data,
    // This crashes in React 16 and earlier:
    text: e.target.value
  }));
}
这是因为 React 在旧浏览器中重用了不同事件的事件对象，以提高性能，并将所有事件字段在它们之前设置为 null。在 React 16 及更早版本中，使用者必须调用 e.persist() 才能正确的使用该事件，或者正确读取需要的属性。

在 React 17 中，此代码可以按照预期效果执行。旧的事件池优化操作已被完成删除，因此，使用者可以在需要时读取事件字段。

这改变了行为，因此我们将其标记为重大更改，但在实践中我们没有看到它在 Facebook 上造成影响。（甚至还修复了一些错误！）请注意，e.persist() 在 React 事件对象中仍然可用，只是无效果罢了。


# 事件绑定
React 元素的事件处理和 DOM 元素的很相似，但是有一点语法上的不同:

React 事件的命名采用小驼峰式（camelCase），而不是纯小写。
使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。

例如，传统的 HTML：
```
<button onclick="activateLasers()">
  Activate Lasers
</button>
```
在 React 中略微不同：
```
<button onClick={activateLasers}>
  Activate Lasers
</button>
```

这里不能用`onClick={this.activateLasers()}` 为什么呢？

首先jsx语法中会把{}内当做js执行，这里this.activateLasers()会直接被执行，
其次，即使是`onClick={this.activateLasers}`也不行，因为js中this指向的问题，必须要bind（this）
否则用箭头函数直接解决问题，箭头函数在这属于匿名函数，在点击后执行，且箭头函数在创建时就绑定this到当前域中。

## bind(this)
```
constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // 为了在回调中使用 `this`，这个绑定是必不可少的
    this.handleClick = this.handleClick.bind(this);
}
```
你必须谨慎对待 JSX 回调函数中的 this，在 JavaScript 中，class 的方法默认不会绑定 this。如果你忘记绑定 this.handleClick 并把它传入了 onClick，当你调用这个函数的时候 this 的值为 undefined。

这并不是 React 特有的行为；这其实与 JavaScript 函数工作原理有关。通常情况下，如果你没有在方法后面添加 ()，例如 onClick={this.handleClick}，你应该为这个方法绑定 this。

## 两种除了在constructor中bind(this)的方法

### 实验性的 public class fields 语法
你可以使用 class fields 正确的绑定回调函数：
```js
class LoggingButton extends React.Component {
  // 此语法确保 `handleClick` 内的 `this` 已被绑定。
  // 注意: 这是 *实验性* 语法。
  handleClick = () => {
    console.log('this is:', this);
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        Click me
      </button>
    );
  }
}
```

### 回调中使用箭头函数：
```js
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    // jsx里{}内的内容当成js代码会立即执行 这里执行一个箭头函数定义 但并没有运行
    return (
      <button onClick={(e) => this.handleClick(e)}>
        Click me
      </button>
    );
  }
}
```

## 事件绑定示例

``` JavaScript

import React, { Component,Fragment } from 'react';

class Todolist extends Component {

// 构造方法 优先于类里的任何方法执行 
// 代码内容其实就是Todolist()这个构造函数的内容代码
	constructor(props){
		super(props);  //继承父类的构造方法执行一次
    	this.state = {
  		inputValue: '',
  		list: []
  	   }
	}

	render(){
		return (
			<Fragment>
			<div>
				<label htmlFor = "insertArea">输入内容</label> //label  作用是扩大点击范围 点击它聚焦到input标签   for换成htmlFor
				<input
					id = "insertArea"
					className = 'input'  //class 换成className 与‘类’冲突
					value = {this.state.inputValue}    //数据绑定
					onChange = {this.handleInputChange.bind(this)}  //事件监听 通过bind(this)改变handle函数的this作用指向
			   />
			<button>提交</button>
			</div>
			<ul>
				{
					this.state.list.map((item, index) => {
						return (
							<li
								key = {index}
								onClick = {this.handleItemDelete.bind(this, index)}
							>
							{item}
							</li>
						)
					})
				}
			</ul>
			</Fragment>
		)
  }


	handleInputChange(e){
		this.setState({
			inputValue: e.target.value    //改变组件里state的值 不能直接改变 要用setState
		})
		// this.state.inputValue = e.target.value;
	}


	handleBtnClick(){
			this.setState({
				list: [...this.state.list,this.state.inputValue],
				inputValue: ''
			})
	}


	handleItemDelete(index){
			// console.log(index)
			const list= [...this.state.list];     //改变state list里的数据 先拷贝一个副本 作修改 再用setState修改原state里的数据
			list.splice(index, 1);
			this.setState({
				list: list
			})
	}



}

export default Todolist;

```

好了，有了props state的状态概念，jsx作为页面UI框架结构的描述，事件绑定机制，你已经掌握90%react编码技能了。
剩下的就是一些细节api的熟练使用。
coding哲学、设计模式、算法让你的代码更优雅易读。

# 组件化 组件拆分和数据通信

## 组件拆分
还是拆分、封装的coding思维。只不过对于前端来说，一个重大的拆分项就是UI和业务逻辑的分离。

UI组件：负责页面的渲染
容器组件：负责页面的逻辑

无状态组件：
当一个组件内只有render函数时 就可以用无状态组件定义它
```js
const TodoListUI = (props) => {
      return (
        内容
      )
}
```

无状态组件来表示UI组件时，直接纯函数表达，在接收使用父组件传来的值和方法时，就不用写`value ={this.props.inputValue}`了。
直接写 `value = {props.inputValue}`

我的理解 它只是一个函数而已。

最理想情况UI组件当然是无状态组件纯函数最好，但这不代表UI组件就不能有状态只能是无状态组件，UI组件内有些UI相关的控制需要状态去保存非常正常，我们需要抽离的是UI无关的业务逻辑，放到容器组件中，或者到全局状态处理，或者单独的逻辑文件。

组件拆分自然而然就要考虑组件间的数据通信问题。

## 组件通信 

### 父传子：
通过props  属性 来传递数据


### 子传父：
利用回调函数：父组件使用props属性向子组件传递一个函数，子组件携带自己的数据并通过调用该函数向父组件传递数据
父组件调用子组件方法
ref获取整个子组件对象，可以调用子组件中的函数
```html
<div>
  <button onClick={() => {
      this.refs.mychild.handleEvent("父组件传来的");
  }}>子组件</button>
  <Child ref='mychild' />
</div>
```

### 爷孙、跨级、非嵌套组件间通信
1. 层层组件传递props 例如：A组件和B组件之间要通信，A先向C组件通信，C组件通过props和B组件通信，3层组件还能接受，再多层级的props传递代码就非常累赘不直观了。
2. 使用context：生产/消费者模式 context的问题也很多，具体可见状态管理相关内容。主要是数据流向不清晰，容易引起传递值混乱，context的实现也容易造成大量全app层级的rerender高开销。一般只用于app主题等全局配置的数据。
3. 其他的全局状态管理方案redux mobx jotai等等。
4. 自定义的事件机制，发布/订阅模式，通过向事件对象上添加监听器和触发器来实现组件间的通信，本质和context实现是差不多原理，context加上了数据修改后的租组件rerender。通过events、mitt等发布订阅库来实现。缺点是会增加子组件和父组件之间的耦合度，如果嵌套深的话，不易找到父组件。