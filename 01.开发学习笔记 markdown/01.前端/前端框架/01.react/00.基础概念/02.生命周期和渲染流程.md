---
title: 生命周期函数和axios
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
tags:
  - react项目
date:
---

# 生命周期函数 
是指在某一时刻组件会自动调用执行的函数

![截屏2021-03-12 下午12.37.36](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2021-03-12%20%E4%B8%8B%E5%8D%8812.37.36.png)

加上不常用周期：
![截屏2021-03-12 下午12.52.07](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2021-03-12%20%E4%B8%8B%E5%8D%8812.52.07.png)

具体可看官网介绍

## static getDerivedStateFromProps(nextProps, prevState)
一个特殊的static周期方法 取代旧api的一个修正方案。

一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数props和state，分别指接收到的新参数和当前的state对象，这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null
在调用render()方法前调用。该函数会在挂载时，接收到新的props，调用了setState和forceUpdate时被调用

这个方法就是为了取代之前的componentWillMount、componentWillReceiveProps和componentWillUpdate

## shouldcomponentUpdate
shouldcomponentUpdate解决重复渲染
我们知道， 当input输入框输入数据调用handleInputchange函数改变父组件state中inputValue的值 那么
父组件的render函数会重新执行 render里的子组件的也会重新渲染 子组件的render函数也会重新执行
这样子没输入一个值 父组件和子组件都重新渲染 带来性能损耗
怎么解决？
子组件生命周期函数
```JavaScript
shouldComponentUpdate(nextProps, nextState){
  if(nextProps.content !== this.props.content){
    return true;
  }else{
    return false;
  }
}
```

表示即将到来的渲染里 nextProps传来的content有没有变化？ 如果没有 则没有必要重新渲染

## getSnapshotBeforeUpdate
[getSnapshotBeforeUpdate](https://zh-hans.react.dev/reference/react/Component#getsnapshotbeforeupdate)取代了componentWillUpdate，触发时机为update发生的时候，在render之后、dom渲染dom改变之前，返回一个值，作为componentDidUpdate的第三个参数。

比如列表更新后新的数据不断插入到数据前面，如何保证可视区依旧是之前看到的呢？
```
getSnapshotBeforeUpdate(){
    return this.refs.wrapper.scrollHeight
}
    
componentDidUpdate(prevProps,prevState,preHeight){
    this.refs.wrapper.scrollTop+=this.refs.wrapper.scrollHeight-preHeight
}
.....
```
也就是说，在getSnapshotBeforeUpdate开始处于pre-commit阶段可以读取dom，但这里读的dom信息是未修改前的，在componentDidUpdate中可以使用dom，这里读到的dom是更新后的，但注意此时react并未让出js线程给渲染线程，所以屏幕此时还未变化，在componentDidUpdate中重新进行的state修改都不会发生页面闪烁。浏览器只能 paint 最后的 DOM 更变。

## componentDidMount
class时代一般ajax请求的书写位置
如果我想要在react中发送一个ajax请求 从远程服务器的api中请求一个list 把它渲染到页面上
在哪发ajax请求？
一般在生命周期函数的componentDidMount里发ajax请求  如果写在render里 会陷入重发渲染重复发请求的死循环
如果放在componentWillMount里 虽然没有问题 但是会和以后比较深的技术栈矛盾 引起不必要的问题 那么约定写在ComponentDidMount里

react内部便没有像jquery一样封装ajax请求
所以我们引入第三方库 yarn add axios 或者 npm install axios

```JavaScript
componentDidMount(){
			axios.get('/api/todolist')
			.then(() => {alert('succ')})
			.catch(() ={alert('error')})
}
```

### didmount中使用dom操作
已经遇到过很多次的问题，在didmount中直接使用dom操作，querySelector，必须将选择器书写完整，querySelector选择了一个元素后在用.chilren[]的常规方式是拿不到子元素的，显示undifined。

------- 

注意以上都是旧版的legacy模式同步更新方式下。

react后续启用了concurrent模式，fiber架构。

Concurrent 模式说白就是让组件更新异步化，切分时间片，渲染之前的调度、diff、更新都只在指定时间片进行，如果超时就暂停放到下个时间片进行，中途给浏览器一个喘息的时间。

浏览器是单线程，它将 GUI 描绘，时间器处理，事件处理，JS 执行，远程资源加载统统放在一起。当做某件事，只有将它做完才能做下一件事。如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化，一些 DOM 操作，内部也会对 reflow 进行处理。reflow 是一个性能黑洞，很可能让页面的大多数元素进行重新布局。

浏览器的运作流程: 渲染 -> tasks -> 渲染 -> tasks -> 渲染 -> ....

这些 tasks 中有些我们可控，有些不可控，比如 setTimeout 什么时候执行不好说，它总是不准时；资源加载时间不可控。但一些JS我们可以控制，让它们分派执行，tasks的时长不宜过长，这样浏览器就有时间优化 JS 代码与修正 reflow ！

总结一句，就是让浏览器休息好，浏览器就能跑得更快。

## 哪三个钩子在react16.4之后删除（可能react17正式删掉了）为什么
三个钩子在react17删除
```
componentWillMount

componentWillReceiveProps
componentWillUpdate
```

(1)componentWillMount在SSR中这个方法会被多次调用，会导致重复触发多次，同时若在这个方法内绑定事件将无法解绑，会造成内存泄露，这个方法变得不够安全高效而逐步被放弃。
(2)componentWillReceiveProps外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求。
(3)componentWillupdate,更新前记录DOM状态，可能会做一些处理，与componentDidUpdate相隔时间如果过长会导致状态不可信。

使用getDerivedStateFromProps代替了旧的componentWillMount和componentWillReceiveProps。
使用getSnapshotBeforeUpdate代替了旧的componentWillUpdate

因为fiber架构的可中断，使得他们出现问题

什么是fiber架构，react 虚拟dom结构由树结构变成了链表结构 才是可中断的关键

使用getDerivedStateFromProps(nextProps, prevState)的原因：
旧的React中componentWillReceiveProps方法是用来判断前后两个 props 是否相同，如果不同，则将新的 props 更新到相应的 state 上去。在这个过程中我们实际上是可以访问到当前props的，这样我们可能会对 this.props做一些奇奇怪怪的操作，很可能会破坏 state 数据的单一数据源，导致组件状态变得不可预 测。
而在 getDerivedStateFromProps 中禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当 前的 props 来更新组件的 state，而不是去访问this.props并做其他一些让组件自身状态变得更加不可预测 的事情。

使用getSnapshotBeforeUpdate(prevProps, prevState)的原因： 
在 React 开启异步渲染模式后，在执行函数时读到的 DOM 元素状态并不总是渲染时相同，这就导致在 componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的 值很有可能已经失效了。
而getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读 取到的 DOM 元素状态是可以保证与componentDidUpdate 中一致的。

-------

# 渲染流程

## class组件正常执行流程：
理解本节内容，需要同时深度理解  浏览器相关 - 线程 引擎 - 浏览器组件 js异步并发模型

具体组件执行流程可看react源码更新过程。

### 挂载：
当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：
constructor
static getDreivedStateFromProps()（新增）
#componentWillMount(废弃)
render
componentDidMount

### 更新
当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：
static getDreivedStateFromProps()（新增）
shouldComponentUpdate
render
getSnapshotBeforeUpdate
componentDidUpdate

### 卸载
当组件从 DOM 中移除时会调用如下方法：
componentWillUnMount

注意周期里各函数执行时机的一个重点：
1. render函数并不做实际的渲染动作，他只是返回一个JSX描述的结构（ReactElement）。
2. render函数被调用完之后，componentDidMount函数并不是会被立刻调用。componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，这里的渲染指组件已经被js引擎『装载』到了DOM树上，但是渲染引擎还没有执行，页面没有完成真实渲染，js引擎并没有让出锁。

## 渲染

渲染 是个复合且笼统的过程，可以简单理解为 layout 和 paint 两个过程。layout 是计算出 renderObject（浏览器中表示渲染元素的对象，大体上和 DOM 节点是对应的）的几何尺寸和位置；paint 则是将 renderObject 绘制为位图用于显示，这个过程一般需要 GPU 的参与。

class组件的render方法并不会去真正的操作DOM，它的作用是把需要的东西返回回来（jsx）。

setState状态改变，重新执行组件树，即重新运行关联组件的应用代码，
reconciler构建新的VDOM或者fiber树，diff比对前后fiber树变化，打上变更tag，
renderer按tag更新真实的dom，完成状态到UI到自动更新。

真正渲染的工作，是挂载阶段的ReactDOM.render方法去操作（在web环境，renderer就是ReactDOM）。

### 组件重渲染
之前基础架构层面概念讲完，那么组件何时会触发了渲染？

组件收到新的props。
自生维护状态state被更新。
上下文的值被更新（如果该组件使用useContext监听上下文的变化）。

父组件由于上述任何原因而更新。

### 一个例子说明渲染逻辑：
```ts
function TickerComponent = ()=>{
    const [ticker, setTicker] = useState("AAPL");
    ...
    const onChange = event => {
       setTicker(event.target.value);
    }
...
}
```

useState语句返回一个状态值（‘ticker’）和一个更新相应状态值的setter函数（‘setTicker’）。

当组件第一次被渲染时，‘ticker’值将是参数中指定的默认值（即’AAPL’）。

当一个新的ticker在下拉菜单中被选中时，onChange函数会被调用。这个函数使用setter函数更新状态值。 这个状态的变化触发了重新渲染 --再次调用TickerComponent函数来执行。但这次 "useState(‘AAPL’) "返回之前由setter函数设置的ticker值。这就像React将状态存储在一个与我们组件实例相联系的隐藏的数据存储器中。最新的状态值被保留下来，并在重读时返回。如果该组件被卸载并重新挂载，那么一切都会重新开始。






