
# composition出现背景

vue3出现了composition API解决关注点分离的问题，这个问题其实react已经先用hook尝试解决。之前无论是react还是vue2，当组件变得复杂庞大后，相关的逻辑会散落在组件的各个生命周期之中，难以维护。vue2中，当我们在template里看到一个属性，我们要在methods里看相关处理方法，然后往上看data里具体这个属性的定义，代码比较跳跃，当代码量很大时心智负担加重，出现问题难以定位。

Composition api可以说受hook启发，完全靠拢了react hook的思想，但vue实用为主的特质没有react hook那么追求开发哲学，避免了一些hook的问题，比如hook的地狱effect依赖。

在setup函数中，composition api提供了对之前option配置方式创建实例的等价表达，如data method computed watch等等。

# 特点

使用 Vue 2 的写法，代码逻辑是分散的，因为它们必须被分散到 data、methods、computed、watch 等地方。而使用 Composition API 时，则可以将相同的代码提取到一起，然后引入使用即可。

1.对 TypeScript 类型推导友好，编程体验较好 之前vue2对ts支持是很差的，随着ts的流行，vue势必要重写，迎合趋势。
2.提供了类似 React Hooks 的复用机制，从而可以在不引入新的组件的情况下，将组件内部的代码再次合理进行抽取，即在组件内部又提供了一种组织代码的方法

setup执行时机在beforeCreate之前，可以理解这时实例刚开始初始化，
执行 setup 时，你只能访问以下 property：
props
attrs
slots
emit
换句话说，你将无法访问以下组件选项：
data
computed
methods
refs (模板 ref)

所以setup中不能使用data methods，为了避免错误使用他们，框架直接将setup函数中的this修改为undefined。

在 setup() 内部，this 不是该活跃实例的引用，因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它option api中的 this 完全不同。这使得 setup() 在和其它选项式 API 一起使用时可能会导致混淆。使用了setup就不要使用vue2中的选项式api。

setup中只能执行同步代码。

setup 选项是一个接收 props 和 context 的函数，我们将在之后进行讨论。此外，我们将 setup 返回的所有内容都暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。


# setup函数
composition API最核心的是setup()函数。

setup是created之前，实例被完全初始化之前调用的函数。
组件创建之前，props被解析之后执行，是组合式 API 的入口。

所以setup里根本不能使用this这样的值，因为还未完成初始化，在methods里定义的函数也是完全不能在setup里使用的。 所以Vue为了避免我们错误的使用, 它直接将setup函数中this修改成了undefined。
setup()函数后来一样被挂载到了this.$options
setup函数只能是同步的不能是异步的

setup函数返回的对象里的值会完全暴露给template，可以直接使用。

如果返回一个()=> h()会直接渲染h()内容 （h()创建虚拟dom）

```js
const app = Vue.createApp({
    template: `
        <div @click="handleClick">{{name}}</div>
    `,

    setup(props, context){
        return {
            name: 'dadada',
            handleClick: ()=>{
                alert(121)
            }
        }
    }
});

app.mount("#root")
```

## context
context有三个键值对
const { attrs, slots, emit } = context;

attrs 是父组件调用子组件时向下传来的None-props属性

slots 父组件传来的插槽

emit：
之前我们通过this.$emit('change')向外传递事件 父组件可以监听事件然后处理传递来的值。

现在我们可以通过在setup函数内定义函数，然后emit('change')实现同样功能。

```js
const app = Vue.createApp({
    methods: {
        handleChange(){
            alert("change")
        }
    }
    template: `
        <child @change="handleChange">parent</child>
    `,
    });
    
app.component({
    template: `
        <div @click="handleClick">123</div>
    `,
    
    setup(props, context){
        const { attrs, slots, emit } = context;
        function handleClick() {
            emit('change')
        }
        return { handleClick }
    }
})
app.mount("#root")
```

setup函数里 一般就是通过调用函数展示代码执行的一个流程
我们一般不在setup函数里写过长的逻辑处理函数

在外部写逻辑函数 然后在setup函数内进行流程调用