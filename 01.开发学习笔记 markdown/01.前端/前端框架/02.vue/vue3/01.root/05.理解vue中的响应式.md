

对vue来说，双向数据绑定的响应式数据一直是vue引以为豪的开发便利。
在vue2中响应式数据是通过es5中的getter/setter来实现的，这套响应式数据机制受制于语言设计，有一些不能完全覆盖到数据变更的地方，例如当动态向对象上添加key，或者通过下标的方式修改数组，就不能出发数据变更的检测机制。

getter/setter是两个很特殊的方法，对应对象/类实例的一个成员，这个方法并不会被从外部直接调用，而是在对应的成员被访问的时候才会被调用。例如：

```js
var obj = {};

Object.defineProperty(obj, 'foo', {
    _value: 'bar',
    get(){
        return this._value;
    }
    set(value){
        this._value = value;
    }
});
```

当我们访问obj.foo时，get()方法会被调用，因此obj.foo的值就是get()方法的返回值。同理当obj.foo被赋值的时候，set()方法会被调用。

利用这个机制，开发者就很容易知道某个数据正在被赋值，从而获得更新界面的机会。

Vue 就是利用这个机制来实现数据变更的监测的。因此当我们使用 Vue 的时候，只需要重新给某个对象的属性重新赋值，Vue 就会自动帮开发者更新界面，而不需要开发者手工调用任何界面更新的代码。

# Proxy
vue3中响应式数据使用了一个完全不同的机制---Proxy。

Proxy 可以为任何一个对象设置一个代理对象，并在代理对象中设置一些自定义的逻辑。Vue 3 使用这个机制来监测数据变更：首先针对需要监听的数据对象设置一个代理对象，在代理对象中拦截对数据赋值的操作，从而获知数据变化：

```js
const dataObj = {};

const dataProxy = new Proxy(dataObj, {
    set(target, key, value){
        // 进行对应界面的更新
        Reflact.set(target, key, value);
    }
});
```
值得注意的是，因为只有在 ES6 的环境中才可以使用 Proxy，且这个特性无法通过编译到 ES5 的方式进行降级，所以目前兼容性相对来说比较差，这也是 Vue 3 不支持 IE 浏览器的主要原因。