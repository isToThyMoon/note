---
title: 06.组件传值总结
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 04.vue
---

# 父子组件

## 父传子（props）
在Vue中，父组件向子组件传值，都是通过子组件标签的attribute的形式。通过v-bind指令可以动态传值。

在模板里父组件内部的调用子组件的标签上，利用属性写成v-bind:content="content"
把父组件的content值传递给子组件，子组件定义时设置了props来接受父组件传来的值。子组件定义内部就可以直接使用父组件传递过来的值了。

注意createApp().component()这样的写法不能直接在vue/cli项目里直接写，因为语法限制要用单文件组件。这里只是简便说明传值的逻辑。

注意html中的attribute不支持大写 所以自定义attribute最好是短横线写法 kebab-case

```js
const app = createApp({
    data(){
        return{
            content: 'dadada'
        }
    },

    template: `
        <div><test v-bind:content="content" dididi="dididi" /></div>
    `
});

app.component('test', {
    props: ['content', 'dididi'],
    template: `
        <div>{{content}} {{dididi}}</div>
    `
});
app.mount('#root');
```

## 子传父 （通过父组件监听自定义事件 子组件$emit触发传递）

那么如何从子组件向父组件传值呢？

子组件可以使用 $emit 触发父组件的自定义事件。

我们以一个实际需求为例子，todolist这个小demo中，我们要实现点击todoitem的dom就删除这个item，而我们的todoitem是根据存储在父组件vue实例里的todoList这个数组来循环渲染的。这就是子传父。

修改Todolist项目的demo代码：

子组件的通过onclick事件向外层$emit出一个delete事件 （向上一层触发事件）

父组件监听delete事件后触发处理函数

```html
<body>

    <div id="app">
        <input type="text" v-model="inputValue" />
        <button v-on:click="handleSubmit">提交</button>
        <ul>
            <todo-item 
                    :content="item" 
                    :index="index" 
                    v-for="(item, index) in todoList"
                    @delete="handleItemDelete"
                      >
            </todo-item>
        </ul>
    </div>

    <script src="vue.js"></script>

    <script>
		Vue.component("todo-item", {
            props: ['content', 'index'],
		   template: "<li @click='handleItemClick'>{{content}}</li>",
            methods: {
                handleItemClick: function(){
                    this.$emit('delete', this.index)
                }
            }
		});

		var app = new Vue({
			el: '#app',
			data: {
				inputValue: '',
				todoList:['去上课', '去吃饭']
			},

			methods: {
				handleSubmit: function(){
                    this.todoList.push(this.inputValue);
                    console.log(this.inputValue)
					this.inputValue = '';
				},
                  handleItemDelete: function(index){
                      this.todoList.splice(index, 1)
                  }
                 
			}
		})
    </script>
</body>
```

## ref 
vue中获取dom的方式 也适用 父子组件通信

ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例

`$parent / $children`：访问父/子实例，调用父/子组件方法



# 爷孙、跨级、非嵌套组件间通信
非父子组件我们可以采用事件触发层层传递方式传值。但略显复杂。层级一多要理清这些复杂的数据传递是不现实的。

vue和react不一样，vue是轻量的视图层框架。我们可以使用vue官方提供的数据层框架vuex来解决这个问题。（对标react生态里的redux）



## 总线模式
还有一种方式是发布 订阅模式（观察者模式）。vue称之为总线模式EventBus。
`（$emit / $on）`适用于 父子、隔代、兄弟组件通信

通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。

另外vue3中有mitt库，轻量强大的发布订阅库。react中也可以使用，可以不通过新建Vue实例来实现，不用把什么都挂载到vue实例上。

```html
    <div id="root">
        <child content="dadada"></child>
        <child content="dididi"></child>
    </div>

    <script src="https://cdn.bootcss.com/vue/2.5.13/vue.min.js"></script>
    
    <script>
        Vue.prototype.bus = new Vue()

        Vue.component('child', {
            props: {
                content: String
            },

            data: function(){
                return {
                    selfContent: this._props.content
                }
            },

            template: '<div @click="handleClick">{{selfContent}}</div>',

            methods: {
                handleClick: function() {
                    this.bus.$emit('change', this._data.selfContent)
                }
            },

            mounted: function(){
                var _this = this;
                this.bus.$on('change', function(msg) {
                    //注意这里on监听函数的内部this指向了bus这个新的vue对象。所以要在之前保存this
                    _this.selfContent = msg;
                })
            }
        })

        var VM = new Vue({
            el: '#root',
        }) 
    </script>
```

## attrs/listeners 适用于 跨级组件通信

`$attrs`：包含了父组件传递过来的所有非props属性。

可以通过 v-bind="$attrs" 传入内部组件。通常配合 inheritAttrs 选项一起使用。

`$listeners`：包含了作用在这个组件上的所有监听器(不含 .native 修饰器的) 

# provide / inject 适用于 跨级组件通信
祖先组件中通过 provider 来提供变量（拓展实例的属性），然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。

具体实例应用见vue自定义插件一章。

# Vuex 
适用于 父子、隔代、兄弟组件通信
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 (state)。
Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。

## 略解
Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。
（1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。
（2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。
主要包括以下几个模块：
State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。