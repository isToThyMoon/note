https://juejin.cn/post/7272270987256397876

# 服务端组件最佳实践

1.共享数据：
当在服务器上获取数据时，可能需要在不同的组件之间共享数据。与其使用 React Context（在服务器上不可用）或传递数据作为 props，不如使用 fetch 或 React 的 cache 函数在需要的组件中获取相同的数据，React 将对重复请求进行合并。


2.让服务端代码隔离于客户端组件之外：
要确保一些只应在服务器上运行的代码不会意外地进入客户端，可以使用**server-only**包。
`npm install server-only`

```jsx
import 'server-only'
 
export async function getData() {
  const res = await fetch('<https://external-service.com/data>', {
    headers: {
      authorization: process.env.API_KEY,
    },
  })
 
  return res.json()
}
```

使用了server-only包的组件，将只允许服务端代码调用，如果客户端代码调用则会报错。
相应的，还有一个client-only包，可以用来标记仅包含客户端代码的模块。

3.使用第三方包
由于服务端组件是一个新的 React 功能，许多 npm 包可能还没有添加use client指令。如果一个第三方组件在服务端组件中不起作用，可以将其封装在你自己的客户端组件中来解决这个问题。
例如：
```
import { Carousel } from 'acme-carousel'
 
export default function Page() {
  return (
    <div>
      <p>View pictures</p>
 
      {/* Error: `useState` can not be used within Server Components */}
      <Carousel />
    </div>
  )
}
```

可以通过封装一层，客户端组件引入封装后的代码，就能解决掉报错：
```
'use client'
 
import { Carousel } from 'acme-carousel'
 
export default Carousel
```

```jsx
import Carousel from './carousel'
 
export default function Page() {
  return (
    <div>
      <p>View pictures</p>
 
      {/*  Works, since Carousel is a Client Component */}
      <Carousel />
    </div>
  )
}
```

4.使用Context Providers
通常，Context Providers 会在应用的根部渲染，以共享全局状态，如当前主题。
但是 Context Providers 在服务端组件里是不受支持的，例如：
```
// layout.tsx

import { createContext } from 'react'
 
//  createContext is not supported in Server Components
export const ThemeContext = createContext({})
 
export default function RootLayout({ children }) {
  return (
    <html>
      <body>
        <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
      </body>
    </html>
  )
}
```

要解决这个问题，就要在客户端组件中创建上下文并呈现其提供程序
```
// theme-provider.tsx

'use client'
 
import { createContext } from 'react'
 
export const ThemeContext = createContext({})
 
export default function ThemeProvider({ children }) {
  return <ThemeContext.Provider value="dark">{children}</ThemeContext.Provider>
}
```

现在引入服务端组件就不会报错了
```
// layout.tsx

import ThemeProvider from './theme-provider'
 
export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html>
      <body>
        <ThemeProvider>{children}</ThemeProvider>
      </body>
    </html>
  )
}
```

看到这个例子就有疑问了，前面说了被"use client"声明的组件，会画一条分界线，把这个组件及其子组件都变成客户端组件，而这里ThemeProvider包裹了所有children，那不就变成所有页面都是客户端组件了吗？
其实不是，ThemeProvider在这里其实只是提供了一个插槽，只能决定子元素的位置，而不能决定子元素的渲染方式。



# 客户端组件最佳实践
1.向下移动客户端组件
为了减少客户端打包后的大小，客户端组件应当放在组件树的枝干（组件树从上到下，最上面是跟节点）。
例如，我们有一个<SearchBar />的组件，这个组件需要交互，所以只能是客户端组件。那么，如果要加快渲染速度，就可以把页面放在服务端渲染，而<SearchBar />作为客户端组件引入。
```
// SearchBar is a Client Component
import SearchBar from './searchbar'
// Logo is a Server Component
import Logo from './logo'
 
// Layout is a Server Component by default
export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <>
      <nav>
        <Logo />
        <SearchBar />
      </nav>
      <main>{children}</main>
    </>
  )
}
```

联系上文，我们可以知道，这样做的方式，会优先进行服务端组件渲染，而此时<SearchBar />的位置会是一个占位符，一旦开始混合渲染，占位符的位置会被真实的<SearchBar />填充。

2.server Component传递数据给Client Component
从服务器组件传递 props 到客户端组件（可序列化数据）。
考虑以下场景：你有一个服务器组件负责获取用户的信息，然后你希望将这些信息传递给一个客户端组件以展示一个交互式的用户资料卡。

在这种情境中，你需要：

在服务器组件中预获取用户数据。
将数据作为 props 传递给客户端组件。
为了使这个过程有效且无错误，从服务器组件传递给客户端组件的 props 必须是可序列化的。

基本的数据类型（如数字、字符串、数组和普通对象）通常都是可序列化的。但是，如函数、特定的对象实例（例如 Date 对象或自定义类的实例）或包含循环引用的对象可能不是。

怎么处理不可序列化的数据？

如果客户端组件依赖于不可序列化的数据，你有几个选项：

客户端获取：在客户端组件中直接获取数据，比如使用 AJAX 请求。
路由处理程序：在 NextJS 中，你可以使用 API 路由来在服务器上获取数据，并从客户端进行调用。


# 混合使用客户端和服务器组件
当你混合使用客户端和服务器组件时，应当将 UI 视为组件树。从根布局开始（它是一个服务器组件），你可以通过添加 "use client" 指令在客户端渲染某些子树。
虽然在这些客户端子树中仍然可以嵌套服务器组件或调用服务器操作，但仍有一些事情需要注意：

如果需要在客户端访问服务器上的数据或资源，客户端需要向服务器发出新的请求。
当向服务器发出新请求时，首先渲染所有服务器组件，在客户端上，React 会使用 RSC Payload 将服务器组件和客户端组件调和成一棵树。
由于客户端组件是在服务器组件之后呈现的，因此不能将服务器组件导入到客户端组件中。正确的方式应该是：将服务器组件作为属性传递给客户端组件（如：children），这种方式允许你在客户端组件中使用来自服务器组件的数据或内容，而不必再次请求服务器。

错误示例：

```jsx
'use client'
 
// You cannot import a Server Component into a Client Component.
import ServerComponent from './Server-Component'
 
export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)
 
  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
 
      <ServerComponent />
    </>
  )
}
```

正确示例：

```jsx
'use client'
 
import { useState } from 'react'
 
export default function ClientComponent({
  children,
}: {
  children: React.ReactNode
}) {
  const [count, setCount] = useState(0)
 
  return (
    <>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      {children}
    </>
  )
}
```

```jsx
// This pattern works:
// You can pass a Server Component as a child or prop of a
// Client Component.
import ClientComponent from './client-component'
import ServerComponent from './server-component'
 
// Pages in Next.js are Server Components by default
export default function Page() {
  return (
    <ClientComponent>
      <ServerComponent />
    </ClientComponent>
  )
}
```