---
title: 00.js历史和一些遗留问题
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - root
tags:
  - js
date:
---

JavaScript是一种运行在浏览器中的解释型的编程语言。
网页交互逻辑都是由JavaScript驱动的。
ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。
由于浏览器在发布时就确定了JavaScript的版本 所以就有兼容性的问题
可以在同一个页面中引入多个.js文件，还可以在页面中多次编写`<script> js代码... </script>`，浏览器按照顺序依次执行。
由于浏览器的安全限制，以file://开头的地址无法执行如联网等JavaScript代码，最终，你还是需要架设一个Web服务器，然后以http://开头的地址来正常执行所有JavaScript代码。

1995年 网景公司开发navigator浏览器 自带脚本功能 这个脚本就是JavaScript。
由js之父branden eich编写，他擅长 scheme 函数式编程。
所以当公司要求他写一个看起来像java的语言时（和sun公司同时推出Java 和JavaScript），他只是表面做到了。所以js有很多奇怪的语法和特性。
实现看起来实现了类似java的代码如：`var obj = new Object()`。
类似的JavaScript中有很多无用代码，根本没人用：
var a = new Number(1) 其实就是 var a = 1
var a = new Function('x','y','x+y')
这是历史遗留问题。

包括this关键字也是java里的内容。在java代码里非常重要。

在js发布后，charset:unicode的encoding:utf-8才发布。所以自带了一个字符bug。

96年ms开发了ie浏览器，写了一个JScript。

网景被ms市场打败，为了反击，网景开源了浏览器，做了firefox，由monzilla委员会维护浏览器。
为了抵制ms，网景向ECMA“欧洲计算机制造商协会”（并没有向w3c）申请制定web浏览器中的脚本标准。因为JavaScript商标已经被注册，所以这个标准采用ECMAscript这个名字。

1999年xmlHttpRequest首次在ie5.0中作为非标准的activeX组件出现，XML 是当时最流行（或被宣扬）的数据格式，微软推出它是为了支持基于web的outlook版本。
在2000年7月8日，ie5.5版本。 ms正式推出了js发请求的功能，xmlHttpRequest这个api。

2004年，开创性的一年，gmail利用这个功能开发实现了网页上的程序（除了gmail还有谷歌地图），可以收发请求。js正式成为了一门编程语言。

Jesse James Garrett 在他 2005 年的文章《AJAX: Web 应用程序的新方法》中提出了“AJAX”（Asynchronous JavaScript and XML）概念，那时谷歌邮箱和谷歌地图等基于 AJAX 的应用程序已经存在，但是这个术语激励了开发人员，并引起了流畅的 Web 2.0 体验爆炸式增长。

所有主流浏览器都支持 XMLHttpRequest，并在 2006 年成为官方（ecmascript）的 web 标准。

中国的互联网同行2010年左右才知道有前端这个细化的工作分类。


在申请了标准之后，发现js（es3）不行：
全局变量太多。（没有模块化）
标准库内容太少。（内置代码太少，功能函数太少。）

升级。2009升级到es5。只有15个很小的变化。（es5也泛指2015年以前发布的版本，2015年发布了es6版本）

但大多数人认为升级的步子太小。

rails社区（一帮写ruby的人，水平很高），开发了coffeeScript，js的改良版。
增加了类class、箭头函数、optional chain等语法。

```js
// 拓展 所谓optional chain 已经在2019年 chrome 79版本后试验性支持。
var obj = window.obj1
obj.a.b.c.name
// 存在一个问题，长链式调用，如果a b c name任意一个不存在，如obj.a=== undefined会直接返回报错。
//为了实现合理调用，我们要这个写：
if(obj.a !== undefined && obj.a.b != undefined && obj.a.b.c != undefined && obj.a.b.c.name !== undefined){
    console.log(obj.a.b.c.name)
}
// 这样写太复杂了 利用optional chain语法
console.log(obj?.a?.b?.c?.name)
// 确保不会报错，代码也十分简洁。

```

在试验可行，rails社区的改良被大部分开发者接受后，ECMA把这些特性吸纳，升级了ES5到ES6。

而后js约定每年一更，
es7 2个更新。2016年
es8 10个更新。2017年

但浏览器并不能实时支持这些新特性，所以出现了es next。
也就是利用webpack（其实是babel）等技术，把新语法代码转化为旧版本已支持语法。

js的一个奇怪之处在于，当前的互联网公司，还未发布的语法特性就已经被开发使用了。而很多已经发布标准的语言特性又可能暂时没有被主流浏览器所原生支持。
归根结底，js的运行是在浏览器之上的，chrome实现了一个新的语法，如果可以，将会被ECMA吸纳，如果其他浏览器暂时未实现，不支持，可以用babel转义，转化成已实现的语法在其他浏览器上使用。

# 关于浏览器内核
浏览器之所以能够工作，它的核心是一个叫做「内核」的东西，这个内核就类似于汽车的引擎，没有它浏览器是没法工作的，而市面上的内核有很多种，比如：KHTML、Presto、Trident、WebKit 等，大家熟知的浏览器如 Firefox、IE、Opera、Chrome、Safari 等所用的内核都不一样，而 Chrome 和 Safari 浏览器所用的内核是一样的，叫做「WebKit」，WebKit 其实是苹果基于开源的内核 KHTML 来改造的，也是开源的。


而内核其实又分为两部分：渲染引擎和 js 引擎。渲染引擎主要就是负责获取网页的 html、xml、图片、css 等内容进行渲染显示，js 引擎则负责解析 javascript 语言，实现网页的动态效果。


Chrome 虽然也是基于 WebKit 内核的，但是 Google 一开始觉得 WebKit 自带的 js 引擎性能上有问题，所以 Google 专门为 Chrome 搞了个 js 引擎叫做「V8」，所以在内核方面，Chrome 和 Safari 的主要区别就在于 js 引擎不一样







