---
title: 06.js闭包贯穿始终
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - root
---

# 闭包
如果一个函数内部使用了它函数作用域范围外的值，这样的语法结构是闭包。
 
1.内部函数使用外部函数的参数和变量；
2.内部函数被导出到全局，因为内部函数在全局可抵达，导致外部函数的上下文保留，参数和变量不会被垃圾回收机制回收。

闭包出现原因：
我们在编程时不想用全局变量，会造成污染和难以处理的bug。
我们要使用局部变量。

闭包的优点：
1.希望一个变量长期保存内存中；实现变量数据共享。
2.避免全局变量污染；
3.实现私有成员。读取函数内部的数据可被外部操作但不给直接访问。

闭包的缺点：
1.常驻内存，增加内存使用量；使用不当造成内存泄漏。
2.闭包会在父函数外部，改变父函数内部变量的值。

由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

其实无所谓优缺点，闭包的特性这一条决定了你要怎么用它。

#  用途场景
## 1.闭包往往是和立即执行函数一起使用的
我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。

es5里，只有函数有局部变量。
于是我们声明一个function xxx， 调用：xxx.call()
这个时候， xxx 是全局变量（全局函数）
所以我们不能给这个函数名字 用匿名函数。

可以使用立即执行函数(function(){}).call()

立即执行函数的语法：
function(){}.call()可能会报错
不报错：
1. ！function(){}.call() (我们不在乎匿名函数的返回值 所以加！取反没有关系)
2. (function(){}).call() 


```js
(function() {
    var person = {
        name: 'dadada',
        age: 18
    }
    
    window.dadadaGrowUp = function() {
        person.age += 1
        return person.age
    }
}).call()
```
1.立即执行函数使得person无法被外部访问
2.闭包使得匿名函数dadadaGrowUp可以操作person
3.window.dadadaGrowUp记录里匿名函数的地址
4.任何地方都可以使用window.dadadaGrowUp操作person。但不能直接访问person

再次封装：
```js
var accessor = function() {
    var person = {
        name: 'dadada',
        age: 18
    }
    
    return function() {
        person.age += 1
        return person.age
    }
}

var dadadaGrowUp = accessor.call()

dadadaGrowUp.call()
// 连续调用
```
## 2.结果缓存

# 一个闭包题：
```JavaScript
function Foo() {
    var i = 0;
    return function() {
        console.log(i++);
    }
}
 
var f1 = Foo(),
    f2 = Foo();
f1();
f1();
f2();
```
结果 0 1 0

这道题考察闭包和引用类型对象的知识点：
1.一般来说函数执行完后它的局部变量就会随着函数调用结束被销毁，但是此题Foo函数返回了一个匿名函数的引用（即一个闭包），它可以访问到Foo()被调用执行时产生的环境，而局部变量i一直处在这个环境中，只要这个环境有可能被访问到，它就不会被销毁，所以说闭包有延续变量作用域的功能。这就好理解为什么：
f1();//0
f1();//1
2.一开始认为f1和f2都=foo()是都指向了同一个function引用类型，所以顺理成章就会答错认为：
f2();//2
但其实foo()返回的是一个匿名函数，所以f1,f2相当于指向了两个不同的函数对象，所以结果也就顺理成章的变为：
f2();//0

Function是引用类型：保存在堆中，变量f1,f2是保存在栈中；

## 为什么闭包看似好像延续了作用域？
理由：
执行上下文的创建阶段，跟着被创建的还有作用域链！这个作用域链由在函数中以内部属性的形式存在的[[scope]]组成。在函数定义时，其对应的父变量对象就会被记录到这个内部属性[[scope]]里。闭包正是通过这一层作用域链的关系，实现了对父作用域执行上下文信息的保留。

详细解释下：
f1和f2是指向两块不同的堆内存。函数的内存空间，或者说创建的函数上下文应该在运行结束后就被销毁了。但这里的变量i，根据标记清除法的GC机制，它是一直可以被抵达的，所以这个变量的内存一直没有被释放。

注意到在执行上下文一章的内容，函数的生命周期有创建阶段和调用阶段，然后被GC回收。
在创建阶段（也就是定义阶段），return语句返回一个匿名函数时，这里这个匿名函数被定义，匿名函数的[[scope]]属性存储了外层的所有作用域链，这里i变量所在的作用域已经建立。
又因为i变量一直可达到，这块内存不会被释放。

在f1 和f2运行时，匿名函数进入激活阶段，创建执行上下文，将AO和[[scope]]组成完整作用域链，这就是变量的查找规则被完善了。

执行上下文进入执行阶段，内部i使用时顺着作用域链向外查找，这时候Foo的作用域下的i一直没被销毁，而且地址内存块被匿名函数通过[[scope]]保存了下来，自然而然地取i的值参与运算。

第二次调用i时同理，虽然又创建了一次函数上下文，但是作用域链仍然通过匿名函数创建时就静态保存的[[scope]]属性建立，仍然会找到这个未被销毁的变量i。


## 3.一个应用
很多框架例如jquery就是一个巨大的闭包。为了不污染全局变量会采用这样的操作。