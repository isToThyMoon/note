---
title: 04.js内存管理机制
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - root
---

js内存管理为什么会问？

内存管理常常紧跟在闭包之后，因为往往闭包会有内存泄漏的问题。

# JS 内存生命周期
内存管理是每一种编程语言都会具备的一种基本能力。

区别在于，一些语言会将这种能力开放 —— 比如 C 语言中的 malloc() 和 free() 方法 ，这些方法的暴露，使得开发者能够切身感受到内存管理这件事情的存在。

而在另一些语言 —— 比如 JS 中，这种能力是被 “隐藏” 了的：JS 并没有暴露任何内存操作给开发者，而是自己默默地自动完成了所有的管理动作。这是 JS 内存管理不被大多数同学所重视的原因。

JS 的内存生命周期，和大多数程序语言一样，分为三个阶段。

分配内存
内存读写
内存释放

# 栈内存与堆内存

JS 中的数据类型，整体上来说只有两类：基本类型和引用类型。

其中基本类型包括：Sting、Number、Boolean、null、undefined、Symbol。这类型的数据最明显的特征是大小固定、体积轻量、相对简单，它们被放在 JS 的栈内存里存储。

而排除掉基本类型，剩下的数据类型就是引用类型，比如 Object、Array、Function 等等等等。这类数据比较复杂、占用空间较大、且大小不定，它们被放在 JS 的堆内存里存储。

访问基本类型时，过程非常简单：从栈中直接获取该变量的值。

而在访问引用类型时，则需要分两步走：

从栈中获取变量对应对象的引用（即它在堆内存中的地址）
拿着获取到的地址，再去堆内存空间查询，才能拿到我们想要的数据

# 垃圾回收机制

前面讲完了内存的分配和使用，现在我们来看下内存的释放，也就是 “还坑” 这个动作。

每隔一段时间，JS 的垃圾收集器就会对变量做 “巡检”。当它判断一个变量不再被需要之后，它就会把这个变量所占用的内存空间给释放掉，这个过程叫做垃圾回收。

那么 JS 是如何知道一个变量是否不被需要的呢？ 这里就引出了内存管理的又一个考点 —— 垃圾回收算法。

在 JS 中，我们讨论的垃圾回收算法有两种 —— 引用计数法和标记清除法。

## 引用计数法
这是最初级的垃圾回收算法，它在现代浏览器里几乎已经被淘汰得干干净净，但是仍有一些面试官执着于询问该方法的思路、以便于判断你对 JS 的了解是否足够全面和深入。

在 JS 中，我们强调 “引用” 仅仅用来描述引用类型的内存地址。不过大家要是有一些 JAVA 基础，你会了解到，“引用” 这个概念，其实可以认为它描述的是变量所处那块内存的内存地址 —— 这里所说的 “变量” 是一个泛的概念，它泛指所有类型的变量，而不局限于某一种类型。在 “引用计数法” 中，“引用” 这个概念，其主语也正是 JS 环境中的所有实体。

当我们用一个变量指向了一个值，那么就创建了一个针对这个值的 “引用”。

**在引用计数法的机制下，内存中的每一个值都会对应一个引用计数。当垃圾收集器感知到某个值的引用计数为 0 时，就判断它 “没用” 了，随即这块内存就会被释放。**

### 引用计数的限制
```
function badCycle() {
  var cycleObj1 = {}
  var cycleObj2 = {}
  cycleObj1.target = cycleObj2
  cycleObj2.target = cycleObj1
}

badCycle()
```

我们知道函数作用域的生命非常短暂，当函数执行完之后，作用域内的变量也会全部被视作 “垃圾” 进而移除。

引用计数法无法甄别循环引用场景下的 “垃圾” 
如果两个变量互相引用，那么他们从引用计数来说将永远无法被清除。这就是内存泄露了。 

## 标记清除法
考虑到引用计数法存在严重的局限性，自 2012 年起，所有浏览器都使用了标记清除算法。可以说，标记清除法是现代浏览器的标准垃圾回收算法。

在标记清除算法中，一个变量是否被需要的判断标准，是它**是否可抵达**。

这个算法有两个阶段，分别是标记阶段和清除阶段：

**标记阶段**：垃圾收集器会先找到根对象，在浏览器里，根对象是 Window；在 Node 里，根对象是 Global。从根对象出发，垃圾收集器会扫描所有可以通过根对象触及的变量，这些对象会被标记为 “可抵达”。
**清除阶段**： 没有被标记为 “可抵达” 的变量，就会被认为是不需要的变量，这波变量会被清除。

自己当然不需要去实现这些方法，但是理解它们还是非常简单的。


# 内存泄漏
该释放的变量（内存垃圾）没有被释放，仍然霸占着原有的内存不松手，导致内存占用不断攀高，带来性能恶化、系统崩溃等一系列问题，这种现象就叫内存泄漏。

如果一个对象没有被引用，它就是垃圾，就会被回收。

内存泄漏：例如ie6中有个bug 如三个对象互相引用，外部没有变量引用它们，ie6 不认为这个垃圾，不会回收，内存一直堆积。
解决：都置为null即可。

## 经典闭包导致的内存泄漏：
先提前感受下闭包保留父级上下文的能力。

```js
function F(){
    let n = 1;
    
    function S(){
        alert(n)
    }
    
    return S //一定要return出去 
}

var Foo = F();
Foo();
```

原因就在于F是S的父函数，而S被赋给了一个全局变量，这导致S因为“可抵达”不会被GC，始终在内存中，而S的存在依赖于F，因此F的上下文开辟的内存也不会被回收，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing) // 'originalThing'的引用
      console.log("嘿嘿嘿");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log("哈哈哈");
    }
  };
};
setInterval(replaceThing, 1000);
```
unused 和someMethod共享作用域
someMethod在theThing定义的对象内，theThing变量定义在全局变量，一直可以到达，这导致这个someMethod闭包所在作用域不会被释放。
**因为共享作用域**，unused这个闭包和它引用住的originalThing都在此作用域内，不会被释放。
这导致从第二次起执行的orignalThing不断引用上一次赋值的theThing
第n+1次执行的originalThing都会引用第n次定义的theThing
这导致无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏


## 误写的全局变量

```js
function test() {
  me = 'xiuyan'
}
```
非严格模式下写代码时，me 而非 var me 这种写法，会导致这个 me 被默默地挂载到全局对象上。

根据我们前面所讲的垃圾回收策略，本来 me 这个变量，如果被 var 声明过，它作为函数作用域内的变量，在函数调用结束后就会消失 —— 这也是我们所期望的。但现在它是一个全局变量了，永远无法被清除。这样的变量一多，问题就来了。

## 忘记清除的 setInterval 和 setTimeout

## 清除不当的 DOM

```js
const myDiv = document.getElementById('myDiv')

function handleMyDiv() {
    // 一些与myDiv相关的逻辑
}

// 使用myDiv
handleMyDiv()

// 尝试”删除“ myDiv
document.body.removeChild(document.getElementById('myDiv'));
```

如果有变量再removechild之前对节点有了引用。
被移除的这个子节点在移除后仍然存在于内存中,只是没有添加到当前文档的DOM树中。如果在之前没有myDiv的引用，那么过一阵子GC会认为该节点无用了，才会回收内存。

那么myDiv这个变量对这个 DOM 的引用仍然存在，它仍然是一块 “可抵达” 的内存。这种你以为已经清除、但其实活得好好的 DOM 一旦堆积，将带来不可预期的内存隐患。


-------


# 内存概念
一切都运行在内存中：
操作系统无论是macos还是linux还是window都存在根目录下，（root/ usr/ bin/ opt/ 等等）
开机时主板通电，读取固件（固定写在主板内的存储设备，包含一些开机程序）
开机程序将文件系统内的操场系统加载到内存中运行。

操作系统（linux为例）：
首先加载操作系统内核
启动初始化进程，编号为1，每个进程都有编号，依次启动依次赋值。
启动系统服务：文件 安全 网络等等
等待用户登录：输入密码登录/ssh登录
登录后，运行shell程序，用户就可以和操作系统对话了。bash是一种shell，windows这种图形化界面其实也可以认为是一种shell，更适合大众使用。



打开浏览器：
运行了chrome.exe程序
开启chrome进程，作为主进程。
主进程开启一些辅助进程，如网络服务，GPU加速等
每新建一个页面tab，就会开启一个渲染进程。不同进程间是独立的。一个渲染进程会有很多线程，运行不同功能。
进程是车间，那么线程就是车间内的不同条流水线，完成不同功能。

浏览器输入网址，发起请求，下载html文件，解析HTML，下载css等资源文件，解析css，解析JS，执行JS，渲染绘制页面。

需要注意的是，渲染引擎线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。

线程作为系统资源调度的最小单位，拥有最小的粒度。js引擎、渲染引擎都处于单独的线程中，这是为什么js是单线程的原因。
js如果要修改页面的显示效果，它必须通过线程间的通信调用渲染引擎去做，这就是DOM操作，也是DOM操作耗费时间资源的原因。

浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生后被触发的时候，回调函数就从web api被压入事件队列（task queue）。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。


执行js代码前浏览器都发生了什么？
浏览器准备了window document setTimeout这些对象（web api）
执行代码

执行js代码发生了什么？
准备工作，提供API，window document setTimeout这些东西。
这些都不是js自身具备的功能。
我们将这些功能称为运行环境，runtime env
一旦js加载完成，就开始执行js。

js代码在哪里运行？
还是内存。

![IMG_3622](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2022-12-11%20%E4%B8%8B%E5%8D%8811.56.51.png)

电脑中包括os在内的大大小小程序瓜分你的内存条拓展的内存。
chrome当然也划分出一片内存使用。
chrome有一个主进程 主进程创建其他辅助进程和新开页面的单独渲染进程。

前端开发者主要关注每1个tab对应的1个渲染进程。
一个渲染进程中主要关注负责页面渲染的渲染线程和js线程。同进程中的线程可以跨线程通信。
js线程中的js引擎划分出一片内存使用。存储代码区，存储变量区，负责连续存储的stack区和负责链式存储的heap区。

这只是个简图，并不完成，还有调用栈、任务队列等区域。每种浏览器的分配规则也不太一样，我们不用过多关注。

主要关注存储数据的stack栈和heap堆。这里不存储变量名，变量名在单独的区域。

栈区每个数据顺序存放（基础类型），堆区每个数据随机存放（对象）。

这里的其实也不存在什么传值传址，=总会把右边东西复制到左边。视右边的类型。

6种基本类型变量存储在栈内存中，访问变量直接操作值。

引用类型变量的变量值保存在栈内存中，变量值就是一个指向对象的指针（地址），指向实际存储在堆内存的引用类型变量，通过其对应的变量名操作时：
1）如果是复制操作，就是复制指针值，类似于基本类型变量复制，但是对象没做变动，依旧存储在同一个堆内存。
2）如果是直接操作属性，应该就是针对对象直接操作。

引用类型如`let a = {}`
变量a存储在变量存储区 它指向栈内存一片区域，这里存储了引用类型{}所在堆内存的地址。访问变量a，先取到栈内存中的一串地址，然后指向堆内存中的实际对象数据。

注意每一个对象在堆中都有独立随机的存储空间 即使是对象中的对象 父对象中，属性变量存储子对象的地址 也就是引用

所以明白了在内存中的存储 你不用知道值和类型 =就是把右边赋给左边的变量 至于右边是什么，具体情况而定。
所谓区分值和类型，其实是不必要的。