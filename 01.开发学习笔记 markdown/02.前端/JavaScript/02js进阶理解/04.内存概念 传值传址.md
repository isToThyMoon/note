---
title: 07.js 浏览器内存分配和js引擎介绍、windows对象、传值传址
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - root
---

一切都运行在内存中：
操作系统无论是macos还是linux还是window都存在根目录下，（root/ usr/ bin/ opt/ 等等）
开机时主板通电，读取固件（固定写在主板内的存储设备，包含一些开机程序）
开机程序将文件系统内的操场系统加载到内存中运行。

操作系统（linux为例）：
首先加载操作系统内核
启动初始化进程，编号为1，每个进程都有编号，依次启动依次赋值。
启动系统服务：文件 安全 网络等等
等待用户登录：输入密码登录/ssh登录
登录后，运行shell程序，用户就可以和操作系统对话了。bash是一种shell，windows这种图形化界面其实也可以认为是一种shell，更适合大众使用。



打开浏览器：
运行了chrome.exe程序
开启chrome进程，作为主进程。
主进程开启一些辅助进程，如网络服务，GPU加速等
每新建一个页面tab，就会开启一个渲染进程。不同进程间是独立的。一个渲染进程会有很多线程，运行不同功能。
进程是车间，那么线程就是车间内的不同条流水线，完成不同功能。

浏览器输入网址，发起请求，下载html文件，解析HTML，下载css等资源文件，解析css，解析JS，执行JS，渲染绘制页面。

需要注意的是，渲染引擎线程和JS引擎线程是不能同时进行的。渲染线程在执行任务的时候，JS引擎线程会被挂起。因为JS可以操作DOM，若在渲染中JS处理了DOM，浏览器可能就不知所措了。

线程作为系统资源调度的最小单位，拥有最小的粒度。js引擎、渲染引擎都处于单独的线程中，这是为什么js是单线程的原因。
js如果要修改页面的显示效果，它必须通过线程间的通信调用渲染引擎去做，这就是DOM操作，也是DOM操作耗费时间资源的原因。

浏览器是事件驱动的（Event driven），浏览器中很多行为是异步（Asynchronized）的，例如：鼠标点击事件、窗口大小拖拉事件、定时器触发事件、XMLHttpRequest完成回调等。当一个异步事件发生后被触发的时候，回调函数就从web api被压入事件队列（task queue）。浏览器有一个内部大消息循环，Event Loop（事件循环），会轮询大的事件队列并处理事件。例如，浏览器当前正在忙于处理onclick事件，这时另外一个事件发生了（如：window onSize），这个异步事件就被放入事件队列等待处理，只有前面的处理完毕了，空闲了才会执行这个事件。setTimeout也是一样，当调用的时候，js引擎会启动定时器timer，大约xxms以后执行xxx，当定时器时间到，就把该事件放到主事件队列等待处理（浏览器不忙的时候才会真正执行）。


执行js代码前浏览器都发生了什么？
浏览器准备了window document setTimeout这些对象（web api）
执行代码

执行js代码发生了什么？
准备工作，提供API，window document setTimeout这些东西。
这些都不是js自身具备的功能。
我们将这些功能称为运行环境，runtime env
一旦js加载完成，就开始执行js。

js代码在哪里运行？
还是内存。

![IMG_3622](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2022-12-11%20%E4%B8%8B%E5%8D%8811.56.51.png)

电脑中包括os在内的大大小小程序瓜分你的内存条拓展的内存。
chrome当然也划分出一片内存使用。
chrome有一个主进程 主进程创建其他辅助进程和新开页面的单独渲染进程。

前端开发者主要关注每1个tab对应的1个渲染进程。
一个渲染进程中主要关注负责页面渲染的渲染线程和js线程。同进程中的线程可以跨线程通信。
js线程中的js引擎划分出一片内存使用。存储代码区，存储变量区，负责连续存储的stack区和负责链式存储的heap区。

这只是个简图，并不完成，还有调用栈、任务队列等区域。每种浏览器的分配规则也不太一样，我们不用过多关注。

主要关注存储数据的stack栈和heap堆。这里不存储变量名，变量名在单独的区域。

栈区每个数据顺序存放（基础类型），堆区每个数据随机存放（对象）。

这里的其实也不存在什么传值传址，=总会把右边东西复制到左边。视右边的类型。

6种基本类型变量存储在栈内存中，访问变量直接操作值。

引用类型变量的变量值保存在栈内存中，变量值就是一个指向对象的指针（地址），指向实际存储在堆内存的引用类型变量，通过其对应的变量名操作时：
1）如果是复制操作，就是复制指针值，类似于基本类型变量复制，但是对象没做变动，依旧存储在同一个堆内存。
2）如果是直接操作属性，应该就是针对对象直接操作。

引用类型如`let a = {}`
变量a存储在变量存储区 它指向栈内存一片区域，这里存储了引用类型{}所在堆内存的地址。访问变量a，先取到栈内存中的一串地址，然后指向堆内存中的实际对象数据。

注意每一个对象在堆中都有独立随机的存储空间 即使是对象中的对象 父对象中，属性变量存储子对象的地址 也就是引用

所以明白了在内存中的存储 你不用知道值和类型 =就是把右边赋给左边的变量 至于右边是什么，具体情况而定。
所谓区分值和类型，其实是不必要的。
