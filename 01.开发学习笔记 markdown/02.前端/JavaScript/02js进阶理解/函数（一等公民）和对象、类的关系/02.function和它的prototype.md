---
title: 02.js function函数和它的prototype
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 函数 对象 类
---

# js创建函数的几种方式

## 通过关键字function的创建方法
```javascript
function aaa(){
    
}
// 不可以省略function关键字 但是在 es6 object literal {} 中定义方法是可以省略关键字简写的,但是 函数 和 对象的方法 不是一个概念，不可混淆。这里只是补充提醒。
```

## 匿名函数创建法
```js
// 第一种其实是关键字来简写 原本应该是
var aaa = function() {
    
}
// 这其实是匿名函数 然后让变量aaa指向这个匿名函数

```

## 也可以利用Function对象创建：

```javascript
let func = new Function ([arg1, arg2, ...argN], functionBody);
//如:
let sum = new Function('a', 'b', 'return a + b');
//前面都是变量 最后是函数体 不同的是，他们都是字符串形式，这一特性在服务器端可以有一些骚操作，在接收到数据时直接构建相关函数 具体见https://javascript.info/new-function
```

## 箭头函数
新特性 语法糖 也可以匿名 不赋给变量
```js
var f = (x,y) => {
	  return x+y
}

```

# function本质
按之前所述，js中的function其实也是object（对象）。
但function和object的关系没有这么简单。

javascript中，所有函数都可以看成都是由Function()这个构造函数创建的对象。
而对象又只能由构造函数实例化出来。
函数和对象的关系在prototype里有详细的描述。

```
Object.__proto__ == Function.prototype
true
```

为什么需要prototype？ 为了所有实例能够继承同一份函数 且无需在内存创造多个同样的函数 浪费资源 

# 更进一步
JS是单继承的，Object.prototype是原型链的顶端，所有对象从它继承了包括toString等等方法和属性。

Object本身作为函数也是由构造函数Function创建，继承了Function.prototype; 
`Object.__proto__ === Function.prototype`

Function本身就是函数，它的原型链指向自己的prototype。
`Function.__proto__ === Function.prototype`

Function.prototype的原型链往上追溯到Object.prototype
`Function.prototype.__proto__ === Object.prototype`

而`Object.prototype.__proto__ === null`，
说明原型链到Object.prototype终止。所有对象均从Object.prototype继承属性。

这也是为什么Object和Function互相为对方的instance
从原型链查找，双方的__proto__都能找到自身的prototype

```JavaScript
Object instanceof Function // true
Function instanceof Object // true

Object instanceof Object // true
Function instanceof Object // true
```

## prototype （函数独有的属性）
有点容易混淆的是，函数独有一个属性叫prototype，只有函数拥有prototype属性，而所有的函数本质又是对象，所以函数也有[[prototype]]这个所有对象都有的隐藏属性，它的值是一个对象的引用（也就是地址）。

prototype的魔法是：
我们之前可以使用诸如 new F() 这样的构造函数来创建一个新对象。
如果这个构造函数的F.prototype 是一个对象，那么 new 操作符会使用它为新对象设置 [[Prototype]]。
这是原型链的完成。

注意：
*F.prototype 属性仅在 new F 被调用时使用，它为新对象的 [[Prototype]] 赋值。如果在创建之后，F.prototype 属性有了变化（F.prototype = <another object>），那么通过 new F 创建的新对象也将随之拥有新的对象作为 [[Prototype]]，但已经存在的对象将保持旧有的值。*

每个函数都有 "prototype" 属性，即使我们没有提供它。
默认的 "prototype" 是一个只有属性 constructor 的对象，属性 constructor 指向函数自身。`F.prototype = {constructor：F}`，所以我们可以通过访问它的 "constructor" 属性来获取一个对象的构造器

可以想象，当此构造函数F创建了一个对象A后，新对象A的[[prototype]]指向构造函数的prototype指向的对象，它的constructor属性指向构造函数本身。
那么当调用对象A的constructor属性时也就从原型链上查找，对象A继承了它构造函数的prototype指向对象的constructor属性。A.constructor == F
这里的含义就很清楚了，对象A的构造函数是F！

当我们有一个对象，但不知道它使用了哪个构造器（例如它来自第三方库），并且我们需要创建另一个类似的对象时，用这种方法就很方便。它相当于一个身份识别。
但是！JavaScript 自身并不能确保正确的 "constructor" 函数值。它存在于函数的默认 "prototype" 中，但仅此而已。之后会发生什么 —— 完全取决于我们。我们可以对它任意修改替换，甚至完全替换掉一个构造函数的prototype属性的指向。