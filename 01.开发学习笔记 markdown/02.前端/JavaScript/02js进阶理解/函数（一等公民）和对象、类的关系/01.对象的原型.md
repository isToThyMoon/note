---
title: 01.js object class
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 函数 对象 类
tags:
  - js
date:
---


# 原型继承、原型链和__proto__

在编程中，我们经常会想获取并扩展一些东西。
例如，我们有一个 user 对象及其属性和方法，并希望将 admin 和 guest 作为基于 user 稍加修改的变体。我们想重用 user 中的内容，而不是复制/重新实现它的方法，而只是在其至上构建一个新的对象。

原型继承（Prototypal inheritance） 这个语言特性能够帮助我们实现这一需求。

## [[Prototype]] 所有对象都有的隐藏属性
js的对象有一个隐藏属性[[prototype]]，要么为null，要么就是对另一个对象的引用（也就是存储另一个对象的地址），该对象就是子对象的“原型”。
当从object中读取一个缺失的属性时，js会顺着[[prototype]]引用，自下而上查找这个属性。在编程中，这种行为被称为“原型继承”。许多炫酷的语言特性和编程技巧都基于此。

[[prototype]]是内部属性且隐藏的，一种设置它的方式就是__proto__，它其实是[[prototype]]因为历史原因遗留下来的getter/setter。现代编程语言中使用Object.getPrototypeOf/Object.setPrototypeOf也能get/set原型。不过先这么理解。

有趣的是，this 根本不受原型的影响。无论在哪里找到方法：在一个对象还是在原型中。
在一个方法调用中，this 始终是点符号 . 前面的对象。谁调用函数，函数中的this就指向谁。

for..in 循环也在其自身和继承的属性上进行迭代。所有其他的键/值获取方法仅对对象本身起作用。

函数有一个prototype属性，用于通过构造函数创建对象时设置对象的原型。

## 设置原型[[Prototype]]的方法（补充）

 js的对象有一个隐藏属性[[prototype]]，通过__proto__操作它。
 
`__proto__` 被认为是过时且不推荐使用的（deprecated），这里的不推荐使用是指 JavaScript 规范中规定，proto 必须仅在浏览器环境下才能得到支持。
应该使用下面方法来代替 __proto__。
现代的方法有：

1.Object.create(proto, [descriptors]) ---- 利用给定的 proto 作为 [[Prototype]] 和可选的属性描述来创建一个空对象。

2.Object.getPrototypeOf(obj) ---- 返回对象 obj 的 [[Prototype]]。

3.Object.setPrototypeOf(obj, proto) ---- 将对象 obj 的 [[Prototype]] 设置为 proto。

### 原型简史
如果我们数一下有多少种处理 [[Prototype]] 的方式，答案是有很多！很多种方法做的都是同一件事儿！
为什么会出现这种情况？这是历史原因。

1.构造函数的 "prototype" 属性自古以来就起作用。

2.之后，在 2012 年，Object.create 出现在标准中。它提供了使用给定原型创建对象的能力。但没有提供 get/set 它的能力。因此，许多浏览器厂商实现了非标准的 __proto__访问器，该访问器允许用户随时 get/set 原型。

3.之后，在 2015 年，Object.setPrototypeOf 和 Object.getPrototypeOf 被加入到标准中，执行与__proto__相同的功能。由于__proto__实际上已经在所有地方都得到了实现，但它已过时，所以被加入到该标准的附件 B 中，即：在非浏览器环境下，它的支持是可选的。

## 内建原型
Object 就是一个内建的对象构造函数，其自身的 prototype 指向一个带有 toString 和其他方法的一个巨大的对象。
当 new Object() 被调用（或一个字面量对象 {...} 被创建），按照前面章节中我们学习过的规则，这个对象的 [[Prototype]] 属性被设置为 Object.prototype。
所以，之后当 obj.toString() 被调用时，这个方法是从 Object.prototype 中获取的。
Object.prototype 上方的链中没有更多的 [[Prototype]]：
`alert(Object.prototype.__proto__); // null`
Object的原型上一层就是null了。

其他内建对象，像 Array、Date、Function 及其他，都在 prototype 上挂载了方法。

例如，当我们创建一个数组 [1, 2, 3]，在内部会默认使用 new Array() 构造器。因此这个数组的[[prototype]]指向 Array.prototype，为这个数组提供数组的操作方法。这样内存的存储效率是很高的。

按照规范，所有的内建原型顶端都是 Object.prototype。这就是为什么有人说“一切都从对象继承而来”。



