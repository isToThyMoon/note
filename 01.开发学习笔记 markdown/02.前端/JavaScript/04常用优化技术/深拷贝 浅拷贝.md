---
title: js 垃圾回收 深拷贝 浅拷贝
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
  - 数组 字符串常见操作
---

# 深拷贝与浅拷贝
有了内存存储类型的知识，才能明白深拷贝 浅拷贝的概念。

深拷贝：拷贝后对新变量操作不影响原变量和对象。
基本类型都是深拷贝。不考虑。

let arr = {}，arr2 = arr 这种属于浅拷贝

# 使用数组的内置方法来拷贝数组： 第一层拷贝

Array.slice()    const arr2 = arr1.slice();  // 浅拷贝

Array.concat()   const arr2 = [].concat(arr1); // 返回新数组 但有引用类型元素的话还是拷贝的地址

Array.from()     const arr2 = Array.from(arr1); // 创建新数组

都只是第一级属性复制，比浅拷贝多一层而已

# 第一层深拷贝（不使用数组的内置方法来复制数组(都默认不能修改原数组)）
1. 扩展运算符        arr2 = [...arr1];

2. JSON转化
JSON.sringify 和 JSON.parse 这是JS实现类深拷贝最简单的方法了，原理就是先将对象转换为字符串，再通过JSON.parse重新建立一个对象。
但是这种方法的局限也很多：不能复制function、正则、Symbol循环引用报错相同的引用会被重复复制，如果属性值中有 undefined 时会丢属性，属性值是引用类型时也无法深拷贝

```
var a = {
    ...
}

var b = JSON.parse(JSON.stringify(a))
```
3. 利用js的合并对象方法 这种操作也叫mixin
可这种方法和for in 循环一样只能复制一层 
Object.assign(target, ...sources)

const person = {
   name: 'Wes Bos',
   age: 80
 };
const cap2 = Object.assign({}, person, { number: 99, age: 12 });
console.log(cap2); // Object {name: "Wes Bos", age: 12, number: 99}
可以看到后来的源对象的属性值，将会覆盖它之前的对象的属性。所以可以先复制 person 之后，再赋给属性新的值。

Lodash 有一个深度复制的方法，但使用之前需要多考虑一下。

# 真正的深拷贝
1. 递归循环
for in 加递归拷贝内部属性实现

```
function isObj(obj) {
    return (typeof obj === 'object' || typeof obj === 'function') && obj !== null
}

function deepCopy(obj) {
    let tempObj = Array.isArray(obj) ? [] : {}
    for(let key in obj) {
        tempObj[key] = isObj(obj[key]) ? deepCopy(obj[key]) : obj[key]
    }
    return tempObj
}

```

第二套代码：

```js
function clone(object){
    let object2; 
    if(!(object instanceof Object)){
        return object;
    }else if(object instanceof Array){
        object2 = []
    }else if(object instanceof Function){
        object2 = eval(object.toString())
    }else if(object instanceof Object){
        object2 = {}
    }
    
    for(let key in object){
        object2[key] = clone(object[key])
    }
    return object2
}

```

2. 深拷贝代码

```
function isObject(obj) {
  return typeof obj === 'object';
}

function isArray(arr) {
  return Array.isArray(arr);
}
function deepClone(obj) {
  if (!isObject(obj))  return obj;
  var cloneObj = isArray(obj) ? [] : {};
  
  for(var key in obj) {
    if (obj.hasOwnProperty(key)) {
      var value = obj[key];
      var copy = value;
      
      if (isObject(value)) {
        cloneObj[key] = deepClone(value);
      } else {
        cloneObj[key] = value;
      }
    }
  }
  return cloneObj;
}
```