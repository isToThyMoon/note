---
title: 03.逻辑操作符
categories:
  - 01.开发学习笔记 markdown
  - 06.JavaScript
---

# 逻辑操作符
逻辑与（&&）总结：
只要第一个值的布尔值为true，那么永远返回第二个值。
逻辑与属于短路操作，第一个值为false时，不再操作第二个值，且返回第一个值。

寻找从左到右第一个假值，找到立即返回，否则返回最后一个值。

逻辑或（||）总结：
只要第一个值的布尔值为false，那么永远返回第二个值。
逻辑或属于短路操作，第一个值为true时，不再操作第二个值，且返回第一个值。

寻找从左到右第一个真值，找到立即返回，否则返回最后一个值。




相等运算符`==`。JavaScript在设计时，有两种比较运算符：
第一种是`==`比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
第二种是`===`比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。


# 循环

## 循环内部的作用域

在 JavaScript 中，for 循环中的循环变量的作用域取决于你在声明这个变量时所使用的关键字（var、let 或 const）。不同的关键字会导致不同的作用域行为。

**使用 var 关键字**：如果你使用 var 声明循环变量，那么它将具有函数级作用域，而不是块级作用域。这意味着在整个函数内部都可以访问该变量，而不仅仅是在 for 循环的代码块内部。
```js
function example() {
  for (var i = 0; i < 5; i++) {
    // i 在整个函数内都可见
  }
  console.log(i); // 在函数内部仍然可以访问 i
}
```
这可能导致变量泄漏到函数的外部，因此在现代 JavaScript 中，通常不建议在 for 循环中使用 var。

**使用 let 或 const 关键字**：如果你使用 let 或 const 声明循环变量，那么它将具有块级作用域，仅在 for 循环的代码块内部可见。
并且每次循环的块级作用域都是相互隔离的。
```js
function example() {
  for (let i = 0; i < 5; i++) {
    // i 仅在 for 循环的代码块内可见
  }
  console.log(i); // 这里会引发错误，i 在此处不可见
}
```

### 一个常见面试题
```js
// 误解作用域:认为存在块级作用域
var array = [];
for (var i = 0; i < 3; i++) {
  // 三个箭头函数体中的每个`'i'`都指向相同的绑定，
  // 这就是为什么它们在循环结束时返回相同的值'3'。
a
  array.push(() => i);
}
var newArray = array.map(el => el());
console.log(newArray); // [3, 3, 3]
```

如果使用 let 声明一个具有块级作用域的变量，则为每个循环迭代创建一个新的绑定。每次循环块级作用域中的 i 都相互独立，并不像var那样全程共用了一个。
```js
// 使用ES6块级作用域
var array = [];
for (let i = 0; i < 3; i++) {
  // 这一次，每个'i'指的是一个新的的绑定，并保留当前的值。
 // 因此，每个箭头函数返回一个不同的值。
 // 注意这里推进的是一个箭头函数 不是具体的值 这算是面试题硬造的情况
  array.push(() => i);
}
var newArray = array.map(el => el());
console.log(newArray); // [0, 1, 2]
```
解决这个问题的另一种方法是使用闭包。

```js
let array = [];
for (var i = 0; i < 3; i++) {

  array[i] = (function(x) {
    return function() {
      return x;
    };
  })(i);
}
const newArray = array.map(el => el());
console.log(newArray); // [0, 1, 2]  
```

## for in循环遍历key value

```js
for(var key in person){
    console.log(key);
    console.log(person.key) 
    //打印不出value 这是一个陷阱，.key等价与person['key'] 每次都是取'key'这个键对应的value，明显是取不到的。应该用下面的：
    conole.log(person[key])
```