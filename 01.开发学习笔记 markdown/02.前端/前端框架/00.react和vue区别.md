
# 区别：库与框架
截止时间2022.09.

react常与vue对比，除了一些共性特征和一些语法区别，react一个显著的特点就是围绕react搭建前端项目的生态极度繁荣，而vue则更多是官方封装好了最佳实践，开发者跟着文档去写就好了。

原因官方其实已经给出，在官方网站首页，react对自己的介绍是A JavaScript library for building user interfaces。

一个构建用户界面的js库，它并没有说自己是一套大而全的框架级别的项目（如angular 如Vue）。

相比于Vue对自己的介绍：The Progressive JavaScript Framework：An approachable, performant and versatile framework for building web user interfaces.（一个用于构建web用户界面的渐进、高效、多功能的JS框架）。vue对自身定位是一个框架，几乎不用开发者开发选择其他生态。

react结合它的生态库才构成一个`MV*`框架。所谓`MV*`框架，如Vue React。只关注数据层Model + 视图View层。VM层（数据视图关联层）的实现由框架内部黑盒完成。你不用去关注内部如何实现，只需要知道实现了MV*的框架不需要命令式操作dom，而是数据驱动UI（无论是react通过setState后diff算法标记DOM，比较式更新视图；但是vue通过defineProperty/proxy实现观察者模式，细粒度响应式更新视图）。

# 响应式设计不同
响应式可以被广义地定义为应用状态变化时自动更新UI。
react和vue的响应式设计不同，
导致响应式风格和响应粒度都有差别。

react通过setState后diff算法构建新虚拟DOM，并标记修改，然后通过比较式更新视图；
但是vue通过defineProperty/proxy实现观察者模式，细粒度响应式更新视图。

# 不可变数据与可变数据不同
react深刻实践函数式编程哲学。
纯函数的三个特点是无副作用（不依赖外部资源和不确定操作），引用透明（唯一输入对应唯一输出），参数值不可变（传入函数的参数不能修改）。其中参数值不可变源于js引用类型的特性，js引用类型数据作为函数的入参，在函数内部接收的是引用类型数据的地址，操作这个地址直接改变源对象。
react hook下开发方式深刻绑定函数式编程，函数传入参数即props改变时会重新执行函数组件，也就是react的响应式。那么组件是否要重新渲染就是要检验函数组件的状态（props state）是否发生变化，这就是react一直使用的比较式更新，这种比较更新在状态是基本类型时毫无问题，但因为这种比较是浅层比较，在引用类型时就失灵：当引用类型状态发生修改，但引用地址没变，在比较式更新下就会认为这个状态未发生改变。

针对react这种特性才出现了不可变数据，虽然不可变数据就是函数式编程里的一个重要概念。

截止2022年10月，最新的方案可以采用immerJS实现，每次针对不可变数据的修改都会返回一个全新地址的对象，但它们内部又可以共享结构共享内存，所以性能几乎没有损失。

# hook区别
react发布hooks版本之后其他框架也随之跟进。
vue在composition api中对标useEffect提供了watch，更细分的话，还提供了watchEffect（还有watchPostEffect，watchSyncEffect），但介绍很短。
useEffect在react中是一个难点。react和vue在这里的区别就是react其实并没有提供一个watch，根据它的开发哲学也不准备实现，而vue则是实用为主，只要有利于开发就组合使用。
这其实凸显了react和vue作为前端库和前端框架在大方向趋同但设计理念上有着差异。

useEffect是在每次渲染完成后执行的副作用，早期的useEffect强调根据依赖数组的控制可以模拟一些生命周期，但useEffect从设计之初就不是生命周期或者说写业务逻辑的地方，从react18开始react官方也在弱化这个概念，严格模式甚至不保证useEffect的执行次数。
vue则是在提供了watchEffect之外还保留了各种生命周期函数。
从易用性来说vue肯定更适合快速开发，vue的设计理念就是吸纳各种框架的长处。
react则是基于一个思想不断贴近所谓的开发哲学，比如hooks的函数式编程。
react的入门门槛会越来越高，不理解它的开发哲学会写出非常奇怪的代码。
