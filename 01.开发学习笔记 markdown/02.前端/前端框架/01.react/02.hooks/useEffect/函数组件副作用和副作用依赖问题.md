# intro
缘起是hook版本出现了很久但是一直没办法深度使用，因为deps问题一直无法找到一个最佳实践去写hook。

# 函数式编程和副作用

为什么有hooks的出现呢？因为react需要它贯彻自己的理念，补全自己的缺陷（之前的函数组件不好管理状态）。React一直宣传的是单向数据流，强调数据的不可变性，骨子里一直是函数式的。哪怕之前的class组件是对象式的写法，它也在状态变更时使用固有的函数 this.setState，是披着对象皮的函数式思维，class并不符合它自身的价值理念。而且react也一直说它只是做UI的库，薄薄的一层view。至于数据，怎么用怎么管理，是留给开发者自己决定的。在写过成千上万页面的前端眼中，有几条认知很容易达成一致：数据与视图分离。大函数拆分，模块化代码。尽量复用，追求高内聚，低耦合的实现。

hook出现是为了实践函数式编程思想： UI = f(state)
一个组件，对于一个确定的输入（state props），有一个确定的输出（一个确定的UI结果也就是JSX）。

# side effect
先说明所谓的effect是什么。

所谓函数副作用具体来说就是函数运行主体由输入得到输出之外，读写外部资源或执行影响函数输出的确定性操作所产生的东西，它降低代码可读性并且影响数据逻辑，很容易造成bug。

副作用是实现主要目的外产生的额外行为和影响。对于react函数式编程，由数据模型渲染出页面UI = f(state)就是主要目的，主要目的之外的支线任务就是要做的副作用，react hooks设计了useEffect来承载它们。

以实际的开发举例，组件在某些场景下难以避免需要按条件调整状态和输出。所以react hooks允许在function component中引入副作用进行必要的调整，这些命令式代码所处的api就是useEffect。

数据获取 注册事件 修改dom等后置操作都会对页面产生不可控作用，这些就是side effect操作。

分为无须清除的副作用（注意防止内存泄漏）和需要清除的副作用。

为什么要清除副作用？简单举例。
增加事件监听，执行逻辑。组件重复渲染，重复增加事件监听，当事件触发，逻辑会不止执行一次。

# useEffect(didUpdate？)

先提前声明，useEffect是容纳副作用操作的地方。而不是副作用本身。

[官方文档描述](https://zh-hans.reactjs.org/docs/hooks-reference.html#useeffect)

> 该 Hook 接收一个包含命令式、且可能有副作用代码的函数。
> 在函数组件主体内（这里指在 React 渲染阶段）**改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作**都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。
> 使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。
> 默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。

第一个参数是执行函数，第二个参数是依赖变量。
useEffect 必然会在 mount 的时候执行一次，其他的运行时机取决于依赖数组的不同组合。

## 第二个参数
useEffect hook 接受两个参数，第一个是要执行的代码，第二个是一个数组，指定一组依赖的变量，其中任何一个依赖变量发生变化时，此 effect 都会重新执行一次。

当数组为空数组 []，表示不会应为页面的状态改变而去执行回调方法（即仅在初始化mount，第一次渲染完成后执行，类似componentDidMount）
当这个参数不传递，表示页面的任何状态（state props）一旦变更都会执行回调方法。（如果在 useEffect 中更新了 state，且没有指定依赖数组，或 state 存在于依赖数组中，就会造成死循环。）
当数组非空，仅仅当依赖数组里的值任意一项有变化，才会执行回调方法（类似componentDidUpdate中对具体依赖值做判断。）

如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量，否则你的代码会引用到先前渲染中的旧变量。

## 返回值
通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 执行函数需返回一个清除函数来清理effect。
useEffect 的执行函数中可以返回一个函数，在每一次新的 render 进行前或者组件 unmount 之时，都会执行此函数，进行清理工作。

### 为什么要有清理函数？优点？
如果有一个子组件useEffect执行代码是创建一个元素并插入文档中，父组件控制子组件的显隐，即mount和unmount，那么每次显示隐藏都会执行useEffect内容创建一个新元素插入dom，这样不仅内存爆炸而且也不符合功能预期。
为了解决这个问题，在class组件中我们会在componentWillUnmount中对ajax请求和这些副作用做清除，而在hooks写法中，通过useEffect的返回清除函数来做对应副作用的清除操作，并且可以在同一个作用域中拿到该元素的引用。useEffect清理函数实现了“副作用”和对应的“副作用清除”代码的聚合，代码层面直观，不像class写法代码散落在各个生命周期，组件庞大时造成心智负担理解困难。


-------

# 到底该怎么使用useEffect？
先说结论，你应该尽力不用useEffect，能不用就不用。

先由一个很广泛的吐槽，useEffect在滥用时的超长依赖数组问题说起。

## useEffect的deps依赖数组问题
文档有具体解释，useEffect的第二参数属于控制effect执行的优化方式。（也就是说组件重渲染时useEffect中执行的逻辑其实是一样的，没有必要执行两遍，所以加依赖数组阻止无意义的重复执行，理论上按react官方理念，即使执行多次也不应该导致bug，这只是一种优化方式而非必要逻辑。）
> 如果你要使用此优化方式，请确保数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量。
> 我们推荐启用 eslint-plugin-react-hooks 中的 exhaustive-deps 规则。此规则会在添加错误依赖时发出警告并给出修复建议。

将所有effect使用到的所有外部作用域变量加入到deps数组是一条很有必要但是又很麻烦的规则。

这条lint规则和官方文档将useEffect和生命周期的类比可以说是一切最佳实践争论的源头。部分极端的人认为官方从未说过useEffect等同于生命周期，并且认为滥用useEffect是一个破坏纯函数实践并且造成数据流混乱的万恶之源，应当杜绝使用，

为了说明这个牵扯讨论度非常高的问题首先必须分清你是如何使用useEffect的。

## 核心争论 useEffect当watch用对不对？
两种思维：watch还是effect？监听器还是副作用？

如何使用useEffect按照代码风格或者说开发理念可以分成两类。
1. 受文档中将effect和生命周期类比的影响，一种非常常见的用法是将effect当成类似vue中的watch使用：当依赖数组变量发生改变时，自动执行某些逻辑。
2. 一种是符合官方思路但文档没有强调得十分清晰的做法，将useEffect作为每次重复渲染完成后需要添加执行的副作用。将本不必要放在useEffec中的逻辑前置到该状态变化时执行。如，在事件回调中处理相应逻辑，EventCallback。

完全看成state引起rerender的副作用 state change → render → effect 

也可以是watch： state change → render → effect → 监听执行 → state change → render 多产生一次rerender

文档中有一句话说得很好，虽然是写在 useCallback 那里的，但是放在 useEffect 中也适用：
你应该把依赖数组作为性能优化的条件，而不是作为语义的保证。


### useEffect当成watch使用的问题
实际上将useEffect当作watch使用也就意味着该段逻辑监听某些字段执行，而为了满足lint规则，这段逻辑并不一定只响应这些状态（你在这段逻辑中使用了其他状态），最后极大概率是依赖数组写不全或者写了一堆长长的依赖可读性极差。

例如依赖某个状态执行一段函数：

```js
  const handleChangeTab = (activeKey)=>{
    console.log(activeKey)
    console.log(foo)
  }

  useEffect(() => {
    handleChangeTab(activeKey);
  }, [activeKey])
  
// React Hook useEffect has a missing dependency: 'handleChangeTab'. Either include it or remove the dependency array
```


lint规则会提示你缺少依赖项handleChangeTab，当你添加该依赖项一定也是不符合react规则的，因为handleChangeTab函数每次渲染都会重新创建，引用地址每次渲染都不同，就会造成该段effect逻辑无限执行。为了解决它你可能会想到useCallback，一个记忆函数地址的hook。
```js
const handleChangeTab = useCallback((activeKey)=>{
    ...
}, [...])

useEffect(() => {
    handleChangeTab(activeKey);
}, [activeKey,  handleChangeTab])
```
这样非常明显你需要在useCallback中继续写依赖数组，而且useEffect依赖数组中有handleChangeTab函数也非常奇怪，因为按照watch的想法，你本来只是想当某些状态改变时触发一些逻辑代码的执行而已，结果你写了一堆不合本意的面条代码。

更极端的例子:
```js
useEffect(() => {
    doSomeThing(a, b, c)
    console.log(a)
    console.log(b)
    console.log(c)
}, [a])
```
按watch的风格写代码，监听状态a执行一段逻辑，该段逻辑中使用了b和c状态，但deps数组中没有这两个依赖，无法通过lint规则，而添加这两个依赖就违反了我们的业务规则：本意只想在状态a变化时才执行这段逻辑。这种矛盾说明我们代码设计出了问题。

其实当写到useCallback就意识到这种写法非常不对劲，如果是父子组件传递该函数，子组件调用该函数很容易造成隐式依赖，更不用说如果出现多个useEffect相互触发导致链式watch，那就变成完全没法读的糟糕代码。实际上这种watch的使用方式非常容易造成数据流混乱、代码架构设计失序、巨量的不必要组件重绘甚至一不小心造成死循环调用。


**要么“确保依赖数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量”是一条糟糕的规则，
要么“将useEffect当作watch使用”是一条糟糕的实践。**

实际上这两者都有些问题，以下详细说明。

#### 不要将useEffect当作watch使用
已经说了当watch使用的问题。那么就不要把它当watch使用。
这是条挺难践行的规则，因为写命令式代码是一件很自然而然的事情。

useEffect是首次加载时网络请求的必用api，这导致它看起来是一个非常常用的hook，官方的初衷理论上useEffect使用的场景除了网络请求，添加监听器，和渲染后副作用的dom操作以外几乎不应该有其他场景，实际上react也在考虑不使用useEffect执行网络请求，而是suspense。
对于监听props修改来执行一些逻辑（类似class组件的getDerivedStateFromProps），官方推荐是将上一轮props存在一个state变量中：
```js
function ScrollView({row}) {
  const [isScrollingDown, setIsScrollingDown] = useState(false);
  const [prevRow, setPrevRow] = useState(null);

  if (row !== prevRow) {
    // Row 自上次渲染以来发生过改变。更新 isScrollingDown。
    setIsScrollingDown(prevRow !== null && row > prevRow);
    setPrevRow(row);
  }

  return `Scrolling down: ${isScrollingDown}`;
}
```

useEffect 从语义上说，就是组件每次渲染都要执行一遍的副作用，然后有时候组件重渲染时 useEffect 中的逻辑其实完全相同，没必要执行两遍，所以加个依赖数组避免它无意义的执行。注意，这仅仅是为了避免两次重复的执行，即使不加依赖数组，让 useEffect 真的执行了两次，也不应该会导致组件 bug。

也就是说，你应该先保证即使不写依赖数组（注意，这里不是依赖数组为空），你的组件也不会出问题，然后再传一个依赖数组减少没必要的 useEffect 调用。对于把 useEffect 当 watch 用的人，如果去掉了你们的依赖数组，你们的组件还能正常工作吗？文档中可是一直放着这样一句话“在未来，我们可能移除依赖数组”呢。原文中的例子还好，在把 useEffect 当 watch 用的思想下，在 useEffect 中 setState 那更糟糕，且不说更容易写出死循环，本来重绘一次的事件，现在会让组件又多重绘，这样写得多了，很容易出现一个事件让组件重绘好几次，甚至十几次的问题。

基于这点分歧，把 useEffect 当 watch 用的人，与把本不必要放在 useEffect 中的逻辑前置到状态真正发生变化时处理的人，所写出来的代码是完全不同的，不论是数据流，还是代码风格。

在实际的工作项目中，一次迭代的上万行代码里，仅仅会在组件 didMount 后发起 get 请求时使用 useEffect，除此以外，在组件整个生命周期中，应当都几乎没写过 useEffect。useEffect 本来就是个不那么常用的 api。

另外，我其实也很少写 useRef，所以对于把在effect中使用到的但不需要监听的变量先用 ref 存起来的做法也不认同。这本质上也是为了在 useEffect 中使用这两个状态而不写依赖的妥协。我认为 useRef 是比 useEffect 用得更少的 api，在实际的数据流中几乎不用经常出现。

我想强调的是，把 useEffect 当做监听器的思想是不可取的。“监听器”思想在于监听特定字段，这不是一个普适的逻辑，是只为特定字段服务的，那我认为这其实是某个状态变更逻辑的一部分，而不是一种组件渲染的副作用。把 useEffect 当监听器，带来的结果就是极大概率依赖写不全，因为你只想在某个（某些）字段变化时做相应，而这个响应却不一定只依赖这个（这些）字段。

不要以把 useEffect 当作监听器的思想使用 useEffect，而是把 useEffect 视作一种组件渲染的副作用，在这种思想下，依赖一定可以写全，数据流会清晰，bug 会变少。


当实际写业务时，副作用是无法避免对，我的想法是不绝对杜绝useEffect但尽量减少useEffect的使用，如果一定要用useEffect作为watch，尽量最小化deps的长度。

能采用函数式setState推算出的，用函数是setState：setCount(c => c + 1);
尽量将执行逻辑提前到状态修改时，而不是采用watch来监听状态之后执行相关逻辑。（有父组件调用子组件函数的情况，考虑useImperativeHandle）
useEffect使用的函数，能在useEffect内部定义就在内部定义，否则尽量使用纯函数，减少在函数中直接引用状态。
如果使用状态是必须的，采用useRef保存函数地址，使用useMemorizedFn（useEvent），或者自己封装。如果有延迟调用情况，那么在延迟调用中使用的状态考虑用useRef保存。
除非状态非常简单的函数组件，采用useReducer+useContext的形式。更复杂状态的组件，如果想使用不可变数据，采用useImmerReducer，或者直接redux toolkit管理全局状态。
不可变数据本身就是函数式编程的一部分（唯一输入对应唯一输出，传入的状态在函数内部禁止修改），所以在react hook成为官方主推的函数式编程主流，immerJS值得尝试。

react特性 fiber树调和阶段更新时采用浅比较，不可变数据使得检测数据变化更加容易
共享结构带来的性能提升
不可变数据容易追踪调试，不易出bug
简单方式实现复杂状态监测（如undo功能）

#### 避免依赖数组写全导致大量不必要依赖
“确保依赖数组中包含了所有外部作用域中会发生变化且在 effect 中使用的变量”，这也是一条有点错误的规范，你应该知道哪些场景是无需如此苛刻遵守的。

对于第一点写全依赖数组，[useEffect文档](https://zh-hans.reactjs.org/docs/hooks-effect.html)末尾有一条信息：“未来版本，可能会在构建时自动添加第二个参数。”说明useEffect的依赖数组在api设计层面不是必要的。实际上官方也在考虑如何解决useEffect 的依赖列表与闭包的问题，最新的RFC已经提交了一个新的hook：useEvent（暂名）解决这个问题。而在这个hook RFC前就有大量第三方实现了这个功能，比如ahook的useMemoizedFn。

如果先不管把useEffect当watch使用是否正确，秉持原则：“只有一种情况需要把变量放到 deps 数组中，那就是当该变量变化时，需要触发 useEffect 函数执行。而不是因为 useEffect 中用到了这个变量。”
实际上上面的代码如果你不管控制台的警告，不添加任何你需要监听的状态之外的任何变量，其实执行没有任何问题，useEffect中取到的变量都是最新一帧的状态。
至于官方提到的useEffect不写全依赖会取到过去的状态（闭包问题）正常情况下其实并不存在，闭包问题和useEffect依赖数组并没有太大关系。出现闭包问题，也就是调用effect回调使用到的是过去一帧的变量值只会出现在延迟调用情况下：

1. useEffect 的卸载函数
2. 使用 setTimeout、setInterval、Promise.then 等
3. 未设置依赖的监听函数 

这三种情况其实都是执行逻辑函数定义和调用所在帧不一致，调用是延迟的，取到的始终是初始化那一帧的count值。
```js
const getUsername = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('John');
    }, 3000);
  })
}

function Demo() {
  const [count, setCount] = useState(0);

  // setTimeout 会造成闭包问题
  useEffect(() => {
    const timer = setTimeout(() => {
      console.log(count);
    }, 3000);
    return () => {
      clearTimeout(timer);
    }
  }, [])

  // setInterval 会造成闭包问题
  useEffect(() => {
    const timer = setInterval(() => {
      console.log(count);
    }, 3000);
    return () => {
      clearInterval(timer);
    }
  }, [])

  // Promise.then 会造成闭包问题
  useEffect(() => {
    getUsername(id).then(() => {
      console.log(count);
    });
  }, [])

  // useEffect 卸载函数会造成闭包问题
  useEffect(() => {
    return () => {
      console.log(count);
    }
  }, []);
  
  // 事件监听延迟调用造成闭包问题
  useEffect(() => {
      const handleClick = function() {
        console.log('count: ', count);
      }
        window.addEventListener('click', handleClick, false)

        return () => {
          window.removeEventListener('click', handleClick, false)
        };
    }, []);
    
  return (
    <button
      onClick={() => setCount(c => c + 1)}
    >
      click
    </button>
  )
}
```


所以我们如果要不写繁复的deps数组并且不出闭包问题：

首先，考虑是否不要去监听某个状态来调用effect，如，将某些用户操作后状态变更后引起的副作用操作从useEffect中移除到状态变更的同时，例如你的dom监听函数中。
~~另外，React 里的 Sate 只要发生变化，就会触发 rerender，随之 effect 也会被执行。所以与其考虑如何在 rerender 里避免 effect 执行，不如直接考虑如何避免 rerender。~~

其次：

##### 一：
非延迟调用场景，直接 `// eslint-disable-next-line` 禁用eslint。有很多人这么做，但肯定不行， 不跟官方规则走最后升级迭代一定会痛苦。

##### 二：
[针对函数是否要放进deps数组：](https://zh-hans.reactjs.org/docs/hooks-faq.html#is-it-safe-to-omit-functions-from-the-list-of-dependencies)

非延迟调用场景，在effect中调用的函数如果只有该effect使用，在 effect 内部去声明它所需要的函数；
如果除了该effect还有其他地方用到该函数，或者就有一些原因无法移到effect内部定义：
    如果函数未使用组件的状态可以将函数定义移动到组件外；如果你所调用的方法是一个纯计算，并且可以在渲染时调用，你可以 转而在 effect 之外调用它， 并让 effect 依赖于它的返回值；
    万不得已的情况下，你可以把函数加入 effect 的依赖但把它的定义包裹 进 useCallback Hook。这就确保了它不随渲染而改变，除非 它自身 的依赖发生了改变，这是之前提到的useCallback做法，useCallback或useMemo缓存 减少deps 但是useCallback或useMemo中也要写deps依赖 增加心智负担。实际上由于隐式依赖问题严重，很不推荐。

另外 如果子组件调用父组件下传的函数，是否要放进useEffect依赖数组呢？
```js
function Child(props){
 console.log('rerender:')
 const [result,setResult] = useState('')
 const { fetchData } = props;
  useEffect(() => {
    fetchData().then(result => {
      sefetchDatatResult(result);
    })
  },[fetchData])
 return (
    <div>query:{props.query}</div>
    <div>result:{result}</div>
  )
}

export function Parent(){
 const [query,setQuery] = useState('react');
 const fetchData = () => {
     const url = 'https://xxx/search?query=' + query
      return fetch(url).then(x => x.text())
 } 
 return (
    <div>
    <input onChange={e => setQuery(e.target.value)} value={query} />
    <Child fetchData={fetchData} query={query}/>
    </div>
  )
}
```
如果要放入，必须要用useCallback缓存，否则父组件的每次rerender都会造成该函数地址修改，继而rerender子组件重新执行effect逻辑。
而使用useCallback会造成隐式依赖问题。理想做法是不使用useCallback，而是把该函数依赖的父级状态下传，让子组件的effect依赖该父组件状态，这样effect执行的代码意图更加清晰，回调函数也是纯函数（react中能写纯函数就写纯函数）。

```js
// parent
const fetchData = query => {
  const url = 'https://hn.algolia.com/api/v1/search?query=' + query
  return fetch(url).then(x => x.text())
}
// child

useEffect(() => {
    fetchData(query).then(result => {
      setResult(result);
    })
},[query])
```

如果不想向下传递回调，可以看第五条方案，采用useReducer + useContext的组合。

##### 三：
确定依赖变量是否可以直接由当前state计算得出 采用函数式更新state：setCount(c => c + 1);

```js
useEffect(() => {
    setCount(b => b + 1)
}, []);
```

##### 四：
对于延迟调用的通用处理：通过 useRef标记存储状态，来保证任何时候访问的 countRef.current 都是最新的，以解决闭包问题，且不会出现依赖警告。官方称这种方法为[万不得已的情况下](https://zh-hans.reactjs.org/docs/hooks-faq.html#what-can-i-do-if-my-effect-dependencies-change-too-often)，但其实第三方框架大量使用这种方法，也是在你从代码架构层面无法解决（无法将逻辑从effect中移出前置执行在状态修改前）时最好的方案。

```js
const countRef = useRef(count);
countRef.current = count;
```

```js
const [count, setCount] = useState(0);

// 通过 ref 来记忆最新的 count
const countRef = useRef(count);
countRef.current = count;

useEffect(() => {
  const timer = setTimeout(() => {
    console.log(countRef.current)
  }, 3000);
  return () => {
    clearTimeout(timer);
  }
}, [])
......
```

甚至你可以对函数也这么处理。

```js
...
const handleStateChange = (id)=>{
...
}
const handleStateChangeRef = useRef(handleStateChange);
handleStateChangeRef.current = useMemo(() => handleStateChange,  [handleStateChange]);

useEffect(()=>{
    handleStateChangeRef.current(id)
},[id])
```

但这种ref方式写法太麻烦，复杂项目要写无数个ref。

应当知道，函数式编程（声明式编程）和命令式编程有个最本质的区别，那就是声明式编程会避免用变量保存程序的状态，从而能提高代码的无状态性。在hook中react为我们引入useState来为纯函数添加状态，但其实hook式函数的组件更新逻辑采用的是电影帧的方式，每一帧里useState引入的状态其实都是一个固定值，所以单纯引入useState并不影响纯函数的“纯度”。

像上述代码中采用useRef才是跨周期的用变量保存程序的状态，这种命令式编程的方式虽然和useEffect容纳副作用设计初衷符合，但大量的使用useRef肯定是不断降低纯函数的“纯度”，越不纯的命令式编程带来更高的自由度，同时也让逻辑更加复杂不可控，这是react hook设计初衷就要避免的问题。

所以在组件代码中大量使用这样的useRef有滥用之嫌，但业务组件无可避免需要副作用，需要尽量保持克制使用ref而不是不用，我们无法写出完全的纯函数项目，那样的项目一定是复杂度不够，或者不符合业务需求的，没有业务的代码也就没有了意义。

而且handleStateChange中可以任意使用组件的状态而失去了lint检查（本来就是通过ref在整个周期保存状态而不被useEffect检查，来绕过lint限制），这需要你自己控制在函数代码中不要有延迟调用的情况。

##### 五：
复杂场景，（比如一个 state 依赖于另一个 state），使用useReducer，useReducer 的 dispatch引用地址是稳定的，和useRef一样不用加入依赖列表，这样对于状态的修改完全通过dispatch完成，原本在useEffect中的状态代码都被移出到reducer处理，自然不用加入useEffect的依赖列表。

```js
function scanReducer(state, [type, payload]) {
  switch (type) {
    case "initial":
      return { ...state, pending: payload.pending };
    case "pendingBookAdded":
      return { ...state, pending: state.pending + 1 };
    case "bookAdded":
      return {
        ...state,
        pending: state.pending - 1,
        booksSaved: [payload, ...state.booksSaved]
      };
    case "bookLookupFailed":
      return {
        ...state,
        pending: state.pending - 1,
        booksSaved: [
          {
            _id: "" + new Date(),
            title: `Failed lookup for ${payload.isbn}`,
            success: false
          },
          ...state.booksSaved
        ]
      };
  }
  return state;
}
const initialState = { pending: 0, booksSaved: [] };

const BookEntryList = props => {
  const [state, dispatch] = useReducer(scanReducer, initialState);

  useEffect(() => {
    const ws = new WebSocket(webSocketAddress("/bookEntryWS"));

    ws.onmessage = ({ data }) => {
      let packet = JSON.parse(data);
      dispatch([packet._messageType, packet]);
    };
    return () => {
      try {
        ws.close();
      } catch (e) {}
    };
  }, []);

  //...
};
```

实际上useReducer +useContext管理父子层级的状态修改，[避免向下传递回调](https://zh-hans.reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down)，这也是最常使用的api，我认为这是目前为止的最佳实践。

如果需要不可变数据，使用use-immer中的useImmerReducer替换useReducer，或者一步到位使用Redux Toolkit管理状态，redux toolkit内部集成了immerJs。

官方示例：
```js
const TodosDispatch = React.createContext(null);

function TodosApp() {
  // 提示：`dispatch` 不会在重新渲染之间变化
  const [todos, dispatch] = useReducer(todosReducer);

  return (
    <TodosDispatch.Provider value={dispatch}>
      <DeepTree todos={todos} />
    </TodosDispatch.Provider>
  );
}

// TodosApp 内部组件树里的任何子节点都可以使用 dispatch 函数来向上传递 actions 到 TodosApp：

function DeepChild(props) {
  // 如果我们想要执行一个 action，我们可以从 context 中获取 dispatch。
  const dispatch = useContext(TodosDispatch);

  function handleClick() {
    dispatch({ type: 'add', text: 'hello' });
  }

  return (
    <button onClick={handleClick}>Add todo</button>
  );
}
```

##### 六
未来将要加入的api useEvent。

很早各大hook库就实现了类似的功能，ahooks的useMemoizedFn实现类似功能，所有实现方式大体类似：

```js
function useMemoizedFn(fn) {
  // useRef跨周期记忆此函数
  const fnRef = useRef(fn);
  fnRef.current = useMemo(() => fn, [fn]);
  // useCallback保证返回函数的地址稳定
  return useCallback((...args) => {
    return fnRef.current.apply(args);
  }, []);
}
```
改版：
```js
function useMemoizedFn(fn) {
  const fnRef = useRef(fn);
  // why not write `fnRef.current = fn`?
  // https://github.com/alibaba/hooks/issues/728
  fnRef.current = useMemo(() => fn, [fn]);

  const memoizedFn = useRef();
  if (!memoizedFn.current) {
    memoizedFn.current = function (this, ...args) {
      return fnRef.current.apply(this, args);
    };
  }

  return memoizedFn.current;
}
```
之前React Issue #16956 上对类似的封装做了很多讨论，官方的态度一直是 “在 concurrent 下可能会存在问题” 。在React 18 之前，因为没有 concurrent，所以useMemoizedFn不会有任何问题，随着 React18发布，concurrent 模式稳定之后，官方发现，这种写法也不会有问题，所以在2022年5月发了次RFC，将会考虑提供useEvent。

具体useEvent见其专题。


## 为什么不应该直接在useEffect中请求数据
最后一个useEffect问题，我们常把网络请求这样的副作用写入useEffect，似乎没有其他地方好处理网络请求了。
如果连请求都不能在useEffect中使用，应该写在哪儿。

* 绝大部分触发网络请求的原因都是用户操作，应该在 Event Handler 中发送网络请求
* 大部分时候，首屏需要的数据可以通过服务端渲染 SSR 直出、无需在客户端额外发送网络请求
* 即使需要客户端在首屏获取数据，未来 React 和社区维护的库会提供基于 Suspense 的数据请求 Pattern、实现「Render as your fetch」
* 即使不使用「Fetch on render」的 Pattern，也应该直接使用第三方库如 SWR 或 React Query，而不是直接使用 useEffect


# 总结 设计混乱的useEffect
经过以上一大段对比论证，其实可以感觉到useEffect的设计问题。
了解它的语法和用法后，加上对其字面意思的理解（监听执行副作用），你会非常容易把它当成watcher使用。但很快你会发现，如果监听的变量没有触发组件重渲染，这段监听的useEffect执行函数并不会生效，也就是说useEffect还是用于监听state的变化，即useStateEffect，但参数并未限制仅仅输入state，如果不是为了某些特殊动作，很难不让人认为这是一种设计缺陷。
而且当你在useEffect中使用到函数时，lint规则也会提示你把函数变量放入依赖列表，为避免函数每次创建时地址不同导致无限执行，你又需要缓存函数地址。
useStateEffect的理解也不到位，即使把它当作每次渲染后执行的副作用，useEffect实际还可以负责mount的监听，用空依赖来区分mount和update。
单一api的能力越多，意味着设计越混乱。


### suspense 

Suspense for Data Fetching。（试验性功能）

在data fetching稳定之前没法用。

目前截止2022年9月suspense还只是通过配合 React.lazy 用于组件懒加载，支持数据加载还只存在于计划中。
下面是模拟代码：
```js
const Parent = ()=>{
    return (
       <Suspense fallback={<p>Loading articles...</p>}>
        <Child />
      </Suspense>
    )
}


import getResource from './source'
const Child = ()=>{
    const articles = getResource.read()
    return (
        ...
    )
}
```





