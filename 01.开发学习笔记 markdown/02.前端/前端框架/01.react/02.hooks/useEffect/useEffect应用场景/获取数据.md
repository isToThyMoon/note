

如果是请求数据的操作，似乎理所当然useEffect的参数执行函数可以是一个异步函数，但hooks不允许，useEffect参数只能是一个函数。
正确写法是把获取数据的操作写在一个函数中并在useEffect执行函数中调用它。
```js
const [posts, setPosts] = useState([]);
const [loading, setLoading] = useState(false);

useEffect(() => {
  // const response = await fetch("https://jsonplaceholder.typicode.com/posts");

  const loadPosts = async () => {
    setLoading(true);
    const response = await fetch(
      `https://jsonplaceholder.typicode.com/posts?_limit=${count}`
    );
    const data = await response.json();
    setPosts(data);
    setLoading(false);
  };

  loadPosts();
}, [count]);

```

它所做的操作是，在请求数据前，把 loading 状态设置为 true，然后根据 count 的值去取对应数量的文章列表，把返回值更新到 posts state 中，再把 loading 设置为 false。最后根据 loading 的状态，我们显示 加载中 或 文章列表：

```js
if (loading) return <div>loading...</div>;

return (
  <ul>
    {posts.slice(0, count).map((post, index) => {
      return <li key={post.id}>{post.title}</li>;
    })}
  </ul>
);
```

上边的例子中我们给 useEffect 传递了第二个参数，并把 count 作为依赖的值，每当 count 变化时，此 effect 都会重新执行一次，去加载新的数据。如果我们去掉第二个参数，那么就会陷入死循环的坑，为什么呢？因为 effect 执行时，会更新 posts 和 loading 这两个 state，而 state 变化时，组件又会重新 render 一次，根据 useEffect 在每次 render 必执行一次的定律不难得出结论。那么如果我们给它一个空数组，那么只会在第一次mount时执行该函数。