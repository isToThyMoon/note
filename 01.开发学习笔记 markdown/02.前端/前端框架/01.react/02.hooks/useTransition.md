
https://mp.weixin.qq.com/s/dcPiKDGhMgX6VJ9IK413Ww

要说React有什么其他框架没有的、独一无二的特性，那一定是「并发更新」。围绕并发更新，存在两个很有意思的现象：

很多开发者听说过他

很少开发者直接使用过他

这两个现象看似矛盾，其实很好解释 —— React18之后的新特性，主要是面向上层框架的（主要是Next.js）。

换句话说，这些新特性（比如并发更新）主要是供框架集成，而不是开发者直接使用。

比如，并发更新的两个核心API —— useTransition和useDeferredValue，都是针对「视图切换」的场景。

而在前端交互中，最主要的「视图切换」场景就是「路由切换」，所以包含路由功能的前端框架就会集成这两个API。

而现在，一个试验性浏览器API —— View Transitions API将原生实现「视图切换」功能。



视图切换的实现还有很多细节需要考虑，比如：

如何处理新旧视图切换时的过渡效果？

如何处理新视图加载时的loading效果？

当正在请求新视图数据时（此时视图处在旧视图中），用户又对旧视图产生交互怎么办？

视图切换时如何处理页面滚动位置、光标聚焦（focus）位置？

对于使用屏幕阅读器的盲人，视图切换时阅读器会朗读什么？



在SPA（单页应用）出现之前，网站通常是由多个页面组成。比如网站的每个Tab栏，对应一个独立网页

在Tab之间切换，浏览器会：

卸载之前的页面

请求新页面数据

加载新页面

从「页面卸载」到「页面加载」之间的白屏间隙会造成屏幕闪烁。

要优化这种场景下优化视图切换效果，当前唯一做法是利用history API接管路由操作，将网页变成一个SPA。

既然「视图切换」是如此常见的需求，且有这么多需要考虑的因素，那浏览器为什么不原生实现呢？

于是，View Transitions API应运而生。


View Transitions API的使用很简单，只需要用document.startViewTransition包裹视图切换后的回调函数即可。

比如一个相册gallery应用，点击小图区域将大图区域切换为对应的小图的大图，回调函数的逻辑是「将img标签src属性更新为新图片地址」：

```
const transition = document.startViewTransition(() => {
  galleryImg.src = /* 新图片地址 */;
});
```