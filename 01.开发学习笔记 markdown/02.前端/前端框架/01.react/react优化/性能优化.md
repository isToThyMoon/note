# React中性能优化的手段

框架机制层面：
1. Key标记优化不必要的组件或者dom重绘

2. React.memo与 shouldcomponentupdate 和pureComponent

3. useMemo useCallback来缓存值和函数 避免重复计算
 
4. 组件的immutable不可变数据结构 优化状态更新流程

工程打包层面：

1. 懒加载组件
2. 服务端渲染SSR

代码层面：
1. 状态拆分原子化 避免复杂格式数据的更新
2. 属性传递优化 传递参数时尽量减少传递参数的数量
3. 使用 React Fragments 避免额外标记
4. 不要使用内联函数定义 如onClick绑定一个匿名函数
5. 函数绑定this问题，在 Constructor 的早期绑定函数this 而不是render，更好方法是箭头函数
6. 优化 React 中的条件渲染
7. 不要在 render 方法中大量创建对象和函数
8. 避免 componentWillMount() 中的异步请求
9. 多组件划分层级 优化
10. 为组件创建错误边界

业务层面：
1. 虚拟列表



# 1.加Key标记优化不必要的组件或者dom重绘

## 为什么列表要加 key 属性，以及为什么用 index 是不好的

遍历对象的每一个属性深度对比是非常浪费性能的

React 使用列表的`key`来进行对比，如果不指定，就默认为 index 下标

那么，为什么 不指定 key/用 index 下标 是不好的呢？

假设现在有这样一段代码：

```
const users = [{ username: "bob" }, { username: "sue" }];

users.map((u, i) => <div key={i}>{u.username}</div>);

```

它会渲染出这个 DOM 树：

```
<div key="1">bob</div>
<div key="2">sue</div>

```

然后用户做了某个操作，`users` 被 `unshift` 另一个对象，变成：

```
const users = [
  { username: "new-guy" },
  { username: "bob" },
  { username: "sue" },
];

```

DOM 树就会变成这样，注意`key`的变化：

```
<div key="1">new-guy</div>
<div key="2">bob</div>
<div key="3">sue</div>

```

DOM 树的前后对比是这样的：

```
<div key="1">bob</div>   |  <div key="1">new-guy</div>
<div key="2">sue</div>   |  <div key="2">bob</div>
                         |  <div key="3">sue</div>

```

我们人类看得出来前后的变化只是在开头加了一个`new-guy`而已

但是由于 React 使用 key 值来识别变化，所以 React 认为的变化是：

1. bob -> new-guy
2. sue -> bob
3. 添加 sue

非常消耗性能 😭

但是如果我们一开始就给它指定一个合适的 key，比如用 name：

```
users.map((u, i) => <div key={u.username}>{u.username}</div>);

```

React 认为的变化就变成：

```
	                         |  <div key="1">new-guy</div>
<div key="bob">bob</div>   |  <div key="bob">bob</div>
<div key="sue">sue</div>   |  <div key="sue">sue</div>

```

这样只需要做一个`unshift`操作，性能节省 😃


# 

dynamic import / lazy 官方代码层支持。
进行代码分割，暂时不需要加载的代码直接没有请求资源。


React.memo
react默认行为，父组件状态更新，自组件虽然没有用到这个状态，也会被重新刷新。
如果自组件进行了大量耗时耗cpu计算操作，这样是比较耗费性能的。
react.memo类似之前的pureComponent
只有在自组件的props改变或者内部状态修改时才会重新渲染。

一般情况很少使用，react.memo本身耗费一定性能，且react本身足够快速，需要使用它的场景很少见。



profiler api进行性能追踪。


# 2.React.memo与 shouldcomponentupdate 和pureComponent



# 简化的render prop 实现减少子组件不必要的重渲染
先来看一段常见的 React 代码
```jsx
import { useState } from "react"

const Father = () => {
  const [count, setCount] = useState(0);
  console.log("Father rendered");
  return (
    <>
      <p>I am Father p tag, {count}</p>
      <button onClick={() => setCount(count + 1)}>Add Count</button>
      <br />
      <Children />
    </>
  );
};

const Children = () => {
  console.log("Children rendered");
  return <p>I am Children p tag</p>;
};
```
每次点击触发Father组件的重渲染，根据react比较式响应的原则，子组件Children也会重新渲染。
实际上在子组件中，并没有用到来自父组件的状态或是自身状态发生了变化，既然状态并没有发生变化不存在重新渲染的需要，那么这个组件更新就是没有必要的。如果子组件的渲染开销比较大，这可能会是一个比较严重的性能问题。

那么如何解决这个问题呢？可能第一反应是给子组件加上PureComponent或者 React.memo 进行 props 浅层比较，或者shouldComponentUpdate控制是否重渲染。

我们从其他角度寻找其他解决方式。

改动一下上面的代码，在父组件和子组件之间添加一个承载逻辑的组件（FatherLogic）：

```js
import { useState } from "react";

const Father = () => {
  console.log("Father rendered");
  return (
    <FatherLogic>
      <br />
      <Children />
    </FatherLogic>
  );
};

const FatherLogic = ({ children }) => {
  const [count, setCount] = useState(0);
  console.log("FatherLogic rendered");
  return (
    <>
      <p>I am Father p tag, {count}</p>
      <button onClick={() => setCount(count + 1)}>Add Count</button>
      {children}
    </>
  );
};

const Children = () => {
  console.log("Children rendered");
  return <p>I am Children p tag</p>;
};
```

在这个 逻辑 组件中，我们把原先父组件中依赖 state 的部分放在了这里，将状态进行下放，其余不依赖的部分则通过组件的 children 属性传递给 逻辑组件。

为什么这样建立一个中间容器，就不会重复触发Children组件渲染？

非常简单，在Father组件中，Children作为props被传入FatherIoc中，FatherIoc组件的重渲染不会修改传入的props。

这里其实不是所谓标准的render prop，标准的render prop是父组件的prop属性传入一个函数，函数返回一个包含复用逻辑的组件，这个被传入的render函数在父组件内部被调用，可以接受父组件的state为入参，处理后的复用逻辑组件将在父组件内部使用。但实现了逻辑的复用。

而这里优化重渲染的例子中，组件Children与Father组件的状态变更无关，将Children组件拉到Father的组件父级，作为prop传入并在jsx中使用，这样Father逻辑组件重新渲染时就不会影响到作为props传入的Children组件。

有些认知认为FatherLogic也可以看成是FatherIoC，整体当成是一种依赖倒置的具体实现，依赖注入。Children作为低层模块可以被随意替换，高层模块Father使用低层模块而不依赖它，它们之间通过FatherIoC胶合。只能说整体模式有点像，但并不是完全的依赖倒置，只能说类似。

更接近Render Prop模式而不是依赖注入。具体来说，它使用了类似Render Prop的模式，通过FatherLogic组件的children prop来传递子组件，允许父组件决定渲染什么内容。

这种模式与Render Prop模式非常相似，尽管在传递子组件时没有使用显式的函数，但它共享了Render Prop模式的一些思想，即通过Props传递组件以实现渲染和数据传递的灵活性。