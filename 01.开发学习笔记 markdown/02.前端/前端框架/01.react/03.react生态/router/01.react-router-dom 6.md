
react-router-domv6官方推荐安装：

```bash
npm create vite@latest myproject -- --template react
cd myproject
npm install react-router-dom localforage match-sorter sort-by
npm run dev
```

配合react18的更新，react-router6.x
[官方文档和示例](https://reactrouter.com/en/6.4.3/start/overview)

HashRouter和BrowserRouter的区别：
HashRouter 只会修改URL中的哈希值部分；而 BrowserRouter 修改的是URL本身
HashRouter 是纯前端路由，可以通过输入URL直接访问，一切由前端控制；www.xxx.com/dada/map#/mainpage
使用时 BrowserRouter 直接输入URL会显示404，除非配置Nginx将请求指向对应的HTML文件。初次进入 / 路径时或点击 Link 组件跳转时不会发送请求。

BrowserRouter需要服务端配合配置，对所有路由匹配到index.html，react已经对路由做了处理：


```
server {
	server_name react.thinktxt.com;
	listen 80;

	root /Users/txBoy/WEB-Project/React-Demo/dist;
	index index.html;
	location / {
    	try_files $uri /index.html;
  	}
}
```

通过配置Nginx，访问任何URI都指向index.html，浏览器上的path，会自动被React-router处理，进行无刷新跳转。


# 升级到react-router v6
6.4开始支持data api，也就是loader和action写法，让react router dom获得获取数据的能力。
In v6.4, new routers were introduced that support the new data APIs:
```js
createBrowserRouter
createMemoryRouter
createHashRouter
```

The following routers do not support the data APIs:
```js
<BrowserRouter>
<MemoryRouter>
<HashRouter>
<NativeRouter>
<StaticRouter>
```

新版的react-router使用函数式创建router方式，可以支持最新的data api，以前的jsx嵌套形式的根路由HashRouter等是不支持data api的，所以如果使用新版react-router，务必使用新方式创建路由。
必须结合`<RouterProvider>`一起使用。

```jsx
import React from "react";
import ReactDOM from "react-dom/client";
import {
  createBrowserRouter,
  RouterProvider,
  Route,
} from "react-router-dom";
import "./index.css";

const router = createBrowserRouter([
  {
    path: "/",
    element: <div>Hello world!</div>,
  },
]);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```

当然官方也提供了createRoutesFromElements这个api让你能够非常容易地从旧版jsx方式迁移，route object的配置方式不是必须，借助createRoutesFromElements，jsx方式和route object的方式是可选的。

```jsx
import {
  createBrowserRouter,
  RouterProvider,
} from "react-router-dom";

const router = createBrowserRouter(
  createRoutesFromElements(
    <Route path="/" element={<Root />}>
      <Route path="dashboard" element={<Dashboard />} />
      {/* ... etc. */}
    </Route>
  )
);

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <RouterProvider router={router} />
  </React.StrictMode>
);
```
据体验来说，vue3也采用了新函数式的router创建方式，但是它们创建内嵌路由的思路不一样，其他地方也有差别，可使用时具体体悟。


# 不实用data api 仍采用标签式创建路由
```js
import { BrowerRouter, HashRouter, Routes, Route } from "react-router-dom";
import App from "./app";

const RootRouter:React.FC<any> = () => {

  return(
    <HashRouter>
      <Routes>  // v5版本的Switch变成Routes
        <Route path="/" element={<App/>}/>
        //element：这个是新增的，用于决定路由匹配时，渲染哪个组件。在v5的时候，我们通常会用到component这个属性，或者是render；v6中component/render被element替代
      </Routes>
    </HashRouter>
  )
}

export default RootRouter;
```

BrowerRouter, HashRouter最好放最顶层。

# 路由跳转
路由跳转时，/开头是绝对路由，否则是相对路由，即相对当前URL进行改变

NavLink和Link组件功能是一致的，区别在于可以判断起to属性是否是当前匹配到的路由
navLink组件的style或className可以接收一个函数，函数接收一个含有isActive字段的对象为参数，可根据该参数调整样式

```js
import { NavLink } from "react-router-dom";

function Foo() {
  return (
    <NavLink style={({ isActive }) => ({ color: isActive ? "red" : "#fff" })}>
      Click here
    </NavLink>
  );
}
```

## 编程式跳转
使用useNavigate钩子函数生成navigate函数，可以通过 JS 代码完成路由跳转

> useNavigate取代了原先版本中的useHistory

// v5
const history = useHistory();
history.push('/home');
history.replace('/home');

// v6
const navigate = useNavigate();
navigate('/home');
navigate('/home', {replace: true});

```
import { useNavigate } from 'react-router-dom';

function Foo(){
    const navigate = useNavigate();
    return (
        // 上一个路径：/a；    当前路径： /a/a1
        <div onClick={() => navigate('/b')}>跳转到/b</div>
        <div onClick={() => navigate('a11')}>跳转到/a/a1/a11</div>
        <div onClick={() => navigate('../a2')}>跳转到/a/a2</div>
        <div onClick={() => navigate(-1)}>跳转到/a</div>
    )
}
```
可以直接传入要跳转的目标路由（可以使用相对路径，语法和 JS 相同）
传入-1表示后退

-------

# 使用 useLocation() 钩子通过 React Router 获取当前路由
 const location = useLocation();
 
useLocation也可以获得编程跳转携带的参数
navigate('/your-route-path', { state: { name: 'dada' }});
const location = useLocation();
const { name } = location.state; // 'dada'
 
-------

# 动态路由参数

## 路径参数params
在Route组件中的path属性中定义路径参数
在组件内通过useParams hook 访问路径参数
```
<BrowserRouter>
  <Routes>
    <Route path="/foo/:id" element={<Foo />} />
  </Routes>
</BrowserRouter>;

import { useParams } from "react-router-dom";
export default function Foo() {
  const params = useParams();
  return (
    <div>
      <h1>{params.id}</h1>
    </div>
  );
}
```
### 路径匹配规则
当URL同时匹配到含有路径参数的路径和无参数路径时，优先匹配没有参数的”具体的“（specific）路径。

<Route path="teams/:teamId" element={<Team />} />
<Route path="teams/new" element={<NewTeamForm />} />
如上的两个路径，将会匹配 teams/new 。

路径的正则匹配已被移除。

### 兼容类组件
在以前版本中，组件的props会包含一个match对象，在其中可以取到路径参数。

但在最新的 6.x 版本中，无法从 props 获取参数。

并且，针对类组件的 withRouter 高阶组件已被移除。因此对于类组件来说，使用参数有两种兼容方法：

1.将类组件改写为函数组件
2.自己写一个 HOC 来包裹类组件，用 useParams 获取参数后通过 props 传入原本的类组件


## search 参数query
查询参数不需要在路由中定义
使用 useSearchParams hook 来访问和修改查询参数。其用法和 useState 类似，会返回当前对象和更改它的方法
使用 setSearchParams 时，必须传入所有的查询参数，否则会覆盖已有参数
```js
import { useSearchParams } from "react-router-dom";

// 当前路径为 /foo?id=12
function Foo() {
  const [searchParams, setSearchParams] = useSearchParams();
  console.log(searchParams.get("id")); // 12
  setSearchParams({
    name: "foo",
  }); // /foo?name=foo
  return <div>foo</div>;
}
```

-------

# 嵌套路由

## 路由定义
通过嵌套的书写Route组件实现对嵌套路由的定义。

> path 开头为 / 的为绝对路径，反之为相对路径。

```js
<Routes>
  <Route path="/" element={<Home />}></Route>
  <Route path="/father" element={<Father />}>
    <Route path="child" element={<Child />}></Route>
    <Route path=":name" element={<Another />}></Route>
  </Route>
</Routes>
```

## 在父组件中展示

在React Router v5中，必须明确定义嵌套路由，React Router v6并非如此。它从React Router库中挑选了一个名为 Outlet 的最佳元素，为特定路由呈现任何匹配的子元素。

在父组件中使用Outlet来显示匹配到的子组件

```
import { Outlet } from "react-router-dom";
function Father() {
  return (
    <div>
      // ... 自己组件的内容 // 留给子组件Child的出口
      <Outlet />
    </div>
  );
}
```

## 在组件中定义
可以在任何组件中使用 Routes 组件，且组件内的Routes中，路径默认带上当前组件的路径作为前缀。

注意：此时定义父组件的路由时，要在后面加上 /* ，否则父组件将无法渲染。

```js
<Routes>
  <Route path="/" element={<Home />} />
  <Route path="dashboard/*" element={<Dashboard />} />
</Routes>
function Dashboard() {
  return (
    <div>
      <p>Look, more routes!</p>
      <Routes>
        <Route path="/" element={<DashboardGraphs />} />
        <Route path="invoices" element={<InvoiceList />} />
      </Routes>
    </div>
  );
}
```

-------

# 默认路由
定义：在嵌套路由中，如果 URL 仅匹配了父级 URL，则Outlet中会显示带有index属性的子路由。可以使用在路由的任何层级
```js
<Routes>
  <Route path="/foo" element={Foo}>
    <Route index element={Default}></Route>
    <Route path="bar" element={Bar}></Route>
  </Route>
</Routes>
当 url 为/foo时：Foo 中的 Outlet 会显示 Default 组件
当 url 为/foo/bar时：Foo 中的 Outlet 会显示为 Bar 组件
```

-------

# 全匹配路由
定义： path属性取值为*时，可以匹配任何（非空）路径，该匹配拥有最低的优先级。可以用于设置 404 页面。
```js
<Routes>
  <Route path="/foo" element={Foo}>
    <Route path="bar" element={Bar}></Route>
    <Route path="*" element={NotFound}></Route>
  </Route>
</Routes>
```

-------

# 多组路由
通常，一个应用中只有一个Routes组件。

但根据实际需要也可以定义多个路由出口（如：侧边栏和主页面都要随 URL 而变化）
```js
<Router>
  <SideBar>
    <Routes>
      <Route></Route>
    </Routes>
  </SideBar>
  <Main>
    <Routes>
      <Route></Route>
    </Routes>
  </Main>
</Router>
```

-------

# 路由重定向
当在某个路径/a下，要重定向到路径/b时，可以通过Navigate组件进行重定向到其他路径

等价于以前版本中的Redirect组件
import { Navigate } from "react-router-dom";
function A() {
  return <Navigate to="/b" />;
}

-------

# 布局路由
当多个路由有共同的父级组件时，可以将父组件提取为一个没有 path 和 index 属性的Route组件（Layout Route）
```js
<Route element={<PageLayout />}>
    <Route path="/privacy" element={<Privacy />} />
    <Route path="/tos" element={<Tos />} />
</Route>
```

这种写法等价于：
```js
<Route
  path="/privacy"
  element={
    <PageLayout>
      <Privacy />
    </PageLayout>
  }
/>
<Route
  path="/tos"
  element={
    <PageLayout>
      <Tos />
    </PageLayout>
  }
/>
```

# 路由懒加载

懒加载和代码分割可参考[官方文档](https://zh-hans.reactjs.org/docs/code-splitting.html)

```js
import React, { Suspense, lazy } from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';

const Home = lazy(() => import('./routes/Home'));
const About = lazy(() => import('./routes/About'));

const App = () => (
  <Router>
    <Suspense fallback={<div>Loading...</div>}>
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/about" element={<About />} />
      </Routes>
    </Suspense>
  </Router>
);
```



# data api

当你使用createXXXXRouter和<RouterProvider>时，你就可以使用 Data API。
其实就是允许你把「数据获取逻辑」写到路由定义中。每当路由切换到那里时，会自动获取数据。
我们从<Route>的变化就可以看出，它新增了3个相关的属性：
loader
action
errorElement