
理解本节内容，需要同时深度理解  浏览器相关 - 线程 引擎 - 浏览器组件 js异步并发模型

# class组件正常执行流程：
## 挂载：
当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：
constructor
static getDreivedStateFromProps()（新增）
#componentWillMount(废弃)
render
componentDidMount

## 更新
当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：
static getDreivedStateFromProps()（新增）
shouldComponentUpdate
render
getSnapshotBeforeUpdate
componentDidUpdate

## 卸载
当组件从 DOM 中移除时会调用如下方法：
componentWillUnMount

注意周期里各函数执行时机的一个重点：
1. render函数并不做实际的渲染动作，他只是返回一个JSX描述的结构（ReactElement）。
2. render函数被调用完之后，componentDidMount函数并不是会被立刻调用。componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，这里的渲染指组件已经被js引擎『装载』到了DOM树上，但是渲染引擎还没有执行，页面没有完成真实渲染，js引擎并没有让出锁。

-------


# 组件何时会触发了渲染
之前基础架构层面概念讲完，那么组件何时会触发了渲染？

组件收到新的props。
状态被更新。
上下文的值被更新（如果该组件使用useContext监听上下文的变化）。
父组件由于上述任何原因而更新。

## 父组件中状态更新的影响
由于功能组件中的本地状态变化，我们看到了组件重新渲染的周期。当父组件和子组件都有自己的本地状态（通过useState），并且父组件的状态被改变时，会发生什么呢？
父组件重新渲染时，它的子组件也会重新渲染，这是React的默认行为，可以通过用useMemo挂钩包装子组件来改变它

## 渲染
class组件的render方法并不会去真正的操作DOM，它的作用是把需要的东西返回回来。真正渲染的工作，是挂载阶段的ReactDOM.render方法去操作。

渲染 是个复合且笼统的过程，可以简单理解为 layout 和 paint 两个过程。layout 是计算出 renderObject（浏览器中表示渲染元素的对象，大体上和 DOM 节点是对应的）的几何尺寸和位置；paint 则是将 renderObject 绘制为位图用于显示，这个过程一般需要 GPU 的参与。

在 React 使用 fiber reconciler 之前（前文提到的react15，16开始采用fiber架构），组件的更新在一个 script 任务中完成的，即同步的。尽管在生命周期函数里调用 setState 不会立即影响 state 的变化，但生命周期函数执行完，这些“partialState”都会被一并“结算”，即 batchUpdate，又会立即引起组件的再一次更新。 在 componentDidMount 使用使用 setState，组件的 render 方法会被执行两次，DOM 被更新两次，但由于整个过程在同一个 script 任务发生的，两次render➕commit是不会中段的同步任务，都在js引擎中间并不会让给渲染线程去绘制屏幕，所以浏览器却只能 paint 最后的 DOM 更变。

event loop 明确了一个 task queue 最多有一次 paint（结合事件循环的知识来理解），尽管在 script 中 DOM 被修改了多次。React 的同步渲染逻辑，确保了 componentDidMount 之前的 render 和其中setState触发的 render 在同一个 script 过程中，从而保证了只会有第二次 render 的结果会被浏览器绘制。

## 一个例子说明渲染逻辑：
```ts
const [ticker, setTicker] = useState("AAPL");
...
const onChange = event => {
   setTicker(event.target.value);
}
...
```

useState语句返回一个状态值（‘ticker’）和一个更新相应状态值的setter函数（‘setTicker’）。

当组件第一次被渲染时，‘ticker’值将是参数中指定的默认值（即’AAPL’）。

当一个新的ticker在下拉菜单中被选中时，onChange函数会被调用。这个函数使用setter函数更新状态值。 这个状态的变化触发了重新渲染 --再次调用TickerComponent函数来执行。但这次 "useState(‘AAPL’) "返回之前由setter函数设置的ticker值。这就像React将状态存储在一个与我们组件实例相联系的隐藏的数据存储器中。最新的状态值被保留下来，并在重读时返回。如果该组件被卸载并重新挂载，那么一切都会重新开始。

## setState
为什么didMount生命周期里setState按理应该两次渲染，但实际看不到两次渲染的闪烁，要先理解setState的逻辑。

网上有很多文章称 setState 是『异步操作』，所以导致 setState 之后并不能获取到最新值，其实这个观点是错误的。setState 是一次同步操作，只是每次操作之后并没有立即执行，而是将 setState 进行了缓存，mount 流程结束或事件操作结束，才会拿出所有的 state 进行一次计算。如果 setState 脱离了 React 的生命周期或者 React 提供的事件流，setState 之后就能立即拿到结果。

暂且把这种异步称为伪异步。
setState 只在合成事件和钩子函数中是“伪异步”的，在原生事件和 setTimeout 中都是同步的。
setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然你可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。



## componentDidMount
官方文档对于 componentDidMount 的解释

> componentDidMount在组件挂载之后运行。如果立即（同步）设置 state，那么React就会触发一次额外的render，并将第二个render的响应用作初始UI，这样用户就不会看到闪烁。
> componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。
> 这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅
> 你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理。

这里面比较重要的两句话是这两句： 
1. componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用
2. 额外渲染会发生在浏览器更新屏幕之前

第一句话是什么意思呢？就是说当我们的组件被插入到 DOM 树之后，就会执行 componentDidMount 生命周期。那第二句话是什么意思呢？这句话是说如果我们在 componentDidMount 里面调用了 setState , 会触发一次额外渲染, 也就是说会再走一次 render 流程，但是这个过程会发生在用户界面更新之前。

仔细一想，这两句话好像有点冲突？你又和我说这个组件被插入到 DOM 树之后才会执行 componentDidMount, 又和我说我重新 setState 会发生在用户界面更新之前？？组件被插入到DOM树不就代表着用户界面已经更新了吗？
其实不然，因为浏览器的js线程和渲染线程是互斥的，所以js同步执行的时候渲染线程是没办法去渲染用户界面的，即使我们的内容修改已经同步到了DOM中。

所以 react 的 componentDidMount 和这个是一个道理，componentDidMount 中去重新 setState 的时候，也就是说会立刻进行一次 rerender , setState其实仍然是同步代码，此时js线程仍然被占用。在这个时候我们上一次的内容其实已经到了DOM中，但是渲染线程无法渲染内容到用户界面上，所以用户看不见任何东西。

```
import React from 'react';

function requestData() {
  const now = Date.now();

  while(Date.now() - now <= 2 * 1000) {};

  return 'after componentDidMount data';
}
class App extends React.Component {
  state = {
    data: 'init data'
  }
  componentDidMount() {
    this.setState({
      data: requestData()
    })
  }
  render() {
    return (
      <div>
        <div>App</div>
        <div>{this.state.data}</div>
      </div>
    )
  }
}

export default App;
```
上述代码模拟了下请求数据的操作，didmount中请求数据耗费两秒，会先展示init data再展示after componentDidmount data吗？
实际上只会一个空白结果2秒后（生命周期函数会阻塞渲染，时间拉长页面会一直空白直到操作完成）展示App after componentDidmount data，这是因为js阻塞了渲染所导致的，我们知道这时候虽然界面没有显示，但其实已经挂载到了dom中，所以应该可以拿到init data。

那么自从react hooks出来之后函数组件已经变得非常常见了，而useEffect也是使用频率非常高的一个hooks，我们平时可能就会将它类比为componentDidMount, 其实这两个并不是完全相等的，从我们刚刚的例子可以知道，componentDidMount其实会阻塞页面渲染，但是useEffect是一个真正异步执行的过程（把useEffect看成一个请求），也就是说会在真正渲染完成之后执行，并不会阻塞渲染。真正和componentDidMount等效的是useLayoutEffect，它和componentDidMount一样也会阻塞渲染。

所以，componentDidMount 其实是一个会阻塞渲染的生命周期，我们在这里面最好不要去执行一些非常耗时的逻辑，这样会让我们的首屏出现的更慢。


### didmount中使用dom操作
已经遇到过很多次的问题，在didmount中直接使用dom操作，querySelector，必须将选择器书写完整，querySelector选择了一个元素后在用.chilren[]的常规方式是拿不到子元素的，显示undifined。

------- 

注意以上都是旧版的legacy模式同步更新方式下。

react后续启用了concurrent模式，fiber架构。

Concurrent 模式说白就是让组件更新异步化，切分时间片，渲染之前的调度、diff、更新都只在指定时间片进行，如果超时就暂停放到下个时间片进行，中途给浏览器一个喘息的时间。

浏览器是单线程，它将 GUI 描绘，时间器处理，事件处理，JS 执行，远程资源加载统统放在一起。当做某件事，只有将它做完才能做下一件事。如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化，一些 DOM 操作，内部也会对 reflow 进行处理。reflow 是一个性能黑洞，很可能让页面的大多数元素进行重新布局。

浏览器的运作流程: 渲染 -> tasks -> 渲染 -> tasks -> 渲染 -> ....

这些 tasks 中有些我们可控，有些不可控，比如 setTimeout 什么时候执行不好说，它总是不准时；资源加载时间不可控。但一些JS我们可以控制，让它们分派执行，tasks的时长不宜过长，这样浏览器就有时间优化 JS 代码与修正 reflow ！

总结一句，就是让浏览器休息好，浏览器就能跑得更快。

