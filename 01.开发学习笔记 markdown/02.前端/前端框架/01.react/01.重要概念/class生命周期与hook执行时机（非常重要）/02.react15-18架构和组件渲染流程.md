理解react更新渲染步骤必须从[架构](https://react.iamkasong.com/process/doubleBuffer.html)入手。

## React15架构
react15架构分为两层：
reconciler（协调器），负责找出变化的组件 （需要深刻理解的过程）
renderer（渲染器），负责将变化的组件渲染到页面上（真正的执行由reactDOM.render来做 由开发者写的代码其实都是描述如何构建虚拟dom树 react16开始叫fiber树）

### Reconciler（协调器）构建虚拟DOM
我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。

每当有更新发生时，Reconciler会做如下工作：

1. 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
2. 将虚拟DOM和上次更新时的虚拟DOM对比
3. 通过对比找出本次更新中变化的虚拟DOM
4. 通知Renderer将变化的虚拟DOM渲染到页面上

### Renderer（渲染器）将虚拟DOM映射到真实DOM通知浏览器执行绘制
由于React支持跨平台，所以不同平台有不同的Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer —— ReactDOM (opens new window)。

除此之外，还有：

1. ReactNative渲染器，渲染App原生组件
2. ReactTest渲染器，渲染出纯Js对象用于测试
3. ReactArt渲染器，渲染到Canvas, SVG 或 VML (IE8)
在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。

### React15架构的缺点
在Reconciler中，mount的组件会调用mountComponent ，update的组件会调用updateComponent。这两个方法都会递归更新子组件。
由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16.7ms(浏览器的一帧)，用户交互就会卡顿。

一个例子：初始化时state.count = 1，每次点击按钮state.count++，列表中3个li元素的值分别为1，2，3乘以state.count的结果。
递归更新子组件，Reconciler发现第一元素1需要变成2，构建虚拟DOM，通知Renderer更新DOM 第一个元素由1到2，发现第二元素2需要变成4，构建虚拟DOM，通知Renderer更新DOM 第一个元素由2到4。。。
总之，Reconciler和Renderer是交替工作的，当第一个li在页面上已经变化后，第二个li再进入Reconciler。由于整个过程都是同步的无法被打断，当所有虚拟DOM更新完毕后，Renderer统一将虚拟DOM映射到真实DOM，js交出线权，通知渲染引擎执行页面绘制，所以在用户看来所有DOM都是同步更新的，没有出现三个子元素依此更新的异常。但是唯一的问题就是当递归更新时间超长，渲染必定卡顿。

解决办法——用可中断的异步更新代替同步的更新。15无法支持，于是有了react16的重大升级。


## React16架构
React16架构可以分为三层：

Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler
Reconciler（协调器）—— 负责找出变化的组件
Renderer（渲染器）—— 负责将变化的组件渲染到页面上
可以看到，相较于React15，React16中新增了Scheduler（调度器），让我们来了解下他。

### Scheduler（调度器）Scheduler是独立于React的库
既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。

其实部分浏览器已经实现了这个API，这就是requestIdleCallback。但是由于以下因素，React放弃使用：

1. 浏览器兼容性
2. 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低

基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。

### Reconciler（协调器）
我们知道，在React15中Reconciler是递归处理虚拟DOM的。让我们看看React16的Reconciler (opens new window)。
Reconciler内部采用了Fiber的架构。

我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。
```js
/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```
那么React16是如何解决中断更新时DOM渲染不完全的问题呢？

在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：
```js
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```
整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

### Renderer（渲染器）
Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。

所以在react16中执行一次状态更新，如点击button让count由1变成2。
scheduler接收到更新，先判断有没有其他高优先级更新需要执行，没有其他更新，则将状态变化1到2交给reconciler。
reconciler接收到更新，比对虚拟DOM，将需要更新的虚拟DOM打上update delete等标记，虚拟DOM完全是在内存中操作的一个对象，标记完成后将打了标记的虚拟DOM交给renderer。
renderer接收到通知，根据标记后到虚拟DOM执行DOM操作，js交出线权，交给渲染引擎绘制页面。

注意最重要的一点就是scheduler和renconciler打标记是可以随时打断的：
1. 有其他高优先级任务需要先更新
2. 当前帧16.7ms没有剩余时间了

由于scheduler和reconciler的工作结果完全是在内存之中，即使反复中段用户也不会看见更新不完全的DOM。其实react15的递归更新虚拟DOM交替执行reconciler和renderer的方式也不会造成不完全的DOM，因为虽然通知了renderer，但是整个递归更新子元素的过程无法中断，js引擎一直掌握线权，页面在整个递归完毕前一直无法更新绘制。


从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。

### fiber
异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。

其实，浏览器原生就支持类似的实现，这就是Generator。但是Generator的一些缺陷使React团队放弃了他：
类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。
Generator执行的中间状态是上下文关联的。

代数效应与Fiber：
Fiber并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。
在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。
所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。
React Fiber可以理解为：React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。
其中每个任务更新单元为React Element对应的Fiber节点。

react16中虚拟DOM在react中有个正式的称呼 fiber。

在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。

为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。

Fiber是react16大更新后对虚拟dom更新时协调器的工作的称呼。
Fiber架构将不可中断的递归更新变为了可中断更新。

React Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 维护每一个分片的数据结构，就是Fiber。 
Fiber要解决的问题： 
（1）能够将可中断的任务拆分成块。 
（2）能够对进程中的工作划分优先级、重新设定基址（Rebase）、恢复。
（3）能够在父子之间来回反复，借此为 React 的 Layout 提供支持。
（4）能够通过 render() 返回多个元素。 
（5）为错误边界提供了更好的支持。

#### Fiber的含义
Fiber包含三层含义：
作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。
作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

#### Fiber工作原理

##### 什么是“双缓存”
当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。

如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。

为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。

这种在内存中构建并直接替换的技术叫做双缓存 。

##### 双缓存Fiber树
React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。

在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树存在于**render阶段**，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。

已构建完的workInProgress Fiber树在**commit阶段**渲染到页面。workInProgress Fiber树被切换成current Fiber树。

current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。

React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。

即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。

每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。

在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，决定是否复用的算法就是diff。


-------

# render阶段和commit阶段（结合生命周期的流程图来看本节）

有了之前大段的架构铺垫终于到了render和commit阶段的解释。在render阶段，在内存中构建workInProgress Fiber树。在commit阶段将已完成构建的workInProgress Fiber树从reconciler提交到renderer，并由renderer映射到真实dom，执行dom操作，由渲染引擎渲染到页面。同时将workInProgress Fiber树通过current指针切换成current Fiber树。

react组件渲染分2个阶段 render和commit。

render阶段：Scheduler和reconciler工作，调和对比构建fiber树。

commit阶段：renderer工作（浏览器环境时reactDOM），根据fiber树的tag执行DOM操作，映射真实DOM。更新DOM（如果需要得话）
            细分三个阶段：before mutation；mutation；layout。

## render阶段
render阶段的工作是在内存中进行，当工作结束后会通知Renderer需要执行的DOM操作。我们知道，render阶段的工作是在内存中进行，具体就是为fiber树打tag，
插入DOM节点（Placement）
更新DOM节点（Update）
删除DOM节点（Deletion）
当工作结束后会通知Renderer需要执行的DOM操作。要执行DOM操作的具体类型就保存在**fiber.effectTag**中。
**除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。**

render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。

我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：
```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

可以看到，他们唯一的区别是是否调用**shouldYield**。如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历。这就是concurrent模式的异步的可中断更新。

`workInProgress`代表当前已创建的`workInProgress fiber`树。
`performUnitOfWork`方法会创建下一个Fiber节点并赋值给`workInProgress`，并将`workInProgress`与已创建的Fiber节点连接起来构成Fiber树。
我们知道Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。

### “递”阶段
首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用[beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法。

该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。

当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。

组件执行beginWork后会创建子Fiber节点，节点上可能存在effectTag。

### “归”阶段
在“归”阶段会调用[completeWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理Fiber节点。

和beginWork一样，completeWork根据current === null ?判断是mount还是update。当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：onClick、onChange等回调函数的注册，处理style prop，处理children prop。

当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。

如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。

“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。

在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为**effectList**的单向链表中。effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。
除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。

注意这里的effect和react提供的effect hook并不是一个概念 有点复杂。

## commit阶段（重点 此处涉及到页面何时出现用户可感知的变更，并且执行一些生命周期和effect）
commitRoot方法是commit阶段工作的起点。fiberRootNode会作为传参。 `commitRoot(root);`

在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props。这些effect（不习惯这个词 或许叫修改好理解点）对应的DOM操作在commit阶段执行。

除此之外，在commit阶段会触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）

commit阶段的主要工作（即Renderer的工作流程）分为三部分：before mutation；mutation；layout。

**在before mutation阶段之前和layout阶段之后**
有一些额外工作，涉及到比如useEffect的触发、优先级相关的重置、ref的绑定/解绑。这些对我们当前属于超纲内容，为了内容完整性，先简单介绍。
before mutation之前主要做一些变量赋值，状态重置的工作。们只需要关注最后赋值的**firstEffect**，在commit的三个子阶段都会用到他。

layout之后主要包括三点内容：
useEffect相关的处理。
性能追踪相关。
触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）


**before mutation(操作dom前)**
before mutation阶段的代码很短，整个过程就是遍历effectList并调用commitBeforeMutationEffects函数处理。
```js
function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      // ...focus blur相关
    }

    const effectTag = nextEffect.effectTag;

    // 调用getSnapshotBeforeUpdate
    if ((effectTag & Snapshot) !== NoEffect) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }

    // 调度useEffect
    if ((effectTag & Passive) !== NoEffect) {
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
         // 触发useEffect
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```
这个函数主要做的事情：
1. 处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。
2. 调用**getSnapshotBeforeUpdate**生命周期钩子。
3. **调度useEffect**。

（严格来说这是precommit阶段 可以读取dom）: 调用类组件生命周期函数getSnapshotBeforeUpdate(prevProps, prevState),并且把旧的props和旧的states传递进去。getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题。

调度useEffect：scheduleCallback方法由Scheduler模块提供，用于以某个优先级异步调度一个回调函数。
在此处，被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects。（这里非常重要非常巧妙，之前对react16fiber架构的解释详细介绍了scheduler和reconciler配合工作，这里以scheduleCallback异步调度这个任务就是在本次render commit结束之后插入了一个NormalSchedulePriority的任务，实现在每次渲染到页面后执行useEffect这个功能。）

跟着flushPassiveEffects我们可以找到最终调用 useEffect 的地方是 commitRootImpl ，所以就是在这里面对 useEffect 进行了调度，在完成渲染工作以后去异步执行了 useEffect。

注意这里是调度了useEffect，而useEffect销毁函数和回调函数的调度在下面layout阶段讲解，这两个调度不是一个概念。

我们接下来讨论useEffect如何被异步调度，以及为什么要异步（而不是同步）调度。

如何异步调度？
在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。

在completeWork一节我们讲到，effectList中保存了需要执行副作用的Fiber节点。其中副作用包括
插入DOM节点（Placement）
更新DOM节点（Update）
删除DOM节点（Deletion）

除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。
在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

如果在此时直接执行，rootWithPendingPassiveEffects === null。
那么rootWithPendingPassiveEffects会在何时赋值呢？
在上一节**layout之后**的代码片段中会根据rootDoesHavePassiveEffects是否true决定是否赋值rootWithPendingPassiveEffects。
```js
// layout之后
// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}
```
整个useEffect异步调用分为三步：
before mutation阶段在scheduleCallback中调度flushPassiveEffects
layout阶段之后将effectList赋值给rootWithPendingPassiveEffects
页面渲染完成之后scheduleCallback触发flushPassiveEffects，在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

为什么需要异步调用：
文档介绍：与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。
可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。

**mutation阶段（执行dom操作）**：获取对象的effects 根据不同的effectTag执行不同的操作，插入、更新、删除。将workInProgress fiber树变成current Fiber树。
插入节点： commitPalcement
更新节点：commitWork
删除节点：commitDeletion

类似before mutation阶段，mutation阶段也是遍历effectList，执行函数。这里执行的是commitMutationEffects
commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作：
根据ContentReset effectTag重置文字节点
更新ref
根据effectTag分别处理，其中effectTag包括(Placement | Update | Deletion | Hydrating)。我们关注步骤三中的Placement | Update | Deletion。Hydrating作为服务端渲染相关，我们先不关注。

这里就是一些具体的dom操作了。 先不做详细理解。

Placement effect：意味着该Fiber节点对应的DOM节点需要插入到页面中。调用的方法为commitPlacement。

Update effect：当Fiber节点含有Update effectTag，意味着该Fiber节点需要更新。调用的方法为commitWork，他会根据Fiber.tag分别处理。
主要关注在这个类型度tag下，当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有**useLayoutEffect hook的销毁函数**（这也是hook中每次渲染先执行上一个销毁函数再执行effect的逻辑）。你不需要很了解useLayoutEffect，我们会在下一节详细介绍。你只需要知道在mutation阶段会执行useLayoutEffect的销毁函数。

Deletion effect：当Fiber节点含有Deletion effectTag，意味着该Fiber节点对应的DOM节点需要从页面中删除。调用的方法为commitDeletion。
该方法会执行如下操作：
递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount 生命周期钩子，从页面移除Fiber节点对应DOM节点
解绑ref
**调度useEffect的销毁函数**


**layout阶段（执行dom操作之后）**：
该阶段之所以称为layout，因为该阶段的代码都是在DOM渲染完成（mutation阶段完成）后执行的。
该阶段触发的生命周期钩子和hook可以直接访问到已经改变后的DOM，即该阶段是可以参与DOM layout的阶段。（前两个阶段其实对生命周期和hook已经做了一些准备工作）

与前两个阶段类似，layout阶段也是遍历effectList，执行函数。
具体执行的函数是commitLayoutEffects。主要工作为“根据effectTag调用不同的处理函数处理Fiber并更新ref。
commitLayoutEffects一共做了两件事：
commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）
commitAttachRef（赋值 ref）代码逻辑很简单：获取DOM实例，更新ref。

commitLayoutEffectOnFiber方法会根据fiber.tag对不同类型的节点分别处理。（commitLayoutEffectOnFiber为别名，方法原名为commitLifeCycles）

对于ClassComponent，他会通过current === null?区分是mount还是update，调用**componentDidMount** 或**componentDidUpdate**
**触发状态更新的this.setState如果赋值了第二个参数回调函数**，也会在此时调用。

对于FunctionComponent及相关类型，他会**调用useLayoutEffect hook的回调函数**，**调度useEffect的销毁与回调函数**。

```js
  switch (finishedWork.tag) {
    // 以下都是FunctionComponent及相关类型
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // 执行useLayoutEffect的回调函数
      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      // 调度useEffect的销毁函数与回调函数 注意这里调度的是useEffect的两个函数
      schedulePassiveEffects(finishedWork);
      return;
    }
```
先useLayoutEffect后useEffect，其实这里代码顺序也无所谓先后，before mutation阶段解释过useEffect的前期准备工作，schedulePassiveEffects的调用是一个异步调用。这个函数作用是从函数组件对应的 fiber 上获取上面挂载的 effect，然后将 effect 和 fiber 推到 pendingPassiveHookEffectsUnmount 和 pendingPassiveHookEffectsMount 这个两个队列中。
```js
function schedulePassiveEffects(finishedWork: Fiber) {
  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      const {next, tag} = effect;
      if (
        (tag & HookPassive) !== NoHookEffect &&
        (tag & HookHasEffect) !== NoHookEffect
      ) {
        // 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        // 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }
      effect = next;
    } while (effect !== firstEffect);
  }
}
```

结合之前before mutation提到的scheduleCallback中调度flushPassiveEffects，在layout阶段之后将effectList赋值给rootWithPendingPassiveEffects，渲染完成后执行useEffect的销毁函数和回调函数。
```js
// layout之后
// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}
```

这里dom操作已经完成，可以取到dom信息做一些effect修改。

注意useLayoutEffect的销毁函数是在mutation阶段Update effectTag类型时调用的。
结合这里我们可以发现，useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。

而useEffect则需要先调度，在Layout阶段完成后再异步执行。这就是useLayoutEffect与useEffect的区别。

对于useEffect的销毁函数和回调函数，调用上一次render的销毁函数，调用本次render的回调函数。
在v16中第一版是同步执行的，在官方博客中提到：
副作用清理函数（如果存在）在 React 16 中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。
基于这个原因，在v17.0.0中，useEffect的两个阶段会在页面渲染后（layout阶段后）异步执行。
事实上，从代码中看，v16.13.1中已经是异步执行了。

useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。
这是因为多个组件间可能共用同一个ref。

如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。

在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。

所以useEffect执行分两个阶段，销毁函数的全部执行和回调函数的全部执行。

layout阶段通过schedulePassiveEffects调度useEffect的销毁函数和回调函数，从函数组件对应的 fiber 上获取上面挂载的 effect，然后将 effect 和 fiber 堆到 pendingPassiveHookEffectsUnmount 和 pendingPassiveHookEffectsMount 这个两个队列中。

在阶段一，会遍历并执行所有useEffect的销毁函数。
```js
// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect
const unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];
  for (let i = 0; i < unmountEffects.length; i += 2) {
    const effect = ((unmountEffects[i]: any): HookEffect);
    const fiber = ((unmountEffects[i + 1]: any): Fiber);
    const destroy = effect.destroy;
    effect.destroy = undefined;

    if (typeof destroy === 'function') {
      // 销毁函数存在则执行
      try {
        destroy();
      } catch (error) {
        captureCommitPhaseError(fiber, error);
      }
    }
  }
```
在阶段二，会遍历并执行所有useEffect的回调函数。
```js
// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect
const mountEffects = pendingPassiveHookEffectsMount;
pendingPassiveHookEffectsMount = [];
for (let i = 0; i < mountEffects.length; i += 2) {
  const effect = ((mountEffects[i]: any): HookEffect);
  const fiber = ((mountEffects[i + 1]: any): Fiber);
  
  try {
    const create = effect.create;
   effect.destroy = create();
  } catch (error) {
    captureCommitPhaseError(fiber, error);
  }
}
```


整个layout阶段逻辑就是这些。
注意到current Fiber树切换代码是在layout阶段的第一行。
在双缓存机制一节我们介绍过，workInProgress Fiber树在commit阶段完成渲染后会变为current Fiber树。这行代码的作用就是切换fiberRootNode指向的current Fiber树。

那么这行代码为什么在这里呢？（在mutation阶段结束后，layout阶段开始前。）

我们知道componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的。componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的。

要注意到，mutation阶段构建了新的dom树，layout阶段的componentDidMount之前其实只是完成了渲染树，执行了一些生命周期和effect，最终渲染树定型，这时候所有数据有了，但是控制权还在js线程手中，这时候在componentDidMount中执行setState或者其他一些dom修改，最后浏览器只会保留最终的结果，layout之后应当就是paint，将控制权交给渲染线程，渲染线程根据document，完成屏幕真正的绘制工作。

