# 虚拟DOM 
高效的DOM Diff算法， 最小页面重绘
实际上虚拟dom的价值并不在于性能的提升，而是作为一个手段去实现：声明式 基于数据（状态）来驱动UI的开发方式。

实现原理主要包括以下 3 部分：
用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
diff 算法 — 比较两棵虚拟 DOM 树的差异；
pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。


先看正常渲染步骤：
1. state 数据
2. jsx模板
3. 数据 + 模板 生成真实的DOM 来显示 挂载到DOM上
4. state 发生改变
5. render函数重新执行 数据 + 模板 结合 生成真实的DOM 替换原始的DOM

缺陷：
两次都生成了完整的DOM
非常的耗费性能

改进：
1. state数据
2. jsx模板
3. 数据 + 模板 生成真实的DOM 来显示 挂载到DOM上
4. state 发生改变
5. 数据 + 模板 结合 生成真实的DOM 并不直接替换原始的DOM
6. 新的DOM 和原始DOM作比对， 找差异 只替换变化的部分

改进了一部分性能 但是又增加了一部分比对的性能  性能提升不明显

react 虚拟DOM：
1. state 数据
2. jsx模板
3. 数据 + 模板 生成虚拟DOM （虚拟DOM就是一个JS对象， 用它来描述真实的DOM  可以把它当成一个数组一样的对象 ）（损耗极低性能
`<div id = "abc"><span>hello world</span></div>`
['div',{id: 'abc'},['span',{},'hello world']]
4. 用虚拟DOM的结构生成真实的DOM 来显示
5. state 发生变化
6. 数据 + 模板 生成新的虚拟DOM （极大提升性能）
7. 比较原始虚拟DOM和新的虚拟DOM的区别， 找到区别是span中的内容 （极大提升性能）
8. 直接操作DOM，改变span的内容

所以其实组件内的render函数内return的类似html的标签其实是 模板 它结合state和props 的数据来生成：虚拟DOM（js对象）
再根据虚拟DOM（js对象）生成真实DOM

优点： 性能提升 且 使得跨端应用得以实现 React Native

JSX-> createElement -> 虚拟DOM（JS对象） -> 真实的DOM

所以
```
render(){
  return(
  <div>item</div>
  )
}
```

等价于
```
render(){
  return React.createElement('div', {}, 'item');  // 对应：标签 属性 内容
}
```


### 虚拟 DOM 的优缺点？

#### 优点：
保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

#### 缺点:
无法进行极致优化性能（rerender的粒度问题）： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。

### diff
在虚拟DOM的介绍 第七项流程
7. 比较原始虚拟DOM和新的虚拟DOM的区别， 找到区别是span中的内容 （极大提升性能）

这里的比对是如何实现的？
diff算法  即difference

虚拟DOM的比对 是在state数据变化之后 需要改变DOM
其实是在setState方法调用之后
setState方法是异步的 是为了提升底层的性能
如果有多次的setState在极短时间内同时执行 为了提升性能 比对原始和新的虚拟DOM会集中在一次执行

DIff算法 ：
同层比较
第一层有差异 下面不再比 直接替换

key值的概念：
在循环一层层比对时， 为了比较一一对应 ，新旧的虚拟DOM树每个节点都应该有它自己的“名字”， 按同一名字一一比对
那么 这个唯一标识就key
key只在同级的兄弟节点之间有效，不同级的元素key是可以不一样的。
所以我们不能直接用list的index作为key值 用index后会导致key值不稳定 在增加删除节点后 每个节点的index都有可能发生变化 起不到标识的作用了 diff算法就失去了意义
