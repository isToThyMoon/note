
分解设计稿 划分组件或者层级
提取复用部分

将渲染 UI 和添加交互这两个过程分开。
这是因为，编写一个应用的静态版本时，往往要编写大量代码，而不需要考虑太多交互细节；添加交互功能时则要考虑大量细节，而不需要编写太多代码。所以，将这两个过程分开进行更为合适。


# react哲学
react官方文档中核心概念最后单独一节，介绍[react哲学](https://zh-hans.reactjs.org/docs/thinking-in-react.html)。主要内容就是介绍如何组织react代码，和基础的组件化使用。

## 自上而下和自下而上组件化
“你可以自上而下或者自下而上构建应用：自上而下意味着首先编写层级较高的组件，自下而上意味着从最基本的组件开始编写，当你的应用比较简单时，使用自上而下的方式更方便；对于较为大型的项目来说，自下而上地构建，并同时为低层组件编写测试是更加简单的方式。”

这两种都是组件化，

**“到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。”**

“通过 props 接受你的数据模型。如果你的数据模型发生了改变，再次调用 root.render()，UI 就会相应地被更新。数据模型变化、调用 render() 方法、UI 相应变化，这个过程并不复杂，因此很容易看清楚 UI 是如何被更新的，以及是在哪里被更新的。React 单向数据流（也叫单向绑定）的思想使得组件模块化，易于快速开发。”

“在 React 中，有两类“模型”数据：props 和 state。清楚地理解两者的区别是十分重要的；如果你不太有把握，可以参阅 [React 官方文档](https://zh-hans.reactjs.org/docs/state-and-lifecycle.html)。你也可以查看 [FAQ: state 与 props 的区别是什么？](https://zh-hans.reactjs.org/docs/faq-state.html#what-is-the-difference-between-state-and-props)”

在构建了UI模型之后，“想要使你的 UI 具备交互功能，需要有触发基础数据模型改变的能力。React 通过实现 state 来完成这个任务。” 需要开发者“确定 UI state 的最小（且完整）表示。”

“
通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。
”

## 数据模型（组件状态）
“已经确定了应用所需的 state 的最小集合。接下来，我们需要确定哪个组件能够改变这些 state，或者说拥有这些 state。”

“
注意：React 中的数据流是单向的，并顺着组件层级从上往下传递。哪个组件应该拥有某个 state 这件事，对初学者来说往往是最难理解的部分。尽管这可能在一开始不是那么清晰，但你可以尝试通过以下步骤来判断：

对于应用中的每一个 state：

找到根据这个 state 进行渲染的所有组件。
找到他们的共同所有者（common owner）组件（在组件层级上高于所有需要该 state 的组件）。
该共同所有者组件或者比它层级更高的组件应该拥有该 state。
如果你找不到一个合适的位置来存放该 state，就可以直接创建一个新的组件来存放该 state，并将这一新组件置于高于共同所有者组件层级的位置。
”

总结来说就是单独属于该组件的state由该组件自身把持，和其他组件共用的state应该寻找他们的父级组件来掌控该state，如果找不到合适的位置，应该新建一个组件作为高于共有者层级的父级，也就是**状态提升**。

如此子组件需要修改state时就要考虑反向数据流，“React 通过一种比传统的双向绑定略微繁琐的方法来实现反向数据传递。尽管如此，但这种需要显式声明的方法更有助于人们理解程序的运作方式。” 也就是子组件调用父组件传递来的可以修改state的回调函数。

如此结束。

-------

组件化、组件拆分和合并、解耦和复用等等是组织代码绕不开的问题。
react其实已经要求通过组件化的方式初步为前端编写页面提供了一层代码分割的参考方式，但这远远不够。

可以看出官方react哲学介绍中，
**“到此为止，你应该已经有了一个可重用的组件库来渲染你的数据模型。”**，
也是将数据模型和UI模型分离来帮你理解开发思想，

而react库，其实只是帮助你更好构建UI模型，并且从数据模型中声明式更新UI模型。

永远记得react对自己的定位，一个视图层library。
慢慢理解这一点，把UI层做薄。react其实只接管了之前需要我们通过命令式操作dom来完成页面UI修改的繁重工作。它提出一种新的前端页面开发思想，声明式组件化开发，以数据驱动UI变更，也就是UI = f(state)。

-------

# props 和state区别？ 

都是用来保存信息的，用来控制组件的渲染输出，props是传递给组件的（类似于函数的形参），而state是在组件内部被组件自己管理的。

TL；DR：
If a Component needs to alter one of its attributes at some point in time, that attribute should be part of its state, otherwise it should just be a prop for that Component.

When a component needs to keep track of information between renderings the component itself can create, update, and use state.

props contains information set by the parent component (although defaults can be set) and should not be changed.state contains “private” information for the component to initialise, change, and use on it’s own.

Should this Component have state?

state is optional. Since state increases complexity and reduces predictability, a Component without state is preferable. Even though you clearly can't do without state in an interactive app, you should avoid having too many Stateful Components.

Stateless Component — Only props, no state. There's not much going on besides the render() function and all their logic revolves around the props they receive. This makes them very easy to follow (and test for that matter). We sometimes call these dumb-as-f*ck Components (which turns out to be the only way to misuse the F-word in the English language).

纯props提供数据模型，没有自身state的组件，react称之为无状态组件，官方是推崇这种组件的，易于跟踪数据流，测试用例编写简单，只要能写无状态组件，那一定是首选。

Stateful Component — Both props and state. We also call these state managers. They are in charge of client-server communication (XHR, web sockets, etc.), processing data and responding to user events. These sort of logistics should be encapsulated in a moderate number of Stateful Components, while all visualization and formatting logic should move downstream into as many Stateless Components as possible.

其实就是容器组件和UI组件的分别。
有状态的组件（容器组件）没有渲染，有渲染的组件（UI组件）没有状态。
展示组件+容器组件这样的实践一直都是社区提倡的最佳实践，这样的模式有几个好处：

更好的关注分离：
关注点分离是一个在编程中广泛使用的概念。它指的是执行不同操作的逻辑不应被分组或结合在一起。例如我们把获取数据和展示数据放在了同一个组件中就违反了关注点分离。

若要解决这个问题，并且遵循关注点分离，我们应该将两块（即：获取数据和在 UI 上展示）逻辑分开放置在不同的组件。

更好的复用性：
展示和容器分离能达到更好的复用性（HOC一直倡导的容器组件和UI组件分离），相同的展示组件可以同不同的状态组合在一起进一步转化成可复用的容器组件。也就是带状态的逻辑复用方案。

react hook自定义hook实现了对容器组件/UI组件分离方案的替代。


-------






为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 DRY: Don’t Repeat Yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。

通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

1.该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
2.该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
3.你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。


# 编程的本质
编程的本质是 数据结构+算法，而任何的算法应当分成两个部分，logic+control
logic指真正意义上的算法
control部分只是影响解决问题的效率