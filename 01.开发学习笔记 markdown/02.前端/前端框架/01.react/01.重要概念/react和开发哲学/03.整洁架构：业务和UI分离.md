# 一些关注点：

> 架构整洁：业务逻辑和UI逻辑混杂（antd+ahooks） 还是 业务逻辑和UI逻辑完全分离
> 视图方案： react class组件（面向对象OOP） 还是 hooks函数式组件（函数式FP）
> 响应原理： react原生发布订阅（包括redux） 还是 mobx代理模式
> 模型风格： 面向对象OOP 还是 函数式FP
> 类型系统： js 还是 ts（基本没什么疑问）

更深层级的分离：逻辑/数据/视图分离，reducer/store/UIComponent

# hooks主流开发中遇到的问题
1. 每个组件都有一串state，同时也有接收props，两种数据模型混杂，容器组件和UI组件不分离
2. useEffect滥用，业务逻辑大量用useEffect完成
3. 大量将useEffect当watch来使用，监控到状态变化时执行effect，到处是忍者依赖，一个业务逻辑跨多个useEffect完成
4. useEffect滥用带来的长依赖数组，难以理清执行的逻辑
5. useMemo和useCallback问题同上，长依赖数组

这些问题的都是用 hooks 来实现业务逻辑。
> 那么就是业务逻辑依赖了视图数据，也就是原因依赖了结果，这必然是错误的，是一种根源性的错误，如果状态保存在视图组件里，而不是脱离视图的模型里，那也是模型依赖了视图，这又是一个根源性的错误。如果业务逻辑需要视图组件的渲染才能生效，这又是逻辑依赖了视图，原因依赖了结果，这还是一个根源性的错误。只有react的话，你做什么都是错的，因为react社区的绝大多数基于组件的生态都是错的。这不是因为react hooks本身是错的，而是把视图组件当成最基本的元素的这种思路是错的。简体中文前端社区有「相当一大部分」走在错误的路线上。走在正确路线上的：redux 及其生态圈（部分），mobx 及其生态圈，angular及其生态圈，一些纯视图组件（react-virtualized, react-beautiful-dnd）。走在错误路线上的：antd dva ahooks acro-design react-router（大错特错）

> url 的用途：1. 复制粘贴出去回来定位。2. 浏览器前进后退。
> 这两个用途，都是业务逻辑，都应该是 model 的表现，也就是说，只存在
> 1. 从 model 向 url 同步所需的初始化参数
> 2. 首次进入页面或浏览器前进后退时，解析初始化参数
> 而 react-router 所做的是：
> 1. url 影响视图，意味着需要走 model -> url -> view 的数据流，中间这一步是繁琐而没必要的。
> 2. 通过 url 变化来影响视图 view -> url -> view，同时再把数据同步给 model。
> 这两个数据流都是错误的，正确的应该是
> 1. view -> model -> view
> 2. history(push/pop/open) -> model.init -> view
> 3. model -> url 单向同步

# intro
react自开始hook时代，各种优缺点的讨论，各种不同书写代码方式的讨论，各种最佳实践的辩论，
数据和UI视图分离得到大部分人的赞同，而最主要的、绝大部分分歧的根源都是：“在使用了前端框架如react开发项目时，你的业务逻辑代码写在哪儿，如何组织你的业务代码。”
用整洁架构的知识来表述，“业务逻辑和UI逻辑要不要完全分离。”

1.数据模型(Data model)；指业务数据该如何持久化，以及数据之间的关系，即：传统的ER模型；数据模型存在于数据层。
2.业务模型(领域模型：Domain model):指业务逻辑中，相关联的；数据如何联动协同；领域模型存在于领域层；
3.UI模型：负责界面和交互

class 做领域模型的描述
function 做数据流的抽象

在日常开发中，怎样确认某个功能或者状态是属于 UI 还是业务逻辑呢？只需要问自己，这个功能/状态在产品的 Shell 版 / Open API 版本中是否有必要存在就可以了。举一个例子，你用 React 写了一个计算器，合理情况下，即使要把这个计算器改为能在 Shell 中运行，你的业务逻辑（1 + 1 = 2）也应该是不变的。例如说要实现“查找并高亮”这个功能，显然查找是底层的业务逻辑，因为在各个平台/版本都可以进行查找，而高亮是一个偏 UI 的事情。所以，简单来说，这个功能从上到下应该这么划分：

UI 表现层
渲染一个输入框，允许用户输入内容，并进行查找注意这里查找是调用 props 上的 onSearch，该组件并不负责查找相关的任何逻辑，哪怕是对内容的 trim 这样的逻辑。组件里负责的顶多是 UI 状态相关的逻辑，例如用户点击确定时，如果输入框为空，则进行闪烁提示这种纯 UI 逻辑。内容区展示高亮实现方式是外部传递进来一个 highlight 的 props，内容区负责将其展示出来。

业务逻辑层提供查找并高亮的能力实现方式为将内容处理（trim 等）后，调用 Use Case 层的查找能力，然后将查找结果转换为高亮信息，并通知上面的 UI 表现层。更高级一点，查找和高亮其实也是完全可以解耦的，可以提供一个高亮模块，任何业务只需要调用就可以在内容区进行高亮。

用例层
提供纯粹的查找能力，并不关心是谁发起的查找，也不关心查找后要干嘛

数据层
提供数据模型

所以我们看到，UI 层其实只是个工具人，负责将用户的输入发送给业务内部，并将业务内部返回的结果展示给用户，这也正是最纯粹的 View。在这种设计下，你想把 React 换成 Vue，或者 DOM 换成 Canvas 简直轻而易举，只需要改动替换 UI 表现层，基本上就是重新写下UI组件就好了。

# 整洁架构：业务逻辑和UI逻辑混杂（antd+ahook） 还是 业务逻辑和UI逻辑完全分离

https://michel.codes/
https://staltz.com/blog.html

TL；DR：整洁架构思想：依赖方向应该由不稳定指向稳定，而UI相对其他业务逻辑一定是最不稳定的（所谓的不稳定就是更容易变化，最容易修改），所以如果任何逻辑是一定要让UI先完成让组件先渲染出来（useEffect一轮渲染后作为副作用去执行一些业务逻辑），那一定是错的，无需更多讨论。所以永远不要用react提供的功能去实现一些业务逻辑。（用hook去封装业务逻辑）

具体实战场景中，例如有一天你的项目要因为政治原因或者保密特性或者业务变更就要这么做：从react迁移到vue，或者从DOM方案转移为canvas方案。如果你的业务逻辑和react强绑定，那么迁移等于重写。但如果你的业务逻辑和UI是分离的，UI层非常薄，它作用就是拿数据->做渲染，那么你就可以直接复用以前的业务逻辑，不做任何修改，只需要重写消费数据的UI层就可以了。《架构整洁之道》里有句话：“UI只是实现细节”。


## 整洁架构模型
![](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2022-12-19%20%E4%B8%8A%E5%8D%889.49.27.png)

“
**业务实体**这一层中封装的是整个系统的关键业务逻辑， 一个业务实体既可以是一个带有方法的对象，也可以是一组数据结构和函数的集合。无论如何，只要它能被系统中的其他不同应用复用就可以。

**用例层**中通常包含的是特定应用场景下的业务逻辑，这里面封装并实现了整个系统的所有用例。这些用例引导了数据在业务实体之间的流入／流出，并指挥 着业务实体利用其中的关键业务逻辑来实现用例的设计目标。

我们既不希望在这一层所发生的变更影响业务实体，同时也不希望这一层受外部因素（譬如数据库、UI、常见框架）的影响。用例层应该与它们都保持隔离。

然而，我们知道应用行为的变化会影响用例本身，因此一定会影响用例层的代码。因为如果一个用例的细节发生了变化，这一层中的某些代码自然要受到影响。
...

**最外层的模型**层一般是由工具、数据库、 Web 框架等组成的 。在这一 层中， 我们通常只需要编写一些与内层沟通的勤合性代码 。

框架与驱动程序层中包含了所有的实现细节 。Web是一个实现细节，数据库也是一个实现细节。我们将这些细节放在最外层，这样它们就很难影响到其他层了。
...

同心圆分别代表了软件系统中的不同层次，通常越靠近中心，其所在的软件层次就越高。基本上，外层圆代表的是机制，内层圆代表的是策略。

当然这其中有一条贯穿整个架构设计的规则， 即它的依赖关系规则：源码中的依赖关系必须只指向同心圆的内层，由低层机制指向高层策略。

换句话说，就是任何属于内层圆中的代码都不应该牵涉外层圆中的代码，尤其是内层圆中的代码不应该引用外层圆中代码所声明的名字，包括函数、类、变量以及一切其他有命名的软件实体。

同样的道理，外层圆中使用的数据格式也不应该被内层圆中的代码所使用，尤其是当数据格式是由外层圆的框架所生成时。总之，我们不应该让外层圆中发生的任何变更影响到内层圆的代码。
”

-------


# UI逻辑和业务逻辑不分离的问题

不局限于react，当我们构建一个项目，或者编写一些组件，慢慢就会开始考虑项目、组件的可维护性和复用性。

前端开发总是从界面出发，看着稿子将页面和交互大致写出来后，再将产品文档里的业务逻辑映射成代码，加些判断加些处理加入写好的视觉交互代码中，最终交付项目。这里面就存在很大的问题。

随着业务逻辑的不断加入不断积累，每一个字段（状态）与其他字段之间的关联越来越复杂，处理函数也和字段高度耦合，随着字段和函数增多，组件越来越臃肿也越来越不敢修改，更不要说再react hook中写用useEffect来编写业务代码，甚至通过useEffect来当watch链式监听状态，代码更无法阅读。你担心更改一行代码就导致某个业务的崩溃。

不是说使用了前端框架是从命令式开发到声明式开发的飞跃吗？抛弃了繁杂的dom操作和细致的UI控制业务控制。
那么是什么导致了代码的不可维护？

一个主要原因就在我们的代码仍然同时承载了业务逻辑和UI逻辑。

```
export default (props)=>{
  const [count, setCount] = useState(0)
  //...
  const [codeChecked, setCodeChecked] = useState(false)
  const [code, setCode] = useState()

  useEffect(()=>{
    fetchCode((code)=>{
      setCode(code)
    })
  },[])

  handleSubmit = ()=>{
    // ....
      // 一大堆校验逻辑
      const data = { count }
      if (codeChecked) {
        data.code = code
      }
      // 提交数据
  }
  return (
    <div><input type="text" value={count} placehodler="数量"/></div>
    <div><input type="text" value={code} placehodler="优惠码"/></div>
    <div><input type="checkbox" value={code} onChange={()=>{ setCodeChecked((codeChecked)=>!codeChecked)}}/>使用优惠码</div>
    <button onClick={handleSubmit}>提交</button>

  )
}
```
比如一个购买车页面，里有一个checkbox控制是否选择优惠码，对于业务逻辑它是可选的，但对UI逻辑它是必须的，所以完成业务逻辑的其他状态字段如product price等等和完成UI构建等字段checked耦合在一起，而且在handlesubmit中，checked这个字段也成为了控制使用优惠券code是否提交的开关，这让业务逻辑完全和UI逻辑绑定，再后续的优化开发中，你也无法将这两者解开，这是写死的逻辑。

这种线性的开发逻辑随着业务的拓展，项目的迭代，会越来越难以维护，直到再难改一行。

这样的开发和维护越来越多，必然会慢慢意识到这两个概念，UI逻辑和业务逻辑。

什么是UI逻辑，什么又是业务逻辑？
UI逻辑，其实符合react框架对自己的描述，其实就是一个组件的样式和交互表现，接受数据展示UI输出。我们要把UI做薄。
业务逻辑，获取数据、操作数据等具有明确独特业务的逻辑。

一个简单的豆瓣书籍条目组件，该组件只要知道书籍封面url，书籍名，作者，出版社等等数据就可以正常工作，他不需要知道如何获取数据，数据中间如何处理，如何loading，这些业务逻辑应该在container层，也就是之前写react一些人提出的容器组件，它负责根据书籍id获取数据，判断请求状态，根据状态决定展示数据内容，将完成的数据传递给UI组件进行展示。

容器组件、UI组件，这也是react比较折中的UI和业务分离的模式。

# 容器组件/UI组件拆分 包含逻辑的状态复用方案
项目中目录根据组件和业务耦合程度来划分，和业务耦合程度越低复用性越强。这种UI/容器组件的拆分方式就是让UI组件只关注UI展示，容器组件，或者说业务组件只关注业务处理，容器组件组合UI组件来构建完整的视图页面。
UI组件：关注UI，数据源自props，纯函数组件
容器组件：关注业务逻辑，数据源自状态管理器

更激进的做法就是永远不要用react提供的功能去实现一些业务逻辑。（用hook去封装业务逻辑），业务逻辑应该是框架无关的，很多人在框架流行后有种一切都能用框架解决的错觉。又要提到react对自己的定位：一个视图层框架，你的业务如何编写，组件数据如何组织，它是不关心的。其实不管用什么框架，你的业务逻辑最终还是要用vanilla JS来实现的，那么业务逻辑完全和UI分离，甚至可以随意迁移框架就是理所当然的。

但想分离UI和业务没那么简单：
生命周期中包含请求代码，不好抽离。
组件内部有自己的state。

recompose库解决了一些问题，后来作者加入FB孵化出react hook解决包含逻辑的状态复用问题。实际上也是一种业务逻辑和UI逻辑的拆分。具体可见“包含逻辑的状态复用方案”一章节。有关于recompose和hooks分离业务逻辑和UI逻辑的介绍。根本上来说也是一种容器组件和UI组件拆分。

# hooks中分离业务和UI

一些问题：
1. 每个组件都有一串state，同时也有接收props，两种数据模型混杂，容器组件和UI组件不分离
2. useEffect滥用，业务逻辑大量用useEffect完成
3. 大量将useEffect当watch来使用，监控到状态变化时执行effect，到处是忍者依赖，一个业务逻辑跨多个useEffect完成
4. useEffect滥用带来的长依赖数组，难以理清执行的逻辑
5. useMemo和useCallback问题同上，长依赖数组

基于hooks的纯业务组件写法没有做约束，ui与业务逻辑在一个函数内部维护，面条式代码滋生，容易使组件业务逻辑代码越写越长，久而久之难以维护。很容易出现一个函数内部耦合了types，constants，各类hooks（useState，useReducer，useCallback等），以及各种function，甚至是在dom层夹杂着非常多的逻辑处理。慢慢地，复用性也会越来越差，可能需要经常重构，抽离代码以达到复用的程度。但往往业务的排期已经没法抽开身去维护老代码。

我们需要在团队内部达成共识，能够产出一种固定的开发范式，能够分离代码，做到职责清晰，例如：A模块专门处理View视图组件，B模块专门处理业务逻辑，C模块专门维护ts类型types，D模块专门维护各类常量constants，E模块专门维护公用hooks逻辑，F模块专门维护css modules等。那么，在这前提之下，我们需要实现前端UI与业务逻辑分离，目前主流的有两种方式，一种是纯逻辑抽离出去，返回函数内部方法和state；形如：
```
const useApp = () => {
   const [name, setName] = useState('mike');
   const getName = () => {};
   const updateName = () => {};
   return {
      name,
      getName,
      updateName
   }
}

const AppView =() => {
 const { name } = useApp();
 return <div>{name}</div>
}
```

甚至UI 和 API 一起暴露：
`const {list, nextPage, loading, error} = useUserList()`

把逻辑抽离出去，组件只负责订阅状态然后把 UI 渲染出来，组件彼此之间几乎不通信（至少不进行与逻辑相关的通信），而是都与 reducer 通信，各组件间没有通信成本，拆组件才可行且有意义。

这种方式没什么太大问题，但这种代码不内聚，没法提供通用的逻辑处理，一旦业务发生变化，就会引发多处代码的维护危机。其次如果有很多业务团队，那么就需要考虑如何规范化统一团队内部写法，如何支持更健壮的业务代码。
而且这种写法其实还是一种容器/UI的抽离方式，实现方式还是依赖react提供的api，这其实还是和整洁架构中低层级web UI依赖高层次业务实体相违背，这里还是业务实体依赖了UI。

UI与逻辑分离并不是最终的目的，最终的目的应该是形成一套易于维护，模块职责划分清晰，能够形成固定开发模式，易于扩展，能够规范化业务使用场景，且具备强壮生命力的方案。


-------

比较好的做法是从react组件中彻底分离出业务逻辑。业务逻辑的代码是UI无关的，它就是一组纯粹简单的class或者函数，除了lodash之类的工具包（相当于扩展语言能力）之外，几乎不import任何其他东西。这就是所谓的数据模型，model。它仅描述核心的业务规则，和你用react还是vue还是ng都没有任何关系，可以对接各种框架，甚至还可以跑在后端node里。

这时候react或vue部分就剩下薄薄的一层，最多只需要负责三件事：

1. 把model实例化并和dom联动：通过new或者工厂，构造出model数据，把这些数据响应式地映射到dom；根据dom事件，调用model里的函数或方法，来更新model数据。
 
2. （可选）集中维护model数据的缓存：以前大家用redux或mobx，大部分代码量都是在处理这个问题。现在有了react-query或swr这样的东西，这个工作已经大大简化了。
 
3. 处理纯页面状态：dom上有些状态不是从model数据里来的，是纯粹的页面状态，比如主题颜色啊、数据正在加载的标志啊，抽屉或手风琴的展开折叠啊，等等。这些和model无关，可能从桌面浏览器变到手机浏览器，或者变到electron本地程序，这些页面状态的设计就完全不同了，甚至完全没有了。

一个常见的误区是在react、vue组件或redux、mobx里直接调用fetch、axios来存取数据，然后再把数据喂给model。这不是一个理想的架构。UI和数据持久化是两个独立的东西，最好是在UI里调用model提供的存取函数，然后在model的存取函数里调用fetch、axios：

[ui事件处理函数] --调用--> [user.save方法] --调用--> [fetch函数]

且慢，刚才不是说中间的user.save最好不要import任何其他东西嘛？那它怎么做到能够调用fetch呢？这就需要通过接口来做依赖反转，就是在model里定义一个抽象的数据存取持久化的接口，然后再用fetch等具体方式来构造出这个接口的具体实现。model的代码里调用的是自己定义的接口，所以没有import其他东西。所以写model的时候，就是所谓“面向接口而不是实现编程”。等到用new或者工厂函数来实例化model的时候，再把具体实现作为参数传进去。这样就变成了：

[ui事件处理函数] --调用--> [user.save方法] <--调用-- [fetch函数]

这样，我们在前端的部分就做到了model、UI和持久化这三个东西的分离。这就是所谓六边形架构、洋葱架构、整洁架构的核心套路，无论是前端还是后端开发中，思想都是一样的。（详见 clean architecture一书，强烈推荐）

在这个业务和UI分离的架构下，视图方案采用class还是hooks其实都没什么太大区别，你用vue的optional api, composition api，或者react class组件，react hooks函数，都是一层薄薄的壳子而已，主要就根据第三方组件库的丰富适用程度、团队的能力经验偏好等因素来选择了。理论上来说，vue composable 和 react hooks 的可组合能力是有一定优势的。
