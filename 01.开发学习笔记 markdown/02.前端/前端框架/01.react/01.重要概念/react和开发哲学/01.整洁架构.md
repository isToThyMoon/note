https://www.zhihu.com/question/468249924/answer/1966324921?utm_id=0#!
# 一些关注点：

> 架构整洁：业务逻辑和UI逻辑混杂（antd+ahooks） 还是 业务逻辑和UI逻辑完全分离（容器组件和UI组件也是关注点分离）
> 视图方案： react class组件 还是 hooks函数式组件
> 响应原理： react原生发布订阅（包括redux） 还是 mobx代理模式
> 模型风格（编程范式）： 面向对象OOP 还是 函数式FP
> 类型系统： js 还是 ts（基本没什么疑问）

更深层级的分离：逻辑/数据/视图分离，reducer/store/UIComponent

# 重新思考react
业务架构组织和视图方案没关系。架构上需要把model独立出去，剩下一个薄薄的UI层，UI层本身区别不大。如果你感觉class组件和hook组件的业务逻辑侵入性不同，那很可能是model没有足够地抽离出去，ui和逻辑没分开。分离开的整洁架构，业务和UI分离，使用class组件还是hooks组件都无所谓，甚至react还是vue也无所谓。；

视图方案和响应原理也没关系。这是两个独立正交的维度，不存在耦合，mobx和hooks不是替代关系。

响应原理和模型风格关系很大，vue/mobx的响应原理天然适合对接OOP模型，react响应原理天然适合对接FP模型。

模型风格和类型系统也没关系。类型的动静强弱是独立问题，ts和js一样都可以开发oop风格模型，当然也一样都可以开发偏向fp风格的模型。

总之，这五个东西里面，只有响应原理和模型风格之间有强相关性，其他两两之间其实都没啥关系。对于前端开发，真正需要讨论的重大的技术方案决策，其实就是选择proxy响应式+OOP模型，还是选择react响应式+FP模型。其他问题都不太需要讨论，要不就是已经有普遍优势的选项，要不就是根本无所谓。


# 视图方案（class OOP还是hook FP）和响应原理无关
hooks是视图方案层面的东西，是改进class组件的，它们背后用的都是react原生的响应方案，也就是监测变量引用（reference）的变化，然后整个子树去协调更新。

而mobx，大家喜欢把它和redux、vuex做对比，看作是一个集中管理状态的工具。但其实这个看法不准确，矮化了mobx。mobx也可以用于管理组件的局部状态，它本质是一个替代性的响应方案，类似vue基于proxy的响应系统，并且提供了一些更丰富的微调选项。

视图方案采用class还是hook，和响应风格是发布订阅比较式更新还是代理属性订阅式更新，是两个相互独立的维度。mobx作为一个响应方案，既可以和class组件一起用，也可以和hooks函数组件一起用，甚至还可以跟ng或vue一起用。事实上mobx本身就提供了一个用来代替useState的[hook](https://link.zhihu.com/?target=https%253A//mobx.js.org/api.html%2523uselocalobservable)。

react、vue、ng这些框架的功能其实可以分为两个部分，一个是UI视图的部分，负责对接dom，另一个是响应系统的部分，负责实现数据联动。这两部分理论上不是耦合的，是可以相互组合的。这也是社区有如此多方案的原因。

vue、mobx这种基于proxy的用起来简单，比起react原生方案来，具有本质性的优势。为什么这么说呢？当然一方面是因为react原生的方案乍看简单直接，稍微用起来就会发现各种无效协调、无效更新爆表，要控制好性能的话，无论class组件还是hooks方案都需要注意很多事情，心智负担比较重。但更重要的原因是，vue、mobx的响应方案，对接主流model风格比较方便。

但是为什么react还是有市场？除了早期开拓者的身份，react这种ui=f(state)的函数式哲学非常直接，一切都是js的。

# 响应原理和模型风格（编程范式）的关系
之前提到两种响应原理分别采用两种数据模式，不可变数据和可变数据，这个之前提了很多，函数式编程讲究唯一输入对应唯一数据，它是天生不可变数据的，而class式的面向对象编程，一个引用地址不变的对象，内部有很多可变的状态，还有一些改变这些状态的动作，它是天生可变数据的。

所以响应原理的不同，造成两大模型风格OOP和FP的不同，又或者说它们之间的关系是双向选择的。

vue和mobx这类基于proxy的响应方案，核心依赖的就是“容器对象引用不变，内部属性状态发生改变”，而面向对象的class实例的本质，就是一个引用不变的对象，里面有一些可变的状态，还有一些用来改变这些状态的动作。完美配合！

但如果配合react原生响应系统，用class来写model就比较麻烦。react原生响应方案最怕的就是“容器引用不变、内部变”这种东西，它反而要求“内部不要变，容器整体引用要变”，也就是你每一个动作都必须生成一个新的实例，这样它才能检测到状态的变化。刚好和对象的特性是反的。这就天然切合声明式编程、FP的特质。

class 
数据可变，甲风格典型OOP，适合对接vue、mobx；通过immer对接react不成熟
数据不可变，丙风格非典型FP，class外表下所有方法都是纯函数，适合对接react，包括class和hooks

函数
数据可变，丁风格非典型OOP，相当于把class的方法外置了，适合对接vue、mobx也可以通过immer对接react
数据不可变，乙风格典型FP，适合对接react，包括class和hooks

通过对比，react class组件是“面向对象”的吗？根本不是！一个不允许你修改 this.state属性、只能通过this.setState() 间接修改属性的class，本质上，类似上述的“丙风格”，是一种非典型的FP！这也是随后react推出hooks并建议开发者转向hooks的原因，react骨子里就是FP的。

react原生的响应式方案是非常依赖数据不可变性的。自从react最开始采用这种响应式方案的那一天起，它根子上就是对FP模型友好的，哪怕把组件包装成class，也不能使它更接近OOP。而题主之所以误认为react class组件是OOP，很可能是因为他用了mobx代替react原生响应系统。这时候react就只剩下一个UI dom对接的功能了，FP的核就被抽掉了，变成了表格中的甲方案，这就是典型的OOP。可实际上这个OOP不是因为用了class组件，而是因为用了mobx。如果题主不用mobx，而是redux，那么哪怕你完全不用hooks，都用class组件，你的redux里面也全是FP纯函数。

在我看来，四种风格其实只有class加可变数据或者hooks加不可变数据比较有意义，即然选择了一个框架，除了将业务逻辑和UI逻辑分离，其他都跟着官方走比较好，否则一旦有新的更新会非常痛苦。


