---
title: 生命周期函数和axios
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
tags:
  - react项目
date:
---

# 生命周期函数 
是指在某一时刻组件会自动调用执行的函数

三个钩子在react17删除
componentWillMount
componentWillReceiveProps
componentWillUpdate

由getDerivedStateFromProps取代

(1)componentWillMount在SSR中这个方法会被多次调用，会导致重复触发多次，同时若在这个方法内绑定事件将无法解绑，会造成内存泄露，这个方法变得不够安全高效而逐步被放弃。
(2)componentWillReceiveProps外部组件多次频繁更新传入多次不同的props，会导致不必要的异步请求。
(3)componentWillupdate,更新前记录DOM状态，可能会做一些处理，与componentDidUpdate相隔时间如果过长会导致状态不可信。


![截屏2021-03-12 下午12.37.36](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2021-03-12%20%E4%B8%8B%E5%8D%8812.37.36.png)

加上不常用周期：
![截屏2021-03-12 下午12.52.07](https://raw.githubusercontent.com/ayrikiya/pic-store/main/note/%E6%88%AA%E5%B1%8F2021-03-12%20%E4%B8%8B%E5%8D%8812.52.07.png)

具体可看官网介绍

## static getDerivedStateFromProps(nextProps, prevState)
一个特殊的static周期方法 取代旧api的一个修正方案。

一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数props和state，分别指接收到的新参数和当前的state对象，这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null
在调用render()方法前调用。该函数会在挂载时，接收到新的props，调用了setState和forceUpdate时被调用

这个方法就是为了取代之前的componentWillMount、componentWillReceiveProps和componentWillUpdate

## [getSnapshotBeforeUpdate](https://zh-hans.react.dev/reference/react/Component#getsnapshotbeforeupdate)
getSnapshotBeforeUpdate取代了componentWillUpdate，触发时机为update发生的时候，在render之后、dom渲染dom改变之前，返回一个值，作为componentDidUpdate的第三个参数。

比如列表更新后新的数据不断插入到数据前面，如何保证可视区依旧是之前看到的呢？
```
getSnapshotBeforeUpdate(){
    return this.refs.wrapper.scrollHeight
}
    
componentDidUpdate(prevProps,prevState,preHeight){
    this.refs.wrapper.scrollTop+=this.refs.wrapper.scrollHeight-preHeight
}
.....
```
也就是说，在getSnapshotBeforeUpdate开始处于pre-commit阶段可以读取dom，但这里读的dom信息是未修改前的，在componentDidUpdate中可以使用dom，这里读到的dom是更新后的，但注意此时react并未让出js线程给渲染线程，所以屏幕此时还未变化，在componentDidUpdate中重新进行的state修改都不会发生页面闪烁。浏览器只能 paint 最后的 DOM 更变。

# 基础使用场景：

1.shouldcomponentUpdate解决重复渲染
我们知道， 当input输入框输入数据调用handleInputchange函数改变父组件state中inputValue的值 那么
父组件的render函数会重新执行 render里的子组件的也会重新渲染 子组件的render函数也会重新执行
这样子没输入一个值 父组件和子组件都重新渲染 带来性能损耗
怎么解决？
子组件生命周期函数
```JavaScript
shouldComponentUpdate(nextProps, nextState){
  if(nextProps.content !== this.props.content){
    return true;
  }else{
    return false;
  }
}
```

表示即将到来的渲染里 nextProps传来的content有没有变化？ 如果没有 则没有必要重新渲染

2.ajax请求位置
如果我想要在react中发送一个ajax请求 从远程服务器的api中请求一个list 把它渲染到页面上
在哪发ajax请求？
一般在生命周期函数的componentDidMount里发ajax请求  如果写在render里 会陷入重发渲染重复发请求的死循环
如果放在componentWillMount里 虽然没有问题 但是会和以后比较深的技术栈矛盾 引起不必要的问题 那么约定写在ComponentDidMount里

react内部便没有像jquery一样封装ajax请求
所以我们引入第三方库 yarn add axios 或者 npm install axios

```JavaScript
componentDidMount(){
			axios.get('/api/todolist')
			.then(() => {alert('succ')})
			.catch(() ={alert('error')})
}
```

-------

# class组件正常执行流程：
理解本节内容，需要同时深度理解  浏览器相关 - 线程 引擎 - 浏览器组件 js异步并发模型

具体流程可看react源码更新过程。

## 挂载：
当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：
constructor
static getDreivedStateFromProps()（新增）
#componentWillMount(废弃)
render
componentDidMount

## 更新
当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：
static getDreivedStateFromProps()（新增）
shouldComponentUpdate
render
getSnapshotBeforeUpdate
componentDidUpdate

## 卸载
当组件从 DOM 中移除时会调用如下方法：
componentWillUnMount

注意周期里各函数执行时机的一个重点：
1. render函数并不做实际的渲染动作，他只是返回一个JSX描述的结构（ReactElement）。
2. render函数被调用完之后，componentDidMount函数并不是会被立刻调用。componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，这里的渲染指组件已经被js引擎『装载』到了DOM树上，但是渲染引擎还没有执行，页面没有完成真实渲染，js引擎并没有让出锁。

-------

# 组件重渲染
之前基础架构层面概念讲完，那么组件何时会触发了渲染？

组件收到新的props。
自生维护状态state被更新。
上下文的值被更新（如果该组件使用useContext监听上下文的变化）。

父组件由于上述任何原因而更新。

## 渲染

渲染 是个复合且笼统的过程，可以简单理解为 layout 和 paint 两个过程。layout 是计算出 renderObject（浏览器中表示渲染元素的对象，大体上和 DOM 节点是对应的）的几何尺寸和位置；paint 则是将 renderObject 绘制为位图用于显示，这个过程一般需要 GPU 的参与。

class组件的render方法并不会去真正的操作DOM，它的作用是把需要的东西返回回来（jsx）。

setState状态改变，重新执行组件树，即重新运行关联组件的应用代码，
reconciler构建新的VDOM或者fiber树，diff比对前后fiber树变化，打上变更tag，
renderer按tag更新真实的dom，完成状态到UI到自动更新。

真正渲染的工作，是挂载阶段的ReactDOM.render方法去操作（在web环境，renderer就是ReactDOM）。

## 一个例子说明渲染逻辑：
```ts
function TickerComponent = ()=>{
    const [ticker, setTicker] = useState("AAPL");
    ...
    const onChange = event => {
       setTicker(event.target.value);
    }
...
}
```

useState语句返回一个状态值（‘ticker’）和一个更新相应状态值的setter函数（‘setTicker’）。

当组件第一次被渲染时，‘ticker’值将是参数中指定的默认值（即’AAPL’）。

当一个新的ticker在下拉菜单中被选中时，onChange函数会被调用。这个函数使用setter函数更新状态值。 这个状态的变化触发了重新渲染 --再次调用TickerComponent函数来执行。但这次 "useState(‘AAPL’) "返回之前由setter函数设置的ticker值。这就像React将状态存储在一个与我们组件实例相联系的隐藏的数据存储器中。最新的状态值被保留下来，并在重读时返回。如果该组件被卸载并重新挂载，那么一切都会重新开始。

## 为什么didMount生命周期里两次setState只看到最后一次state结果？

为什么didMount生命周期里setState按理应该两次渲染，但实际看不到两次渲染的闪烁，要先理解setState的逻辑。

在 React 使用 fiber reconciler 之前（前文提到的react15，16开始采用fiber架构），组件的更新在一个 script 任务中完成的，即同步的。
在生命周期函数里调用 setState 不会立即影响 state 的变化，但生命周期函数执行完，这些“partialState”都会被一并“结算”，即 batchUpdate。 
在 componentDidMount 使用使用 setState，组件的 render 方法会被执行两次，DOM 被更新两次，但由于整个过程在同一个 script 任务发生的，两次render➕commit是不会中段的同步任务，都在js引擎中间并不会让给渲染线程去绘制屏幕，所以浏览器却只能 paint 最后的 DOM 更变。

event loop 明确了一个 task 最多有一次 paint（结合事件循环的知识来理解），尽管在 script 中 DOM 被修改了多次。React 的同步渲染逻辑，确保了 componentDidMount 之前的 render 和其中setState触发的 render 在同一个 script 过程中，从而保证了只会有第二次 render 的结果会被浏览器绘制。

### componentDidMount
官方文档对于 componentDidMount 的解释

> componentDidMount在组件挂载之后运行。如果立即（同步）设置 state，那么React就会触发一次额外的render，并将第二个render的响应用作初始UI，这样用户就不会看到闪烁。
> componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。
> 这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅
> 你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理。

这里面比较重要的两句话是这两句： 
1. componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用
2. 额外渲染会发生在浏览器更新屏幕之前

第一句话是什么意思呢？就是说当我们的组件被插入到 DOM 树之后，就会执行 componentDidMount 生命周期。那第二句话是什么意思呢？这句话是说如果我们在 componentDidMount 里面调用了 setState , 会触发一次额外渲染, 也就是说会再走一次 render 流程，但是这个过程会发生在用户界面更新之前。

仔细一想，这两句话好像有点冲突？你又和我说这个组件被插入到 DOM 树之后才会执行 componentDidMount, 又和我说我重新 setState 会发生在用户界面更新之前？？组件被插入到DOM树不就代表着用户界面已经更新了吗？
其实不然，因为浏览器的js线程和渲染线程是互斥的，所以js同步执行的时候渲染线程是没办法去渲染用户界面的，即使我们的内容修改已经同步到了DOM中。

所以 react 的 componentDidMount 和这个是一个道理，componentDidMount 中去重新 setState 的时候，也就是说会立刻进行一次 rerender , setState其实仍然是同步代码，此时js线程仍然被占用。在这个时候我们上一次的内容其实已经到了DOM中，但是渲染线程无法渲染内容到用户界面上，所以用户看不见任何东西。

```
import React from 'react';

function requestData() {
  const now = Date.now();

  while(Date.now() - now <= 2 * 1000) {};

  return 'after componentDidMount data';
}
class App extends React.Component {
  state = {
    data: 'init data'
  }
  componentDidMount() {
    this.setState({
      data: requestData()
    })
  }
  render() {
    return (
      <div>
        <div>App</div>
        <div>{this.state.data}</div>
      </div>
    )
  }
}

export default App;
```
上述代码模拟了下请求数据的操作，didmount中请求数据耗费两秒，会先展示init data再展示after componentDidmount data吗？
实际上只会一个空白结果2秒后（生命周期函数会阻塞渲染，时间拉长页面会一直空白直到操作完成）展示App after componentDidmount data，这是因为js阻塞了渲染所导致的，我们知道这时候虽然界面没有显示，但其实已经挂载到了dom中，所以应该可以拿到init data。

那么自从react hooks出来之后函数组件已经变得非常常见了，而useEffect也是使用频率非常高的一个hooks，我们平时可能就会将它类比为componentDidMount, 其实这两个并不是完全相等的，从我们刚刚的例子可以知道，componentDidMount其实会阻塞页面渲染，但是useEffect是一个真正异步执行的过程（把useEffect看成一个请求），也就是说会在真正渲染完成之后执行，并不会阻塞渲染。真正和componentDidMount等效的是useLayoutEffect，它和componentDidMount一样也会阻塞渲染。

所以，componentDidMount 其实是一个会阻塞渲染的生命周期，我们在这里面最好不要去执行一些非常耗时的逻辑，这样会让我们的首屏出现的更慢。


### didmount中使用dom操作
已经遇到过很多次的问题，在didmount中直接使用dom操作，querySelector，必须将选择器书写完整，querySelector选择了一个元素后在用.chilren[]的常规方式是拿不到子元素的，显示undifined。

------- 

注意以上都是旧版的legacy模式同步更新方式下。

react后续启用了concurrent模式，fiber架构。

Concurrent 模式说白就是让组件更新异步化，切分时间片，渲染之前的调度、diff、更新都只在指定时间片进行，如果超时就暂停放到下个时间片进行，中途给浏览器一个喘息的时间。

浏览器是单线程，它将 GUI 描绘，时间器处理，事件处理，JS 执行，远程资源加载统统放在一起。当做某件事，只有将它做完才能做下一件事。如果有足够的时间，浏览器是会对我们的代码进行编译优化（JIT）及进行热代码优化，一些 DOM 操作，内部也会对 reflow 进行处理。reflow 是一个性能黑洞，很可能让页面的大多数元素进行重新布局。

浏览器的运作流程: 渲染 -> tasks -> 渲染 -> tasks -> 渲染 -> ....

这些 tasks 中有些我们可控，有些不可控，比如 setTimeout 什么时候执行不好说，它总是不准时；资源加载时间不可控。但一些JS我们可以控制，让它们分派执行，tasks的时长不宜过长，这样浏览器就有时间优化 JS 代码与修正 reflow ！

总结一句，就是让浏览器休息好，浏览器就能跑得更快。

