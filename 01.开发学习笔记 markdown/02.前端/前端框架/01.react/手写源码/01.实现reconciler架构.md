# intro

reconciler是React核心逻辑所在的模块，中文名叫协调器。协调（reconcile）就是diff算法的意思。

我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。

每当有更新发生时，Reconciler会做如下工作：

1. 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
2. 将虚拟DOM和上次更新时的虚拟DOM对比
3. 通过对比找出本次更新中变化的虚拟DOM
4. 通知Renderer（如ReactDOM）调用宿主环境api，将变化的虚拟DOM渲染到页面上

其中reconciler的核心是比对，并为变化的虚拟DOM打上代表增/删/更新的标记。

# reconciler有什么用？
这和react的声明式开发有关。

jQuery工作原理（过程驱动）命令式编程：
jQuery直接调用宿主环境API，操作显示真实UI

前端框架结构与工作原理（状态驱动）声明式编程：
状态变更 -> 描述UI的方法（JSX或vue的模版语法）-> 运行时核心模块（reconciler renderer）-> 调用宿主环境API -> 真实dom

vue这类的模板语法有编译优化，而react是一个纯运行时。

reconciler的工作流程就是核心模块消费JSX的过程。

JSX产出ReactElement。

reconciler消费JSX对比变化产出虚拟DOM是一套复杂的工作流程，它需要一个新的数据结构，既能沟通ReactElement和真实的DOMELement，作为数据存储单元，也能描述reconciler的工作流程，作为工作单元。这就是FiberNode，也就是虚拟DOM了。

当前我们了解的节点类型：
JSX
ReactElement
FiberNode
DOMElement

# reconciler的工作方式
对于同一个节点，比较其ReactElement与fiberNode，生成子fiberNode。并根据比较的结果生成不同标记（插入、删除、移动......），对应不同宿主环境API的执行。

下一级ReactElement和子fiberNode继续比较，生成子fiberNode，生成标记。。。。。。

比如，挂载`<div></div>`：
```js
// jsx结果是一个React Element <div></div>
jsx("div") 
// 和对应fiberNode比较，但这时fiberNode是null
null
// 生成子fiberNode
// 对应标记
Placement
```

将`<div></div>`更新为`<p></p>`：
```js
// React Element <p></p>
jsx("p")
// 对应fiberNode（它是div的父级fiberNode和父级的ReactElement比较后生成的子fiberNode）
FiberNode {type: 'div'}
// 生成子fiberNode
// 对应标记
Deletion Placement
```

当所有ReactElement比较完后，会生成一棵fiberNode树，一共会存在两棵fiberNode树：

current：与视图中真实UI对应的fiberNode树
workInProgress：触发更新后，正在reconciler中计算的fiberNode树

计算完workInProgress tree包含很多操作标记，根据这些操作标记操作真实UI，更新完成后，workInProgress tree的内容就应该变成current tree了。
所以这两颗树会来回切换。

react通过双缓冲技术切换这两颗树。

# JSX消费的顺序
以DFS（深度优先遍历）的顺序遍历ReactElement，这意味着：

如果有子节点，遍历子节点
如果没有子节点，遍历兄弟节点 例子：
```js
<Card>
    <h3>你好</h3>
    <p>Big-React</p>
</Card>
```
这是个递归的过程，存在递、归两个阶段：

递：对应beginWork
归：对应completeWork

# diff算法
beginWork中，
对于update的组件，他会将当前组件与该组件在上次更新时对应的Fiber节点比较（也就是俗称的Diff算法），将比较的结果生成新Fiber节点。

为了防止概念混淆，这里再强调下

一个DOM节点在某一时刻最多会有4个节点和他相关。

1. current Fiber。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的Fiber节点。

2. workInProgress Fiber。如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber代表该DOM节点对应的Fiber节点。

3. DOM节点本身。

4. JSX对象。即ClassComponent的render方法的返回结果，或FunctionComponent的调用结果。JSX对象中包含描述DOM节点的信息。

Diff算法的本质是对比1和4，生成2。

## Diff的瓶颈以及React如何应对
由于Diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n^3)，其中n是树中元素的数量。

如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。

为了降低算法复杂度，React的diff会预设三个限制：

只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。

两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。

开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。

## Diff是如何实现的

我们从Diff的入口函数reconcileChildFibers出发，该函数会根据newChild（即JSX对象）类型调用不同的处理函数。
```
// 根据newChild类型选择不同diff函数处理
function reconcileChildFibers(
  returnFiber: Fiber,
  currentFirstChild: Fiber | null,
  newChild: any,
): Fiber | null {

  const isObject = typeof newChild === 'object' && newChild !== null;

  if (isObject) {
    // object类型，可能是 REACT_ELEMENT_TYPE 或 REACT_PORTAL_TYPE
    switch (newChild.$$typeof) {
      case REACT_ELEMENT_TYPE:
        // 调用 reconcileSingleElement 处理
      // // ...省略其他case
    }
  }

  if (typeof newChild === 'string' || typeof newChild === 'number') {
    // 调用 reconcileSingleTextNode 处理
    // ...省略
  }

  if (isArray(newChild)) {
    // 调用 reconcileChildrenArray 处理
    // ...省略
  }

  // 一些其他情况调用处理函数
  // ...省略

  // 以上都没有命中，删除节点
  return deleteRemainingChildren(returnFiber, currentFirstChild);
}
```

我们可以从同级的节点数量将Diff分为两类：

当newChild类型为object、number、string，代表同级只有一个节点

当newChild类型为Array，同级有多个节点 