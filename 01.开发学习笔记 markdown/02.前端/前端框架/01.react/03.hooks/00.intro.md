react16.8的新增特性。让你在不编写class的情况下在函数组件中使用state和其他React特性。

函数式开发依赖一个react团队想达到的终极目标：
 UI = f(state) 
与 UI 无关的不应该是 state 而应该是 ref。

react初始版本使用class组件，但它只是一个视图层library，
基础的数据传递的状态方案只有props传递，组合组件状态提升，而context的不完善只能胜任修改全局主题这种变更不频繁的状态管理，于是出现如何管理数据层数据模型的讨论，主要有redux(immutable)和mobx(mutable)，至此数据层被单独拎出来，与UI渲染分离，实现数据层修改驱动UI变动。
react哲学介绍中，想到这种数据模型和UI模型分离是很自然的事情。

但业务逻辑和UI逻辑是否也分离却是非常隐含的选项，因为在大量的学习示例中，都将业务代码写在生命周期中（class组件），或者useEffect中（函数组件）。

实际上， 在组合组件状态提升时，我们就自然而然想到，可以让容器组件和UI组件分离（HOC同样做的事情），容器组件负责业务逻辑，UI组件作为纯函数只负责UI渲染。这种分离其实也隐含了包含状态的逻辑复用方案，react发展之路，除了致力于解决函数式编程实现UI=f(state)的编程范式，常规组件化之外就是寻找最佳的携带状态的逻辑复用解决方案。 （mixin HOC render prop）

hooks就是目前react认为最佳的逻辑复用方案。

# hook解决问题

**一句话，为了更好地复用包含react状态的逻辑代码。**

1. 包含状态的逻辑复用解决方案
class时代的组件很难复用状态逻辑，从mixin 到HOC到render Props。
但是这类方案需要重新组织你的组件结构，这可能会很麻烦，使你的代码难以理解。如果你在 React DevTools 中观察过 React 应用，你会发现由 providers，consumers，高阶组件，render prop等其他抽象层组成的组件会形成“嵌套地狱”。

这时候，就需要一个更底层的方案来解决逻辑状态复用的问题，所以Hooks应运而生。

Hook 使你在无需修改组件结构的情况下复用状态逻辑。 这使得在组件间或社区内共享 Hook 变得更便捷。

自定义hook：
相比较HOC或render Props，抽取公共逻辑直接在需要调用的地方调用即可

详细来说react团队为了解决复用状态逻辑这几年做了很多尝试 现在走到了hook这条路。
具体发展历程可见**包含状态的逻辑复用方案**。
以及：
https://hejialianghe.github.io/react/react-hooks.html#_8-1-5%E6%89%A9%E5%B1%95%E8%B5%84%E6%96%99
https://www.notion.so/Hook-fd25471f129b4cde9d21b052624b5366


2. 复杂组件逻辑难以理解，生命周期函数内逻辑太多，无法分割。每个生命周期函数中可能会包含各种互不关联的逻辑。
"
我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。

在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了一定挑战。同时，这也是很多人将 React 与状态管理库结合使用的原因之一。但是，这往往会引入了很多抽象概念，需要你在不同的文件之间来回切换，使得复用变得更加困难。

为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。
"

清除副作用的操作分散在各个生命周期中，难以维护。

3. 类组件所带来的问题 this增加学习成本。
"
组件预编译会带来巨大潜力，尤其是在它不局限于模版的时候。最近，我们一直在使用 Prepack 来试验 component folding，也取得了初步成效。但是我们发现使用 class 组件会无意中鼓励开发者使用一些让优化措施无效的方案。class 也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。因此，我们想提供一个使代码更易于优化的 API。
"
4. 业务变动，不得不改写函数组件到class组件。等等

但从react哲学的角度，react推出hooks更是为了贯彻自己一贯的函数式编程的思想。

# hook使用规则：
1. 仅在最顶层使用hook，不要在循环 嵌套 判断内使用hook。确保每次函数渲染hook都按同样顺序调用。

2. 只在react函数组件中使用hook。


hook中使用到的依赖必须放进依赖列表
但是自定义hook时比如useMountEffect 必须要//eslint disable next line来禁用掉报错
这样不好 
用useCallback或useMemo来优化。

非状态的非基本类型是不能被放进依赖里的，这时就用到上两个hook。
为保证非基本类型在每次重新渲染时不会重复定义导致依赖重复触发。


# 渲染理解
hook式的react可以以帧为划分来理解组件的渲染（不同于class式的生命周期）
组件的不同帧拥有各自独立的props state effect 事件监听函数

例如useState引入的某个state值，在每一帧内其实是一个常量 在此帧内该变量就是此常量值。

所以会发现在effect或者监听事件中，我们会看到使用的state是旧的值，其实就是在该effect或监听函数在那一帧中定义时，闭包所引用到的常量state。

解决这个问题官方有推荐，在setState时采用函数式更新。或者useRef保存变更。

# 纯hooks组件的问题

1、useState 写法难用，如果有很多state，需要一个个去维护，写法不够简洁；当业务逻辑越来越复杂，往往会出现一个模块几十个useState需要维护的尴尬局面。
2、useReducer + context的全局状态难用，仍然需要定义很多action type，还需要提供provider，使用useReducer跨组件共享状态很麻烦
3、useMemo useCallback 用法不够清晰，不知何时用何时不用，用法造成困惑
4、 生命周期需要引入useEffect，需要手动管理，且不够语义化
5、基于hooks的业务组件，内部方法依然难以做到复用，应抽离出去单独维护。
6、当使用useEffect模拟mounted事件时，处理异步请求函数时很麻烦。
7、当组件达到一定复杂度的时候，堆积到一起的代码会变得越来越难以维护
8、React Hook的闭包陷阱问题
9、useState 调用updater更新后，无法同步获取最新state值
10、useState updater无法实现细粒度更新对象的属性值，不得不浅拷贝一份数据再进行覆盖

# 奇怪的问题

## hooks命名
必须以use开头的自定义hook命名，以便与其他函数区分，但这实际上也破坏了函数命名的语义，我们很难理解useGetState useTitle怎么个use法，如果以_开头的私有成员变量和$尾缀的流，就没有类似的烦恼，但这只是使用习惯的差异，并不是特别大的问题。

## 调用时序
react规定，不要在循环 嵌套 判断内使用hook。确保每次函数渲染hook都按同样顺序调用。

React 简单粗暴地用「时序」决定了这一切（背后的数据结构是链表），这也导致 Hooks 对调用时序的严格要求。也就是要避免所有的分支结构，不能让 Hooks 「时有时无」。

这种要求完全依赖开发者的经验抑或是 Lint，而站在一般第三方 Lib 的角度看，这种要求调用时序的 API 设计是极为罕见的，非常反直觉。最理想的 API 封装应当是给开发者认知负担最小的。好比封装一个纯函数add()，不论开发者是在什么环境调用、在多么深的层级调用、用什么样的调用时序，只要传入的参数符合要求，它就可以正常运作，简单而纯粹。

可以说「React 确实没办法让 Hooks 不要求环境」，但也不能否认这种方式的怪异。类似的情况在redux-saga里也有，开发者很容易写出下面这种「符合直觉」的代码，而且怎么也「看」不出有问题。
```
import { call } from 'redux-saga/effects'

function* fetch() { 
    setTimeout(function* () {    
        const user = yield call(fetchUser)     
        console.log('hi', user)                  // 不会执行到这儿  
    }, 1e3)
}
```

yield call()在 Generator 里调用，看起来真的很「合理」。但实际上，function*需要 Generator 执行环境，而call也需要redux-saga的执行环境。双重要求之下，实例代码自然无法正常运行。

