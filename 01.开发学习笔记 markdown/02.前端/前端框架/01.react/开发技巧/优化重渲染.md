

## 简化的render prop 实现减少子组件不必要的重渲染
先来看一段常见的 React 代码
```jsx
import { useState } from "react"

const Father = () => {
  const [count, setCount] = useState(0);
  console.log("Father rendered");
  return (
    <>
      <p>I am Father p tag, {count}</p>
      <button onClick={() => setCount(count + 1)}>Add Count</button>
      <br />
      <Children />
    </>
  );
};

const Children = () => {
  console.log("Children rendered");
  return <p>I am Children p tag</p>;
};
```
每次点击触发Father组件的重渲染，根据react比较式响应的原则，子组件Children也会重新渲染。
实际上在子组件中，并没有用到来自父组件的状态或是自身状态发生了变化，既然状态并没有发生变化不存在重新渲染的需要，那么这个组件更新就是没有必要的。如果子组件的渲染开销比较大，这可能会是一个比较严重的性能问题。

那么如何解决这个问题呢？可能第一反应是给子组件加上PureComponent或者 React.memo 进行 props 浅层比较，或者shouldComponentUpdate控制是否重渲染。

我们从其他角度寻找其他解决方式。

改动一下上面的代码，在父组件和子组件之间添加一个承载逻辑的组件（FatherLogic）：

```js
import { useState } from "react";

const Father = () => {
  console.log("Father rendered");
  return (
    <FatherLogic>
      <br />
      <Children />
    </FatherLogic>
  );
};

const FatherLogic = ({ children }) => {
  const [count, setCount] = useState(0);
  console.log("FatherLogic rendered");
  return (
    <>
      <p>I am Father p tag, {count}</p>
      <button onClick={() => setCount(count + 1)}>Add Count</button>
      {children}
    </>
  );
};

const Children = () => {
  console.log("Children rendered");
  return <p>I am Children p tag</p>;
};
```

在这个 逻辑 组件中，我们把原先父组件中依赖 state 的部分放在了这里，将状态进行下放，其余不依赖的部分则通过组件的 children 属性传递给 逻辑组件。

为什么这样建立一个中间容器，就不会重复触发Children组件渲染？

非常简单，在Father组件中，Children作为props被传入FatherIoc中，FatherIoc组件的重渲染不会修改传入的props。

这里其实不是所谓标准的render prop，标准的render prop是父组件的prop属性传入一个函数，函数返回一个包含复用逻辑的组件，这个被传入的render函数在父组件内部被调用，可以接受父组件的state为入参，处理后的复用逻辑组件将在父组件内部使用。但实现了逻辑的复用。

而这里优化重渲染的例子中，组件Children与Father组件的状态变更无关，将Children组件拉到Father的组件父级，作为prop传入并在jsx中使用，这样Father逻辑组件重新渲染时就不会影响到作为props传入的Children组件。

有些认知认为FatherLogic也可以看成是FatherIoC，整体当成是一种依赖倒置的具体实现，依赖注入。Children作为低层模块可以被随意替换，高层模块Father使用低层模块而不依赖它，它们之间通过FatherIoC胶合。只能说整体模式有点像，但并不是完全的依赖倒置，只能说类似。

更接近Render Prop模式而不是依赖注入。具体来说，它使用了类似Render Prop的模式，通过FatherLogic组件的children prop来传递子组件，允许父组件决定渲染什么内容。

这种模式与Render Prop模式非常相似，尽管在传递子组件时没有使用显式的函数，但它共享了Render Prop模式的一些思想，即通过Props传递组件以实现渲染和数据传递的灵活性。