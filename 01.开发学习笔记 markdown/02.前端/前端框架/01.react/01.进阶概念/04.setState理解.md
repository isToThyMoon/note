

# setState后台做了什么
React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染。

setState可以接受函数为参数。当 setState 执行完成且组件被渲染完成时，将调用回调函数。由于 setState 是异步的，因此下一步执行的任何操作都可以使用该回调函数。 在 setState完成后会调用回调函数，下一步需要执行的任何操作都可以使用该回调函数来实现。建议使用生命周期方法而不是该回调函数。

setState 中的第一个参数也可以传入函数，其结构为 function(state, props) => newState。这个函数会将每次更新都加入队列中，执行时通过当前的 state 和 props 来获取新的 state。这样一来 React 就不会将对象合并（显然根本没有对象让他合并），把多次状态修改打包后进行一次批处理操作了。


# setState同步还是异步
网上有很多文章称 setState 是『异步操作』，所以导致 setState 之后并不能获取到最新值，其实这个观点是错误的。setState 是一次同步操作，只是每次操作之后并没有立即执行，而是将 setState 进行了缓存，mount 流程结束或事件操作结束，才会拿出所有的 state 进行一次计算。如果 setState 脱离了 React 的生命周期或者 React 提供的事件流，setState 之后就能立即拿到结果。

暂且把这种异步称为伪异步。

setState 只在合成事件和钩子函数中是“伪异步”的，在原生事件和 setTimeout 中都是同步的，setState 之后就能立即拿到结果。DOM 也会被同步更新，也就意味着如果你多次 setState ，会导致多次更新，这是毫无意义并且浪费性能的。（这种情况在React18之后不存在了，被做了优化，都是异步的。）

setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然你可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。

## setState是同步异步问题
1. 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还 是放到一个updateQueue中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而 当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为 true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state，而是异步的。

2. 所以说setstate本身是同步的，一旦走了react内部的合并逻辑，放入了updateQueue队列中就变成 异步了，而代码中的函数是react控制的，内部会走合并逻辑，所以这里的setState 不但是合并的也 是异步的

3. 上面说了，setState是异步的原因是因为走了react内部的合并逻辑，那只要能绕过react内部的合并 逻辑，不让它进入到updateQueue中不就变成同步了吗？因为setState()本身就是同步的

4. 利用setTimeout绕过react内部的合并逻辑

5. 异步的情况： 由React控制的事件处理函数，以及生命周期函数调用setState时表现为异步 。大部分开发中用到 的都是React封装的事件，比如onChange、onClick、onTouchMove等（合成事件中），这些事件处 理函数中的setState都是异步处理的。

同步的情况： React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout/setInterval， ajax，promise.then内等 React 无法掌控的 APIs情况下，setState是同步更新state的


# react17之后的setState
https://juejin.cn/post/7017691338255073311

setState调用，开始调度任务，判断新任务的优先级是否是同步优先级，是则使用同步渲染模式，否则使用并发渲染模式（时间分片）。

同步渲染模式中，根据当前环境是否支持微任务调用了两个方法：scheduleMicrotask，scheduleCallback。
并发渲染模式中，也是调用了scheduleCallback。

同步渲染模式：
scheduleMicrotask这个方法主要作用是将任务添加进微任务队列：其实是使用了queueMicrotask方法，如果queueMicrotask方法不支持，则会使用Promise，如果Promise也不支持，最后会使用setTimeout来实现。

queueMicrotask是将传入的回调函数添加进微任务队列中，Promise.then方法也是被添加进微任务队列中，setTimeout则是宏任务，总的来说scheduleMicrotask方法是异步的。

并发渲染模式：
scheduleCallback则是Scheduler调度任务的入口，而Scheduler则是使用MessageChannel来实现的：
可以看到Scheduler根据宿主环境会使用不同的方式实现：

在node.js中会使用setImmediate来实现
在浏览器中会使用MessageChannel来实现
在以上方案都不能实现的时候，则降级使用setTimeout来实现
在这里我们值讨论浏览器环境，node环境之后再单独来分析。

MessageChannel是通过实例化，使用消息通道来实现消息传递，是一个宏任务。
setTimeout也是宏任务，所以Scheduler也是异步的。

很明显，react17之后，setState就是完全异步的了，通过把setState更新任务推入微任务或者宏任务队列，实现异步渲染，所以你无法立马在setState下一行代码拿到更新后的新state值。


为什么要使用异步渲染？

这和React中的Lane机制有关，在React合成事件中连续调用的setState的优先级是一样的，在第一个setState调用后，再调用第二个时，会将第一个更新任务的优先级与第二个更新任务的优先级进行比较，如果优先级一样，则不会执行第二个更新任务，而是将第二个任务的更新内容与第一个的更新内容进行合并，最终只会进行一次更新渲染，这样的做法叫做批量更新。

避免短时间内连续调用造成不必要的渲染，增加性能的开销。


# 为什么didMount生命周期里两次setState只看到最后一次state结果？

为什么didMount生命周期里setState按理应该两次渲染，但实际看不到两次渲染的闪烁，要先理解setState的逻辑。

在 React 使用 fiber reconciler 之前（前文提到的react15，16开始采用fiber架构），组件的更新在一个 script 任务中完成的，即同步的。
在生命周期函数里调用 setState 不会立即影响 state 的变化，但生命周期函数执行完，这些“partialState”都会被一并“结算”，即 batchUpdate。 
在 componentDidMount 使用使用 setState，组件的 render 方法会被执行两次，DOM 被更新两次，但由于整个过程在同一个 script 任务发生的，两次render➕commit是不会中段的同步任务，都在js引擎中间并不会让给渲染线程去绘制屏幕，所以浏览器却只能 paint 最后的 DOM 更变。

event loop 明确了一个 task 最多有一次 paint（结合事件循环的知识来理解），尽管在 script 中 DOM 被修改了多次。React 的同步渲染逻辑，确保了 componentDidMount 之前的 render 和其中setState触发的 render 在同一个 script 过程中，从而保证了只会有第二次 render 的结果会被浏览器绘制。

### componentDidMount
官方文档对于 componentDidMount 的解释

> componentDidMount在组件挂载之后运行。如果立即（同步）设置 state，那么React就会触发一次额外的render，并将第二个render的响应用作初始UI，这样用户就不会看到闪烁。
> componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。如需通过网络请求获取数据，此处是实例化请求的好地方。
> 这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 componentWillUnmount() 里取消订阅
> 你可以在 componentDidMount() 里直接调用 setState()。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。如此保证了即使在 render() 两次调用的情况下，用户也不会看到中间状态。请谨慎使用该模式，因为它会导致性能问题。通常，你应该在 constructor() 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理。

这里面比较重要的两句话是这两句： 
1. componentDidMount() 会在组件挂载后（插入 DOM 树中）立即调用
2. 额外渲染会发生在浏览器更新屏幕之前

第一句话是什么意思呢？就是说当我们的组件被插入到 DOM 树之后，就会执行 componentDidMount 生命周期。那第二句话是什么意思呢？这句话是说如果我们在 componentDidMount 里面调用了 setState , 会触发一次额外渲染, 也就是说会再走一次 render 流程，但是这个过程会发生在用户界面更新之前。

仔细一想，这两句话好像有点冲突？你又和我说这个组件被插入到 DOM 树之后才会执行 componentDidMount, 又和我说我重新 setState 会发生在用户界面更新之前？？组件被插入到DOM树不就代表着用户界面已经更新了吗？
其实不然，因为浏览器的js线程和渲染线程是互斥的，所以js同步执行的时候渲染线程是没办法去渲染用户界面的，即使我们的内容修改已经同步到了DOM中。

所以 react 的 componentDidMount 和这个是一个道理，componentDidMount 中去重新 setState 的时候，也就是说会立刻进行一次 rerender , setState其实仍然是同步代码，此时js线程仍然被占用。在这个时候我们上一次的内容其实已经到了DOM中，但是渲染线程无法渲染内容到用户界面上，所以用户看不见任何东西。

```
import React from 'react';

function requestData() {
  const now = Date.now();

  while(Date.now() - now <= 2 * 1000) {};

  return 'after componentDidMount data';
}
class App extends React.Component {
  state = {
    data: 'init data'
  }
  componentDidMount() {
    this.setState({
      data: requestData()
    })
  }
  render() {
    return (
      <div>
        <div>App</div>
        <div>{this.state.data}</div>
      </div>
    )
  }
}

export default App;
```
上述代码模拟了下请求数据的操作，didmount中请求数据耗费两秒，会先展示init data再展示after componentDidmount data吗？
实际上只会一个空白结果2秒后（生命周期函数会阻塞渲染，时间拉长页面会一直空白直到操作完成）展示App after componentDidmount data，这是因为js阻塞了渲染所导致的，我们知道这时候虽然界面没有显示，但其实已经挂载到了dom中，所以应该可以拿到init data。

那么自从react hooks出来之后函数组件已经变得非常常见了，而useEffect也是使用频率非常高的一个hooks，我们平时可能就会将它类比为componentDidMount, 其实这两个并不是完全相等的，从我们刚刚的例子可以知道，componentDidMount其实会阻塞页面渲染，但是useEffect是一个真正异步执行的过程（把useEffect看成一个请求），也就是说会在真正渲染完成之后执行，并不会阻塞渲染。真正和componentDidMount等效的是useLayoutEffect，它和componentDidMount一样也会阻塞渲染。

所以，componentDidMount 其实是一个会阻塞渲染的生命周期，我们在这里面最好不要去执行一些非常耗时的逻辑，这样会让我们的首屏出现的更慢。




# 同步异步经典问题
```js
class Example extends React.Component{
    constructor(){
    super(...arguments)
        this.state = {
            count: 0
        };
    }
    componentDidMount(){
       // a
      this.setState({count: this.state.count + 1});
      console.log('1:' + this.state.count)
      // b
      this.setState({count: this.state.count + 1});
      console.log('2:' + this.state.count)
      setTimeout(() => {
        // c
        this.setState({count: this.state.count + 1});
        console.log('3:' + this.state.count)
      }, 0)
      // d
      this.setState(preState => ({ count: preState.count + 1 }), () => {
        console.log('4:' + this.state.count)
      })
      console.log('5:' + this.state.count)
      // e
      this.setState(preState => ({ count: preState.count + 1 }))
      console.log('6:' + this.state.count)
    }
}

//输出结果
//1:0
//2:0
//5:0
//6:0
//4:3
//3:4

```