# # render阶段和commit阶段（结合生命周期的流程图来看本节）

有了之前大段的架构铺垫终于到了render和commit阶段的解释。在render阶段，在内存中构建workInProgress Fiber树。在commit阶段将已完成构建的workInProgress Fiber树从reconciler提交到renderer，并由renderer映射到真实dom，执行dom操作，由渲染引擎渲染到页面。同时将workInProgress Fiber树通过current指针切换成current Fiber树。

react组件渲染分2个阶段 render和commit。

render阶段：Scheduler和reconciler工作，调和对比构建fiber树。

commit阶段：renderer工作（浏览器环境时reactDOM），根据fiber树的tag执行DOM操作，映射真实DOM。更新DOM（如果需要得话）
            细分三个阶段：before mutation；mutation；layout。

## render阶段
render阶段的工作是在内存中进行，当工作结束后会通知Renderer需要执行的DOM操作。我们知道，render阶段的工作是在内存中进行，具体就是为fiber树打tag，
插入DOM节点（Placement）
更新DOM节点（Update）
删除DOM节点（Deletion）
当工作结束后会通知Renderer需要执行的DOM操作。要执行DOM操作的具体类型就保存在**fiber.effectTag**中。
**除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。**

render阶段开始于performSyncWorkOnRoot或performConcurrentWorkOnRoot方法的调用。这取决于本次更新是同步更新还是异步更新。

我们现在还不需要学习这两个方法，只需要知道在这两个方法中会调用如下两个方法：
```js
// performSyncWorkOnRoot会调用该方法
function workLoopSync() {
  while (workInProgress !== null) {
    performUnitOfWork(workInProgress);
  }
}

// performConcurrentWorkOnRoot会调用该方法
function workLoopConcurrent() {
  while (workInProgress !== null && !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}
```

可以看到，他们唯一的区别是是否调用**shouldYield**。如果当前浏览器帧没有剩余时间，shouldYield会中止循环，直到浏览器有空闲时间后再继续遍历。这就是concurrent模式的异步的可中断更新。

`workInProgress`代表当前已创建的`workInProgress fiber`树。
`performUnitOfWork`方法会创建下一个Fiber节点并赋值给`workInProgress`，并将`workInProgress`与已创建的Fiber节点连接起来构成Fiber树。
我们知道Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归，所以performUnitOfWork的工作可以分为两部分：“递”和“归”。

### “递”阶段
首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用[beginWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3058)方法。

该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。

当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。

组件执行beginWork后会创建子Fiber节点，节点上可能存在effectTag。

### “归”阶段
在“归”阶段会调用[completeWork](https://github.com/facebook/react/blob/970fa122d8188bafa600e9b5214833487fbf1092/packages/react-reconciler/src/ReactFiberCompleteWork.new.js#L652)处理Fiber节点。

和beginWork一样，completeWork根据current === null ?判断是mount还是update。当update时，Fiber节点已经存在对应DOM节点，所以不需要生成DOM节点。需要做的主要是处理props，比如：onClick、onChange等回调函数的注册，处理style prop，处理children prop。

当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。

如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。

“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。在performSyncWorkOnRoot函数中fiberRootNode被传递给commitRoot方法，开启commit阶段工作流程。

在completeWork的上层函数completeUnitOfWork中，每个执行完completeWork且存在effectTag的Fiber节点会被保存在一条被称为**effectList**的单向链表中。effectList中第一个Fiber节点保存在fiber.firstEffect，最后一个元素保存在fiber.lastEffect。
除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。

注意这里的effect和react提供的effect hook并不是一个概念 有点复杂。

## commit阶段（重点 此处涉及到页面何时出现用户可感知的变更，并且执行一些生命周期和effect）
commitRoot方法是commit阶段工作的起点。fiberRootNode会作为传参。 `commitRoot(root);`

在rootFiber.firstEffect上保存了一条需要执行副作用的Fiber节点的单向链表effectList，这些Fiber节点的updateQueue中保存了变化的props。这些effect（不习惯这个词 或许叫修改好理解点）对应的DOM操作在commit阶段执行。

除此之外，在commit阶段会触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）

commit阶段的主要工作（即Renderer的工作流程）分为三部分：before mutation；mutation；layout。

**在before mutation阶段之前和layout阶段之后**
有一些额外工作，涉及到比如useEffect的触发、优先级相关的重置、ref的绑定/解绑。这些对我们当前属于超纲内容，为了内容完整性，先简单介绍。
before mutation之前主要做一些变量赋值，状态重置的工作。们只需要关注最后赋值的**firstEffect**，在commit的三个子阶段都会用到他。

layout之后主要包括三点内容：
useEffect相关的处理。
性能追踪相关。
触发一些生命周期钩子（如 componentDidXXX）和hook（如useLayoutEffect、useEffect）


**before mutation(操作dom前)**
before mutation阶段的代码很短，整个过程就是遍历effectList并调用commitBeforeMutationEffects函数处理。
```js
function commitBeforeMutationEffects() {
  while (nextEffect !== null) {
    const current = nextEffect.alternate;

    if (!shouldFireAfterActiveInstanceBlur && focusedInstanceHandle !== null) {
      // ...focus blur相关
    }

    const effectTag = nextEffect.effectTag;

    // 调用getSnapshotBeforeUpdate
    if ((effectTag & Snapshot) !== NoEffect) {
      commitBeforeMutationEffectOnFiber(current, nextEffect);
    }

    // 调度useEffect
    if ((effectTag & Passive) !== NoEffect) {
      if (!rootDoesHavePassiveEffects) {
        rootDoesHavePassiveEffects = true;
        scheduleCallback(NormalSchedulerPriority, () => {
         // 触发useEffect
          flushPassiveEffects();
          return null;
        });
      }
    }
    nextEffect = nextEffect.nextEffect;
  }
}
```
这个函数主要做的事情：
1. 处理DOM节点渲染/删除后的 autoFocus、blur 逻辑。
2. 调用**getSnapshotBeforeUpdate**生命周期钩子。
3. **调度useEffect**。

（严格来说这是precommit阶段 可以读取dom）: 调用类组件生命周期函数getSnapshotBeforeUpdate(prevProps, prevState),并且把旧的props和旧的states传递进去。getSnapshotBeforeUpdate是在commit阶段内的before mutation阶段调用的，由于commit阶段是同步的，所以不会遇到多次调用的问题。

调度useEffect：scheduleCallback方法由Scheduler模块提供，用于以某个优先级异步调度一个回调函数。
在此处，被异步调度的回调函数就是触发useEffect的方法flushPassiveEffects。（这里非常重要非常巧妙，之前对react16fiber架构的解释详细介绍了scheduler和reconciler配合工作，这里以scheduleCallback异步调度这个任务就是在本次render commit结束之后插入了一个NormalSchedulePriority的任务，实现在每次渲染到页面后执行useEffect这个功能。）

跟着flushPassiveEffects我们可以找到最终调用 useEffect 的地方是 commitRootImpl ，所以就是在这里面对 useEffect 进行了调度，在完成渲染工作以后去异步执行了 useEffect。

注意这里是调度了useEffect，而useEffect销毁函数和回调函数的调度在下面layout阶段讲解，这两个调度不是一个概念。

我们接下来讨论useEffect如何被异步调度，以及为什么要异步（而不是同步）调度。

如何异步调度？
在flushPassiveEffects方法内部会从全局变量rootWithPendingPassiveEffects获取effectList。

在completeWork一节我们讲到，effectList中保存了需要执行副作用的Fiber节点。其中副作用包括
插入DOM节点（Placement）
更新DOM节点（Update）
删除DOM节点（Deletion）

除此外，当一个FunctionComponent含有useEffect或useLayoutEffect，他对应的Fiber节点也会被赋值effectTag。
在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

如果在此时直接执行，rootWithPendingPassiveEffects === null。
那么rootWithPendingPassiveEffects会在何时赋值呢？
在上一节**layout之后**的代码片段中会根据rootDoesHavePassiveEffects是否true决定是否赋值rootWithPendingPassiveEffects。
```js
// layout之后
// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}
```
整个useEffect异步调用分为三步：
before mutation阶段在scheduleCallback中调度flushPassiveEffects
layout阶段之后将effectList赋值给rootWithPendingPassiveEffects
页面渲染完成之后scheduleCallback触发flushPassiveEffects，在flushPassiveEffects方法内部会遍历rootWithPendingPassiveEffects（即effectList）执行effect回调函数。

为什么需要异步调用：
文档介绍：与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。
可见，useEffect异步执行的原因主要是防止同步执行时阻塞浏览器渲染。

**mutation阶段（执行dom操作）**：获取对象的effects 根据不同的effectTag执行不同的操作，插入、更新、删除。将workInProgress fiber树变成current Fiber树。
插入节点： commitPalcement
更新节点：commitWork
删除节点：commitDeletion

类似before mutation阶段，mutation阶段也是遍历effectList，执行函数。这里执行的是commitMutationEffects
commitMutationEffects会遍历effectList，对每个Fiber节点执行如下三个操作：
根据ContentReset effectTag重置文字节点
更新ref
根据effectTag分别处理，其中effectTag包括(Placement | Update | Deletion | Hydrating)。我们关注步骤三中的Placement | Update | Deletion。Hydrating作为服务端渲染相关，我们先不关注。

这里就是一些具体的dom操作了。 先不做详细理解。

Placement effect：意味着该Fiber节点对应的DOM节点需要插入到页面中。调用的方法为commitPlacement。

Update effect：当Fiber节点含有Update effectTag，意味着该Fiber节点需要更新。调用的方法为commitWork，他会根据Fiber.tag分别处理。
主要关注在这个类型度tag下，当fiber.tag为FunctionComponent，会调用commitHookEffectListUnmount。该方法会遍历effectList，执行所有**useLayoutEffect hook的销毁函数**（这也是hook中每次渲染先执行上一个销毁函数再执行effect的逻辑）。你不需要很了解useLayoutEffect，我们会在下一节详细介绍。你只需要知道在mutation阶段会执行useLayoutEffect的销毁函数。

Deletion effect：当Fiber节点含有Deletion effectTag，意味着该Fiber节点对应的DOM节点需要从页面中删除。调用的方法为commitDeletion。
该方法会执行如下操作：
递归调用Fiber节点及其子孙Fiber节点中fiber.tag为ClassComponent的componentWillUnmount 生命周期钩子，从页面移除Fiber节点对应DOM节点
解绑ref
**调度useEffect的销毁函数**


**layout阶段（执行dom操作之后）**：
该阶段之所以称为layout，因为该阶段的代码都是在DOM渲染完成（mutation阶段完成）后执行的。
该阶段触发的生命周期钩子和hook可以直接访问到已经改变后的DOM，即该阶段是可以参与DOM layout的阶段。（前两个阶段其实对生命周期和hook已经做了一些准备工作）

与前两个阶段类似，layout阶段也是遍历effectList，执行函数。
具体执行的函数是commitLayoutEffects。主要工作为“根据effectTag调用不同的处理函数处理Fiber并更新ref。
commitLayoutEffects一共做了两件事：
commitLayoutEffectOnFiber（调用生命周期钩子和hook相关操作）
commitAttachRef（赋值 ref）代码逻辑很简单：获取DOM实例，更新ref。

commitLayoutEffectOnFiber方法会根据fiber.tag对不同类型的节点分别处理。（commitLayoutEffectOnFiber为别名，方法原名为commitLifeCycles）

对于ClassComponent，他会通过current === null?区分是mount还是update，调用**componentDidMount** 或**componentDidUpdate**
**触发状态更新的this.setState如果赋值了第二个参数回调函数**，也会在此时调用。

对于FunctionComponent及相关类型，他会**调用useLayoutEffect hook的回调函数**，**调度useEffect的销毁与回调函数**。

```js
  switch (finishedWork.tag) {
    // 以下都是FunctionComponent及相关类型
    case FunctionComponent:
    case ForwardRef:
    case SimpleMemoComponent:
    case Block: {
      // 执行useLayoutEffect的回调函数
      commitHookEffectListMount(HookLayout | HookHasEffect, finishedWork);
      // 调度useEffect的销毁函数与回调函数 注意这里调度的是useEffect的两个函数
      schedulePassiveEffects(finishedWork);
      return;
    }
```
先useLayoutEffect后useEffect，其实这里代码顺序也无所谓先后，before mutation阶段解释过useEffect的前期准备工作，schedulePassiveEffects的调用是一个异步调用。这个函数作用是从函数组件对应的 fiber 上获取上面挂载的 effect，然后将 effect 和 fiber 推到 pendingPassiveHookEffectsUnmount 和 pendingPassiveHookEffectsMount 这个两个队列中。
```js
function schedulePassiveEffects(finishedWork: Fiber) {
  const updateQueue: FunctionComponentUpdateQueue | null = (finishedWork.updateQueue: any);
  const lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
  if (lastEffect !== null) {
    const firstEffect = lastEffect.next;
    let effect = firstEffect;
    do {
      const {next, tag} = effect;
      if (
        (tag & HookPassive) !== NoHookEffect &&
        (tag & HookHasEffect) !== NoHookEffect
      ) {
        // 向`pendingPassiveHookEffectsUnmount`数组内`push`要销毁的effect
        enqueuePendingPassiveHookEffectUnmount(finishedWork, effect);
        // 向`pendingPassiveHookEffectsMount`数组内`push`要执行回调的effect
        enqueuePendingPassiveHookEffectMount(finishedWork, effect);
      }
      effect = next;
    } while (effect !== firstEffect);
  }
}
```

结合之前before mutation提到的scheduleCallback中调度flushPassiveEffects，在layout阶段之后将effectList赋值给rootWithPendingPassiveEffects，渲染完成后执行useEffect的销毁函数和回调函数。
```js
// layout之后
// useEffect相关
if (rootDoesHavePassiveEffects) {
  rootDoesHavePassiveEffects = false;
  rootWithPendingPassiveEffects = root;
  pendingPassiveEffectsLanes = lanes;
  pendingPassiveEffectsRenderPriority = renderPriorityLevel;
} else {}
```

这里dom操作已经完成，可以取到dom信息做一些effect修改。

注意useLayoutEffect的销毁函数是在mutation阶段Update effectTag类型时调用的。
结合这里我们可以发现，useLayoutEffect hook从上一次更新的销毁函数调用到本次更新的回调函数调用是同步执行的。

而useEffect则需要先调度，在Layout阶段完成后再异步执行。这就是useLayoutEffect与useEffect的区别。

对于useEffect的销毁函数和回调函数，调用上一次render的销毁函数，调用本次render的回调函数。
在v16中第一版是同步执行的，在官方博客中提到：
副作用清理函数（如果存在）在 React 16 中同步运行。我们发现，对于大型应用程序来说，这不是理想选择，因为同步会减缓屏幕的过渡（例如，切换标签）。
基于这个原因，在v17.0.0中，useEffect的两个阶段会在页面渲染后（layout阶段后）异步执行。
事实上，从代码中看，v16.13.1中已经是异步执行了。

useEffect的执行需要保证所有组件useEffect的销毁函数必须都执行完后才能执行任意一个组件的useEffect的回调函数。
这是因为多个组件间可能共用同一个ref。

如果不是按照“全部销毁”再“全部执行”的顺序，那么在某个组件useEffect的销毁函数中修改的ref.current可能影响另一个组件useEffect的回调函数中的同一个ref的current属性。

在useLayoutEffect中也有同样的问题，所以他们都遵循“全部销毁”再“全部执行”的顺序。

所以useEffect执行分两个阶段，销毁函数的全部执行和回调函数的全部执行。

layout阶段通过schedulePassiveEffects调度useEffect的销毁函数和回调函数，从函数组件对应的 fiber 上获取上面挂载的 effect，然后将 effect 和 fiber 堆到 pendingPassiveHookEffectsUnmount 和 pendingPassiveHookEffectsMount 这个两个队列中。

在阶段一，会遍历并执行所有useEffect的销毁函数。
```js
// pendingPassiveHookEffectsUnmount中保存了所有需要执行销毁的useEffect
const unmountEffects = pendingPassiveHookEffectsUnmount;
  pendingPassiveHookEffectsUnmount = [];
  for (let i = 0; i < unmountEffects.length; i += 2) {
    const effect = ((unmountEffects[i]: any): HookEffect);
    const fiber = ((unmountEffects[i + 1]: any): Fiber);
    const destroy = effect.destroy;
    effect.destroy = undefined;

    if (typeof destroy === 'function') {
      // 销毁函数存在则执行
      try {
        destroy();
      } catch (error) {
        captureCommitPhaseError(fiber, error);
      }
    }
  }
```
在阶段二，会遍历并执行所有useEffect的回调函数。
```js
// pendingPassiveHookEffectsMount中保存了所有需要执行回调的useEffect
const mountEffects = pendingPassiveHookEffectsMount;
pendingPassiveHookEffectsMount = [];
for (let i = 0; i < mountEffects.length; i += 2) {
  const effect = ((mountEffects[i]: any): HookEffect);
  const fiber = ((mountEffects[i + 1]: any): Fiber);
  
  try {
    const create = effect.create;
   effect.destroy = create();
  } catch (error) {
    captureCommitPhaseError(fiber, error);
  }
}
```


整个layout阶段逻辑就是这些。
注意到current Fiber树切换代码是在layout阶段的第一行。
在双缓存机制一节我们介绍过，workInProgress Fiber树在commit阶段完成渲染后会变为current Fiber树。这行代码的作用就是切换fiberRootNode指向的current Fiber树。

那么这行代码为什么在这里呢？（在mutation阶段结束后，layout阶段开始前。）

我们知道componentWillUnmount会在mutation阶段执行。此时current Fiber树还指向前一次更新的Fiber树，在生命周期钩子内获取的DOM还是更新前的。componentDidMount和componentDidUpdate会在layout阶段执行。此时current Fiber树已经指向更新后的Fiber树，在生命周期钩子内获取的DOM就是更新后的。

要注意到，mutation阶段构建了新的dom树，layout阶段的componentDidMount之前其实只是完成了渲染树，执行了一些生命周期和effect，最终渲染树定型，这时候所有数据有了，但是控制权还在js线程手中，这时候在componentDidMount中执行setState或者其他一些dom修改，最后浏览器只会保留最终的结果，layout之后应当就是paint，将控制权交给渲染线程，渲染线程根据document，完成屏幕真正的绘制工作。

