# 理解react更新渲染步骤必须从[架构](https://react.iamkasong.com/process/doubleBuffer.html)入手。

## React15架构
react15架构分为两层：
reconciler（协调器），负责找出变化的组件 （需要深刻理解的过程）
renderer（渲染器），负责将变化的组件渲染到页面上（真正的执行由reactDOM.render来做 由开发者写的代码其实都是描述如何构建虚拟dom树 react16开始叫fiber树）

### Reconciler（协调器）构建虚拟DOM
我们知道，在React中可以通过this.setState、this.forceUpdate、ReactDOM.render等API触发更新。

每当有更新发生时，Reconciler会做如下工作：

1. 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM
2. 将虚拟DOM和上次更新时的虚拟DOM对比
3. 通过对比找出本次更新中变化的虚拟DOM
4. 通知Renderer调用宿主环境api，将变化的虚拟DOM渲染到页面上

### Renderer（渲染器）将虚拟DOM映射到真实DOM通知浏览器执行绘制
由于React支持跨平台，所以不同平台有不同的Renderer。我们前端最熟悉的是负责在浏览器环境渲染的Renderer —— ReactDOM。

除此之外，还有：

1. ReactNative渲染器，渲染App原生组件
2. ReactTest渲染器，渲染出纯Js对象用于测试
3. ReactArt渲染器，渲染到Canvas, SVG 或 VML (IE8)
在每次更新发生时，Renderer接到Reconciler通知，将变化的组件渲染在当前宿主环境。

### React15架构的缺点
在Reconciler中，mount的组件会调用mountComponent ，update的组件会调用updateComponent。这两个方法都会递归更新子组件。
由于递归执行，所以更新一旦开始，中途就无法中断。当层级很深时，递归更新时间超过了16.7ms(浏览器的一帧)，用户交互就会卡顿。

一个例子：初始化时state.count = 1，每次点击按钮state.count++，列表中3个li元素的值分别为1，2，3乘以state.count的结果。
递归更新子组件，Reconciler发现第一元素1需要变成2，构建虚拟DOM，通知Renderer更新DOM 第一个元素由1到2，发现第二元素2需要变成4，构建虚拟DOM，通知Renderer更新DOM 第一个元素由2到4。。。
总之，Reconciler和Renderer是交替工作的，当第一个li在页面上已经变化后，第二个li再进入Reconciler。由于整个过程都是同步的无法被打断，当所有虚拟DOM更新完毕后，Renderer统一将虚拟DOM映射到真实DOM，js交出线权，通知渲染引擎执行页面绘制，所以在用户看来所有DOM都是同步更新的，没有出现三个子元素依此更新的异常。但是唯一的问题就是当递归更新时间超长，渲染必定卡顿。

解决办法——用可中断的异步更新代替同步的更新。15无法支持，于是有了react16的重大升级。


## React16架构
React16架构可以分为三层：

Scheduler（调度器）—— 调度任务的优先级，高优任务优先进入Reconciler
Reconciler（协调器）—— 负责找出变化的组件 构建虚拟DOM
Renderer（渲染器）—— 负责将变化的组件渲染到页面上 将虚拟DOM映射到真实DOM通知浏览器执行绘制
可以看到，相较于React15，React16中新增了Scheduler（调度器），让我们来了解下他。

### Scheduler（调度器）Scheduler是独立于React的库
既然我们以浏览器是否有剩余时间作为任务中断的标准，那么我们需要一种机制，当浏览器有剩余时间时通知我们。

其实部分浏览器已经实现了这个API，这就是requestIdleCallback。

```
// 开启调⽤
var handle = window.requestIdleCallback(callback[, options])

// 结束调用 
Window.cancelIdleCallback(handle)
```

requestIdleCallback接收⼀个回调，这个回调会在浏览器空闲时调⽤，每次调⽤会传⼊⼀个IdleDeadline，可以拿到当前还空余多久，options可以传⼊参数最多等多久，等到了时间浏览
器还不空就强制执⾏了，使⽤这个API可以解决任务调度的问题，让浏览器在空闲时才计算diff并渲染；


但是由于以下因素，React放弃使用：

1. 浏览器兼容性
2. 触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低

基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，Scheduler还提供了多种调度优先级供任务设置。

### Reconciler（协调器）
我们知道，在React15中Reconciler是递归处理虚拟DOM的。让我们看看React16的Reconciler (opens new window)。
Reconciler内部采用了Fiber的架构。

我们可以看见，更新工作从递归变成了可以中断的循环过程。每次循环都会调用shouldYield判断当前是否有剩余时间。
```js
/** @noinline */
function workLoopConcurrent() {
  // Perform work until Scheduler asks us to yield
  while (workInProgress !== null && !shouldYield()) {
    workInProgress = performUnitOfWork(workInProgress);
  }
}
```
那么React16是如何解决中断更新时DOM渲染不完全的问题呢？

在React16中，Reconciler与Renderer不再是交替工作。当Scheduler将任务交给Reconciler后，Reconciler会为变化的虚拟DOM打上代表增/删/更新的标记，类似这样：
```js
export const Placement = /*             */ 0b0000000000010;
export const Update = /*                */ 0b0000000000100;
export const PlacementAndUpdate = /*    */ 0b0000000000110;
export const Deletion = /*              */ 0b0000000001000;
```
整个Scheduler与Reconciler的工作都在内存中进行。只有当所有组件都完成Reconciler的工作，才会统一交给Renderer。

### Renderer（渲染器）
Renderer根据Reconciler为虚拟DOM打的标记，同步执行对应的DOM操作。

所以在react16中执行一次状态更新，如点击button让count由1变成2。
scheduler接收到更新，先判断有没有其他高优先级更新需要执行，没有其他更新，则将状态变化1到2交给reconciler。
reconciler接收到更新，比对虚拟DOM，将需要更新的虚拟DOM打上update delete等标记，虚拟DOM完全是在内存中操作的一个对象，标记完成后将打了标记的虚拟DOM交给renderer。
renderer接收到通知，根据标记后到虚拟DOM执行DOM操作，js交出线权，交给渲染引擎绘制页面。

注意最重要的一点就是scheduler和renconciler打标记是可以随时打断的：
1. 有其他高优先级任务需要先更新
2. 当前帧16.7ms没有剩余时间了

由于scheduler和reconciler的工作结果完全是在内存之中，即使反复中段用户也不会看见更新不完全的DOM。其实react15的递归更新虚拟DOM交替执行reconciler和renderer的方式也不会造成不完全的DOM，因为虽然通知了renderer，但是整个递归更新子元素的过程无法中断，js引擎一直掌握线权，页面在整个递归完毕前一直无法更新绘制。


从React15到React16，协调器（Reconciler）重构的一大目的是：将老的同步更新的架构变为异步可中断更新。

