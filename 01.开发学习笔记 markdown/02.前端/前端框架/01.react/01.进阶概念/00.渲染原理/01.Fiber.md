

js引擎和⻚⾯渲染引擎两个线程是互斥的，当其中⼀个线程执⾏时，另⼀个线程只能挂起。如果js长期占据，渲染引擎长期等待就会让页面响应变差。
这就是React15的stack reconciler面对的问题，react此时的更新一旦开启无法中断，那么必须等处理完毕更新到真实dom后才能渲染。

在React Conf 2017上，React Fiber在React16版本发布。

主要做了这些工作：
为每个操作增加优先级，优先级高的任务可以中断优先级低的任务，然后再重新执行，注意是重新执行低优先级低任务。
增加了异步调度任务的功能，实现了requestIdleCallback的polyfill。空闲时执行。
虚拟dom树变成了fiberNode组成的链表。

需要支持更新任务的异步可中断，必须实现任务的异步调度和支持中断的新的数据结构。
一个是requestIdleCallback的polyfill，一个就是fiber结构。

Fiber把渲染更新过程拆分成多个⼦任务，每次只做⼀⼩部分，做完看是否还有剩余时间，如果有继续下⼀个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执⾏。即可以中断和恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同优先级，其中每个任务更新单元为React Element对应的Fiber节点。
 
# fiber结构
一个fiber就是一个js对象，包含了元素的信息、该元素的更新操作队列、类型等，数据结构如下：

```js
// 在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。
// 为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。

// 解释fiber
// 作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。
// 作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
// 作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

// ReactElement作为jsx返回的数据结构，描述了jsx的结构，核心是type key props。
// 可见它无法表达节点之间的关系，也没有保存状态。
// 为了实现fiber功能，我们需要定义一个新的数据结构，FiberNode
// 它介于ReactElement与真实UI节点之间
// 能够表达节点之间的关系
// 方便拓展（不仅作为数据存储单元，也能作为工作单元）
// 这就是FiberNode（虚拟DOM在React中的实现）

export class FiberNode {
	// 作为静态数据结构的属性
	// tag, 哪种类型的节点
	// Fiber对应组件的类型 FunctionComponent/ClassComponent/Host...
	tag: WorkTag;
	// ReactElement里的key
	key: Key;
	// 大部分情况同type，某些情况不同，比如FunctionComponent使用React.memo包裹
	// 是ReactElement.type，调用createElement的第一个参数
	elementType: null;
	// FiberNode的类型
	// 对于 FunctionComponent，指函数本身，对于ClassComponent，指class，对于HostComponent，指DOM节点tagName
	type: any;
	// Fiber对应的真实DOM节点
	// 对于HostComponent这种tag。例如是div,stateNode就保存了这个div的dom
	stateNode: any;

	// 用于连接其他Fiber节点形成Fiber树
	// 每个Fiber节点有个对应的ReactElement，多个Fiber节点靠以下属性连接形成树
	// return指向父FiberNode
	// 为什么用return这种关键字名，因为我们是把FiberNode作为一个工作单元，当它工作完毕就轮到处理父工作单元了。
	// return指节点执行完completeWork后会返回的下一个节点，子Fiber节点及其兄弟节点完成工作后会返回其父级节点，所以用return指代父级节点。
	return: FiberNode | null;
	// 右边的兄弟FiberNode
	sibling: FiberNode | null;
	// 第一个子FiberNode
	child: FiberNode | null;
	// 在父级中的顺序
	index: number;

	ref: Ref; // null | (((handle: mixed) => void) & { _stringRef: ?string }) | RefObject,

	// 作为动态的工作单元的属性
	// 保存本次更新造成的状态改变相关信息 刚开始工作时的props是什么
	// 是当前处理过程中的组件props对象
	pendingProps: Props | null;
	// 工作完成时，稳定下来的props是什么
	// 上一次渲染完成之后的props
	memoizedProps: Props | null;
	// 该Fiber对应的组件产生的Update会存放在这个队列里
	updateQueue: null;
	// 上一次渲染时的state
	memoizedState: null;
	dependencies: null;
   
   // 一个列表 存放这个Fiber依赖的context
   firstContextDependency: ContextDependency<mixed> | null
	mode: null;
	
	// 保存本次更新会造成的DOM操作
	// 用来记录side Effect
	effectTag: null;
	// 单链表 用来快速查看下一个side Effect
	nextEffect: null;
   
   // 子树中第一个side Effect
	firstEffect: null;
	// 子树中最后一个side Effect
	lastEffect: null;
   
	// 调度优先级相关
	lanes: null;
	// 快速确定子树中是否有不在等待的变化
	childLanes: null;

	// 所谓的双缓冲技术，所有ReactElement比较完成后，生成一棵fiberNode树，存在current tree和workInProgress Tree两棵fiberNode树
	// alternate 控制这两种状态的切换
	// 如果目前的的FiberNode是current，那么它的alternate就指向它的workInprogress，反之亦然。
	alternate: FiberNode | null;

	// 副作用
	// 保存状态更新时 比较ReactElement后在FiberNode打上的增删改dom的标记
	flags: Flags;

	constructor(tag: WorkTag, pendingProps: Props, key: Key) {
		// 作为静态数据结构的属性
		this.tag = tag;
		this.key = key;
		this.elementType = null;
		this.type = null;
		this.stateNode = null;

		// 用于连接其他Fiber节点形成Fiber树
		this.return = null;
		this.child = null;
		this.sibling = null;
		this.index = 0;

		this.ref = null;

		// 作为动态的工作单元的属性
		this.pendingProps = pendingProps;
		this.memoizedProps = null;
		this.updateQueue = null;
		this.memoizedState = null;
		this.dependencies = null;

		// this.mode = mode;

		// this.effectTag = NoEffect;
		this.nextEffect = null;

		this.firstEffect = null;
		this.lastEffect = null;

		// 调度优先级相关 和Scheduler相关
		// this.lanes = NoLanes;
		// this.childLanes = NoLanes;

		// 指向该fiber在另一次更新时对应的fiber
		this.alternate = null;
		this.flags = NoFlags;
	}
}
```

### fiber
异步可中断更新可以理解为：更新在执行过程中可能会被打断（浏览器时间分片用尽或有更高优任务插队），当可以继续执行时恢复之前执行的中间状态。

其实，浏览器原生就支持类似的实现，这就是Generator。但是Generator的一些缺陷使React团队放弃了他：
类似async，Generator也是传染性的，使用了Generator则上下文的其他函数也需要作出改变。这样心智负担比较重。
Generator执行的中间状态是上下文关联的。

代数效应与Fiber：
Fiber并不是计算机术语中的新名词，他的中文翻译叫做纤程，与进程（Process）、线程（Thread）、协程（Coroutine）同为程序执行过程。
在很多文章中将纤程理解为协程的一种实现。在JS中，协程的实现便是Generator。
所以，我们可以将纤程(Fiber)、协程(Generator)理解为代数效应思想在JS中的体现。
React Fiber可以理解为：React内部实现的一套状态更新机制。支持任务不同优先级，可中断与恢复，并且恢复后可以复用之前的中间状态。
其中每个任务更新单元为React Element对应的Fiber节点。

react16中虚拟DOM在react中有个正式的称呼 fiber。

在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。

为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。

Fiber是react16大更新后对虚拟dom更新时协调器的工作的称呼。
Fiber架构将不可中断的递归更新变为了可中断更新。

React Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。 维护每一个分片的数据结构，就是Fiber。 
Fiber要解决的问题： 
（1）能够将可中断的任务拆分成块。 
（2）能够对进程中的工作划分优先级、重新设定基址（Rebase）、恢复。
（3）能够在父子之间来回反复，借此为 React 的 Layout 提供支持。
（4）能够通过 render() 返回多个元素。 
（5）为错误边界提供了更好的支持。

Fiber 要想达到⽬的，需要解决两个问题：
1. 新的任务调度，有⾼优先级任务的时候将浏览器让出来，等浏览器空了再继续执⾏；React在scheduler里实现了功能完备的requestIdleCallbackpolyfill 
2. 新的数据结构，可以随时中断，下次进来可以接着执⾏；

新的数据结构是由fiberNode节点构成的链式结构。
每个fiberNode有：
child:⽗节点指向第⼀个⼦元素的指针；
sibling：从第⼀个⼦元素往后，指向下⼀个兄弟元素；
return：所有⼦元素都有的指向⽗元素的指针；
等等。

有了这⼏个指针后，我们可以在任意⼀个元素中断遍历并恢复，
Fiber这个结构外形看着还是棵树，但是没有了指向所有⼦元素的指针，⽗节点只指向第⼀个⼦节点，然后⼦节点有指向其他⼦节点的指针，这其实是个链表。

遍历的时候从根节点出发，先找⼦元素，如果⼦元素存在，直接返回，如果没有⼦元素了就找兄弟
 元素，找完所有的兄弟元素后再返回⽗元素，然后再找这个⽗元素的兄弟元素。整个遍历过程其实
 是个深度优先遍历（DFS），从上到下，然后最后⼀⾏开始从左到右遍历；

#### Fiber的含义
Fiber包含三层含义：
作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。
作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。
作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。

#### Fiber工作原理

##### 什么是“双缓存”
当我们用canvas绘制动画，每一帧绘制前都会调用ctx.clearRect清除上一帧的画面。

如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。

为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。

这种在内存中构建并直接替换的技术叫做双缓存 。

##### 双缓存Fiber树
React使用“双缓存”来完成Fiber树的构建与替换——对应着DOM树的创建与更新。

在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树存在于**render阶段**，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树，被称为workInProgress Fiber树。

已构建完的workInProgress Fiber树在**commit阶段**渲染到页面。workInProgress Fiber树被切换成current Fiber树。

current Fiber树中的Fiber节点被称为current fiber，workInProgress Fiber树中的Fiber节点被称为workInProgress fiber，他们通过alternate属性连接。

React应用的根节点通过使current指针在不同Fiber树的rootFiber间切换来完成current Fiber树指向的切换。

即当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。

每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。

在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，决定是否复用的算法就是diff。