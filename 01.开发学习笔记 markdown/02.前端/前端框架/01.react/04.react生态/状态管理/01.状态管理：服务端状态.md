

按照来源，前端有两类「状态」需要管理：

* 用户交互的中间状态
* 服务端状态

在之前的项目中，通常用Redux、Mobx这样的「全局状态管理方案」无差别对待他们。

事实上，他们有很大区别：

# 用户交互的中间状态
比如组件的isLoading、isOpen，这类「状态」的特点是：

* 以「同步」的形式更新
* 「状态」完全由前端控制
* 「状态」比较独立（不同的组件拥有各自的isLoading）

这类「状态」通常保存在组件内部。
当「状态」需要跨组件层级传递，通常先状态提升，组合组件解决。
全局性的不经常修改的属性，使用Context API。
再大范围的「状态」会使用Redux这样的「全局状态管理方案」。

# 服务端状态(服务端状态缓存)
当我们从服务端请求数据：

```js
function App() {
  const [data, updateData] = useState(null);
  
  useEffect(async () => {
    const data = await axios.get('/api/user');
    updateData(data);
  }, [])

  // 处理data
}
```

返回的数据通常作为「状态」保存在组件内部（如App组件的data状态）。

如果是需要复用的通用「状态」，通常将其保存在Redux这样的「全局状态管理方案」中。

这样做有2个坏处：

1. 需要重复处理请求中间状态
为了让App组件健壮，我们还需要处理请求中、出错等中间状态：

function App() {
  const [data, updateData] = useState(null);
  const [isError, setError] = useState(false);
  const [isLoading, setLoading] = useState(false);
  
  useEffect(async () => {
    setError(false);
    setLoading(true);
    try {
      const data = await axios.get('/api/user');
      updateData(data);
    } catch(e) {
      setError(true);
    }
    setLoading(false);
  }, [])

  // 处理data
}
这类通用的中间状态处理逻辑可能在不同组件中重复写很多次。

2. 「缓存」的性质不同于「状态」
不同于交互的中间状态，服务端状态更应被归类为「缓存」，他有如下性质：

* 通常以「异步」的形式请求、更新
* 「状态」由请求的数据源控制，不由前端控制
* 「状态」可以由不同组件共享

作为可以由不同组件共享的「缓存」，还需要考虑更多问题，比如：

* 缓存失效
* 缓存更新

Redux一把梭固然方便。但是，区别对待不同类型「状态」能让项目更可控。


这里，推荐使用React-Query管理服务端状态。

其他同类方案还有SWR，react-router缓存（和react-router绑定），redux-toolkit query(和redux toolkit绑定)等

具体区别可见：
[React Query vs SWR vs Apollo vs RTK Query vs React Router](https://cangsdarm.github.io/react-query-web-i18n/getstarted/comparison/)
[RTK query Comparison with Other Tools](https://redux-toolkit.js.org/rtk-query/comparison)



通过使用React-Query（或SWR）这样的数据请求库，可以将服务端状态从全局状态中解放出来。

这为我们带来很多好处：

使用通用的hook处理请求中间状态
多余请求合并
针对缓存的更新/失效策略
Redux等「全局状态管理方案」可以更专注于「前端中间状态」处理