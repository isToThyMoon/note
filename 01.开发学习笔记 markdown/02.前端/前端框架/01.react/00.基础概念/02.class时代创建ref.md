

尽管通过状态和jsx，我们实现了UI=f(state)并且react不推荐开发者直接命令式操作dom，而是采用数据驱动UI变化。
但某些特殊情况下我们还是需要直接操作dom的一些行为，如input框的聚焦。
ref是一个逃生舱，允许我们直接操作dom。
而且react在此基础上允许ref绑定react组件，访问子组件方法和属性，或通过ref转发的形式，访问子组件的dom。


另外一个逃生舱是hooks组件的useEffect，在此不作展开。

ref绑定dom：
```ts
import React, { createRef, RefObject } from 'react';

// redux
import { AnyAction } from 'redux';
// import { actionCreators } from './store';
import { connect } from 'react-redux';

// ts redux
import { ThunkDispatch } from 'redux-thunk';


export interface AppProps {
}

export interface AppState {
    
}

class UserbehaviorView extends React.Component<AppProps, AppState>{
    
    myRef: RefObject<HTMLDivElement>;

    // static contextType = idContext;

    constructor(props: AppProps) {
        super(props);
        // 创建ref
        this.myRef = createRef();

        this.state={
        }
    }
    
    componentDidMount(): void {
        //使用ref
        const chartPlaceholder = this.myRef.current;
    
    
    }

    render(): React.ReactNode{
        return (
            <React.Fragment>
                <!--绑定ref-->
                <div className="chart-placeholder" style={{marginTop: '15px'}} ref={this.myRef}/>
            </React.Fragment>
        )
    }
}

const mapStateToProps = (state:any)=>{
    return {
        comId: state.getIn(['APP', 'comId']),
    }
}

const mapDispatchToProps = (dispatch: ThunkDispatch<any,any,AnyAction>)=>{
    return {
        dispatchSwitchDetailDataModal(){
            dispatch({
                type: 'DISPATCHGETDETAILUSERBEV',
                value: {userBevModalVisiable: false, userBevModalData: []}
            })
        },
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(UserbehaviorView);

// export default UserbehaviorView;

```

ref访问子组件方法：
```js
// ParentComponent.js
import React, { Component } from 'react';
import ChildComponent from './ChildComponent';

class ParentComponent extends Component {
  constructor(props) {
    super(props);
    this.childRef = React.createRef();
  }

  handleClick = () => {
    // 通过ref引用调用子组件方法
    this.childRef.current.childMethod('参数值');
  }

  render() {
    return (
      <div>
        <ChildComponent ref={this.childRef} />
        <button onClick={this.handleClick}>调用子组件方法</button>
      </div>
    );
  }
}

export default ParentComponent;


// ChildComponent.js
import React, { Component } from 'react';

class ChildComponent extends Component {
  childMethod = (parameter) => {
    console.log('子组件的方法被调用，参数:', parameter);
    // 执行子组件的逻辑
  }

  render() {
    return <div>子组件内容</div>;
  }
}

export default ChildComponent;
```