---
title: 08.props和state render函数
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
tags:
  - react项目
date:
---

# state
state是组件自己管理数据，控制自己的状态，可变；
state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。
在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。

# props

React 元素也可以是用户自定义的组件：
`const element = <Welcome name="Sara" />;`
当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。

例如，这段代码会在页面上渲染 “Hello, Sara”：

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性(不可内部修改)，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

没有state的叫做无状态组件，有state的叫做有状态组件；
多用props，少用state。也就是多写无状态组件。


当组件的state或者props发生改变时render函数就会重新执行
当父组件的render函数被运行时 子组件的render都将被重新运行一次



# setState后台做了什么
React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染。

setState可以接受函数为参数。当 setState 执行完成且组件被渲染完成时，将调用回调函数。由于 setState 是异步的，因此下一步执行的任何操作都可以使用该回调函数。 在 setState完成后会调用回调函数，下一步需要执行的任何操作都可以使用该回调函数来实现。建议使用生命周期方法而不是该回调函数。

setState 中的第一个参数也可以传入函数，其结构为 function(state, props) => newState。这个函数会将每次更新都加入队列中，执行时通过当前的 state 和 props 来获取新的 state。这样一来 React 就不会将对象合并（显然根本没有对象让他合并），把多次状态修改打包后进行一次批处理操作了。