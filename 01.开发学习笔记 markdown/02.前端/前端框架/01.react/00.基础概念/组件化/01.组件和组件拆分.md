---
title: 02.定义组件
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
date:
---

# 组件
定义组件最简单的方式就是编写 JavaScript 函数：

```javascript 
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
该函数是一个有效的 React 组件，因为它接收唯一带有数据的 “props”（代表属性）对象与并返回一个 React 元素。这类组件被称为“函数组件”，因为它本质上就是 JavaScript 函数。

同时还可以使用 ES6 的 class 来定义组件，因为es6 class语法本质就是创建了一个构造函数。

这里接受唯一带有数据的props 返回一个React元素，就是所谓的纯函数，唯一的输入对应唯一的返回，没有副作用。

```javascript

import React from 'react';

//定义一个组件
//新建一个App类继承自React.Component 它就是一个React的组件了
class App extends React.Component {
  render() {
    return (
      //jsx语法
      <div>
      hello world
      </div>
    );
  }
}

export default App;
-----------------
// app.js 定义App组件   index.js作为入口 引用并渲染这些组件
-----------------
另一种写法：

import React, { Component } from 'react';  // 结构赋值

// import { Component } from 'react';
// //等价于
// import React from 'react';
// const Component = React.Component;
class App extends Component {
  render() {
    return (
      <div>
      hello world
      </div>
    );
  }
}

export default App;

```

# props类型和默认props
一个组件的propTypes 和 defaultProps:

父组件向子组件传值 子组件不知道传来的是props还是直接手写的内容 但是可以在子组件中校验。
子组件要确认传的值是固定类型 用propTypes作传值的强校验

``` javascript

import React, { Component } from 'react';
import PropTypes from 'prop-types';

class Todoitem extends Component {

	constructor(props) {
		super(props);
		this.handleClick = this.handleClick.bind(this);
	}

	render() {
		const { content } = this.props;
		return (
			<div onClick = {this.handleClick}>
				{content}
			</div>
		)
	}


	handleClick() {
		const { deleteItem, index } = this.props;
		deleteItem(index);

	}

}


Todoitem.propTypes = {
	content: PropTypes.string.isRequired,   //isRequired表示必须要传递
	deleteItem: PropTypes.func,
	index: PropTypes.number
}

TodoItem.defaultProps = {
  test: 'hello world',
}

export default Todoitem;

// defaultProps 表示如果没有接受到传递的值 给一个默认的值

```
事实上有了ts和hooks组件之后几乎没人这么写class组件了。

# 组件拆分
还是拆分、封装的coding思维。只不过对于前端来说，一个重大的拆分项就是UI和业务逻辑的分离。

UI组件：负责页面的渲染
容器组件：负责页面的逻辑

无状态组件：
当一个组件内只有render函数时 就可以用无状态组件定义它
```js
const TodoListUI = (props) => {
      return (
        内容
      )
}
```

无状态组件来表示UI组件时，直接纯函数表达，在接收使用父组件传来的值和方法时，就不用写`value ={this.props.inputValue}`了。
直接写 `value = {props.inputValue}`

我的理解 它只是一个函数而已。

最理想情况UI组件当然是无状态组件纯函数最好，但这不代表UI组件就不能有状态只能是无状态组件，UI组件内有些UI相关的控制需要状态去保存非常正常，我们需要抽离的是UI无关的业务逻辑，放到容器组件中，或者到全局状态处理，或者单独的逻辑文件。