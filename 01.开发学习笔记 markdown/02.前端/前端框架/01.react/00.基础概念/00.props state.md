---
title: 08.props和state
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
tags:
  - react项目
date:
---

# state
state是组件自己管理数据，控制自己的状态，可变；
state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。
在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。

# props

React 元素也可以是用户自定义的组件：
`const element = <Welcome name="Sara" />;`
当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。

例如，这段代码会在页面上渲染 “Hello, Sara”：

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性(不可内部修改)，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

没有state的叫做无状态组件，有state的叫做有状态组件；
多用props，少用state。也就是多写无状态组件。


当组件的state或者props发生改变时render函数就会重新执行
当父组件的render函数被运行时 子组件的render都将被重新运行一次



# setState后台做了什么
React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染。

setState可以接受函数为参数。当 setState 执行完成且组件被渲染完成时，将调用回调函数。由于 setState 是异步的，因此下一步执行的任何操作都可以使用该回调函数。 在 setState完成后会调用回调函数，下一步需要执行的任何操作都可以使用该回调函数来实现。建议使用生命周期方法而不是该回调函数。

setState 中的第一个参数也可以传入函数，其结构为 function(state, props) => newState。这个函数会将每次更新都加入队列中，执行时通过当前的 state 和 props 来获取新的 state。这样一来 React 就不会将对象合并（显然根本没有对象让他合并），把多次状态修改打包后进行一次批处理操作了。


# props 和state区别？ 

都是用来保存信息的，用来控制组件的渲染输出，props是传递给组件的（类似于函数的形参），而state是在组件内部被组件自己管理的。

TL；DR：
If a Component needs to alter one of its attributes at some point in time, that attribute should be part of its state, otherwise it should just be a prop for that Component.

When a component needs to keep track of information between renderings the component itself can create, update, and use state.

props contains information set by the parent component (although defaults can be set) and should not be changed.state contains “private” information for the component to initialise, change, and use on it’s own.

Should this Component have state?

state is optional. Since state increases complexity and reduces predictability, a Component without state is preferable. Even though you clearly can't do without state in an interactive app, you should avoid having too many Stateful Components.

Stateless Component — Only props, no state. There's not much going on besides the render() function and all their logic revolves around the props they receive. This makes them very easy to follow (and test for that matter). We sometimes call these dumb-as-f*ck Components (which turns out to be the only way to misuse the F-word in the English language).

纯props提供数据模型，没有自身state的组件，react称之为无状态组件，官方是推崇这种组件的，易于跟踪数据流，测试用例编写简单，只要能写无状态组件，那一定是首选。

Stateful Component — Both props and state. We also call these state managers. They are in charge of client-server communication (XHR, web sockets, etc.), processing data and responding to user events. These sort of logistics should be encapsulated in a moderate number of Stateful Components, while all visualization and formatting logic should move downstream into as many Stateless Components as possible.

其实就是容器组件和UI组件的分别。
有状态的组件（容器组件）没有渲染，有渲染的组件（UI组件）没有状态。
展示组件+容器组件这样的实践一直都是社区提倡的最佳实践，这样的模式有几个好处：

更好的关注分离：
关注点分离是一个在编程中广泛使用的概念。它指的是执行不同操作的逻辑不应被分组或结合在一起。例如我们把获取数据和展示数据放在了同一个组件中就违反了关注点分离。

若要解决这个问题，并且遵循关注点分离，我们应该将两块（即：获取数据和在 UI 上展示）逻辑分开放置在不同的组件。

更好的复用性：
展示和容器分离能达到更好的复用性（HOC一直倡导的容器组件和UI组件分离），相同的展示组件可以同不同的状态组合在一起进一步转化成可复用的容器组件。也就是带状态的逻辑复用方案。

react hook自定义hook实现了对容器组件/UI组件分离方案的替代。

-------

为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 DRY: Don’t Repeat Yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。

通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

1.该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
2.该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
3.你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。