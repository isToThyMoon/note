---
title: 08.props和state
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 01.react
tags:
  - react项目
date:
---

# state
state是组件自己管理数据，控制自己的状态，可变；
state的主要作用是用于组件保存、控制以及修改自己的状态，它只能在constructor中初始化，它算是组件的私有属性，不可通过外部访问和修改，只能通过组件内部的this.setState来修改，修改state属性会导致组件的重新渲染。
在组件初始化的时候，通过this.state给组件设定一个初始的state，在第一次render的时候就会用这个数据来渲染组件。

# props

React 元素也可以是用户自定义的组件：
`const element = <Welcome name="Sara" />;`
当 React 元素为用户自定义组件时，它会将 JSX 所接收的属性（attributes）以及子组件（children）转换为单个对象传递给组件，这个对象被称之为 “props”。

例如，这段代码会在页面上渲染 “Hello, Sara”：

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

const element = <Welcome name="Sara" />;
ReactDOM.render(
  element,
  document.getElementById('root')
);
```

props是一个从外部传进组件的参数，主要作为就是从父组件向子组件传递数据，它具有可读性和不变性(不可内部修改)，只能通过外部组件主动传入新的props来重新渲染子组件，否则子组件的props以及展现形式不会改变。

没有state的叫做无状态组件，有state的叫做有状态组件；
多用props，少用state。也就是多写无状态组件。


当组件的state或者props发生改变时render函数就会重新执行
当父组件的render函数被运行时 子组件的render都将被重新运行一次

# props 和state区别？ 

都是用来保存信息的，用来控制组件的渲染输出，props是传递给组件的（类似于函数的形参），而state是在组件内部被组件自己管理的。

TL；DR：
If a Component needs to alter one of its attributes at some point in time, that attribute should be part of its state, otherwise it should just be a prop for that Component.

When a component needs to keep track of information between renderings the component itself can create, update, and use state.

props contains information set by the parent component (although defaults can be set) and should not be changed.state contains “private” information for the component to initialise, change, and use on it’s own.

Should this Component have state?

state is optional. Since state increases complexity and reduces predictability, a Component without state is preferable. Even though you clearly can't do without state in an interactive app, you should avoid having too many Stateful Components.

Stateless Component — Only props, no state. There's not much going on besides the render() function and all their logic revolves around the props they receive. This makes them very easy to follow (and test for that matter). We sometimes call these dumb-as-f*ck Components (which turns out to be the only way to misuse the F-word in the English language).

纯props提供数据模型，没有自身state的组件，react称之为无状态组件，官方是推崇这种组件的，易于跟踪数据流，测试用例编写简单，只要能写无状态组件，那一定是首选。

Stateful Component — Both props and state. We also call these state managers. They are in charge of client-server communication (XHR, web sockets, etc.), processing data and responding to user events. These sort of logistics should be encapsulated in a moderate number of Stateful Components, while all visualization and formatting logic should move downstream into as many Stateless Components as possible.

其实就是容器组件和UI组件的分别。
有状态的组件（容器组件）没有渲染，有渲染的组件（UI组件）没有状态。
展示组件+容器组件这样的实践一直都是社区提倡的最佳实践，这样的模式有几个好处：

更好的关注分离：
关注点分离是一个在编程中广泛使用的概念。它指的是执行不同操作的逻辑不应被分组或结合在一起。例如我们把获取数据和展示数据放在了同一个组件中就违反了关注点分离。

若要解决这个问题，并且遵循关注点分离，我们应该将两块（即：获取数据和在 UI 上展示）逻辑分开放置在不同的组件。

更好的复用性：
展示和容器分离能达到更好的复用性（HOC一直倡导的容器组件和UI组件分离），相同的展示组件可以同不同的状态组合在一起进一步转化成可复用的容器组件。也就是带状态的逻辑复用方案。

react hook自定义hook实现了对容器组件/UI组件分离方案的替代。

-------

为了正确地构建应用，你首先需要找出应用所需的 state 的最小表示，并根据需要计算出其他所有数据。其中的关键正是 DRY: Don’t Repeat Yourself。只保留应用所需的可变 state 的最小集合，其他数据均由它们计算产生。比如，你要编写一个任务清单应用，你只需要保存一个包含所有事项的数组，而无需额外保存一个单独的 state 变量（用于存储任务个数）。当你需要展示任务个数时，只需要利用该数组的 length 属性即可。

通过问自己以下三个问题，你可以逐个检查相应数据是否属于 state：

1.该数据是否是由父组件通过 props 传递而来的？如果是，那它应该不是 state。
2.该数据是否随时间的推移而保持不变？如果是，那它应该也不是 state。
3.你能否根据其他 state 或 props 计算出该数据的值？如果是，那它也不是 state。


# setState后台做了什么
React会做的第一件事就是把你传递给setState的参数对象合并到组件原先的state。这个事件会导致一个“reconciliation”（调和）的过程。reconciliation的最终目标就是，尽可能以最高效的方法，去基于新的state来更新UI。为了达到这个目的，React会构建一个React元素树（你可以把这个想象成一个表示UI的一个对象）。一旦这个树构建完毕，React为了根据新的state去决定UI要怎么进行改变，它会找出这棵新树和旧树的不同之处。React能够相对精确地找出哪些位置发生了改变以及如何发生了什么变化，并且知道如何只通过必要的更新来最小化重渲染。

setState可以接受函数为参数。当 setState 执行完成且组件被渲染完成时，将调用回调函数。由于 setState 是异步的，因此下一步执行的任何操作都可以使用该回调函数。 在 setState完成后会调用回调函数，下一步需要执行的任何操作都可以使用该回调函数来实现。建议使用生命周期方法而不是该回调函数。

setState 中的第一个参数也可以传入函数，其结构为 function(state, props) => newState。这个函数会将每次更新都加入队列中，执行时通过当前的 state 和 props 来获取新的 state。这样一来 React 就不会将对象合并（显然根本没有对象让他合并），把多次状态修改打包后进行一次批处理操作了。


# setState同步还是异步
网上有很多文章称 setState 是『异步操作』，所以导致 setState 之后并不能获取到最新值，其实这个观点是错误的。setState 是一次同步操作，只是每次操作之后并没有立即执行，而是将 setState 进行了缓存，mount 流程结束或事件操作结束，才会拿出所有的 state 进行一次计算。如果 setState 脱离了 React 的生命周期或者 React 提供的事件流，setState 之后就能立即拿到结果。

暂且把这种异步称为伪异步。

setState 只在合成事件和钩子函数中是“伪异步”的，在原生事件和 setTimeout 中都是同步的，setState 之后就能立即拿到结果。DOM 也会被同步更新，也就意味着如果你多次 setState ，会导致多次更新，这是毫无意义并且浪费性能的。（这种情况在React18之后不存在了，被做了优化，都是异步的。）

setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然你可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。


## react17之后的setState
https://juejin.cn/post/7017691338255073311

setState调用，开始调度任务，判断新任务的优先级是否是同步优先级，是则使用同步渲染模式，否则使用并发渲染模式（时间分片）。

同步渲染模式中，根据当前环境是否支持微任务调用了两个方法：scheduleMicrotask，scheduleCallback。
并发渲染模式中，也是调用了scheduleCallback。

同步渲染模式：
scheduleMicrotask这个方法主要作用是将任务添加进微任务队列：其实是使用了queueMicrotask方法，如果queueMicrotask方法不支持，则会使用Promise，如果Promise也不支持，最后会使用setTimeout来实现。

queueMicrotask是将传入的回调函数添加进微任务队列中，Promise.then方法也是被添加进微任务队列中，setTimeout则是宏任务，总的来说scheduleMicrotask方法是异步的。

并发渲染模式：
scheduleCallback则是Scheduler调度任务的入口，而Scheduler则是使用MessageChannel来实现的：
可以看到Scheduler根据宿主环境会使用不同的方式实现：

在node.js中会使用setImmediate来实现
在浏览器中会使用MessageChannel来实现
在以上方案都不能实现的时候，则降级使用setTimeout来实现
在这里我们值讨论浏览器环境，node环境之后再单独来分析。

MessageChannel是通过实例化，使用消息通道来实现消息传递，是一个宏任务。
setTimeout也是宏任务，所以Scheduler也是异步的。

很明显，react17之后，setState就是完全异步的了，通过把setState更新任务推入微任务或者宏任务队列，实现异步渲染，所以你无法立马在setState下一行代码拿到更新后的新state值。


为什么要使用异步渲染？

这和React中的Lane机制有关，在React合成事件中连续调用的setState的优先级是一样的，在第一个setState调用后，再调用第二个时，会将第一个更新任务的优先级与第二个更新任务的优先级进行比较，如果优先级一样，则不会执行第二个更新任务，而是将第二个任务的更新内容与第一个的更新内容进行合并，最终只会进行一次更新渲染，这样的做法叫做批量更新。

避免短时间内连续调用造成不必要的渲染，增加性能的开销。