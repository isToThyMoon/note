
什么是响应式（reactive）？
类似VM的架构中如react vue，它们将状态从视图层分离出来，遵循数据模型驱动页面视图更新的原则。
开发者无需关注DOM操作而是关注业务逻辑和状态变更。
开发者更新状态时，VM框架自动渲染页面完成视图的更新。这就是响应式reactive。

响应式可以被广义地定义为应用状态变化时自动更新UI。
但是，框架如何反映该状态变更UI，可能会对代码的性能和懒加载产生影响，下面会进行深入探讨。

实际上react vue这两种触发更新的风格也代表两种管理数据的风格，本章应该放在全局状态管理选择全局状态管理库的一章。
但是因为响应式风格更加底层，react原生是采用发布订阅加不可变数据的方式，而第三方也有mobx提供了可变数据代理的拓展，所以放在这儿来讲。

# react响应式
react：通过比较当前值和之前的值来检测数据变化。具体是使用虚拟DOM进行比较。数据是不可变的，这样才可以比对对象的不同。是一种比较式响应。
react的响应式是显式调用setState更新状态，核心是基于发布订阅模式。
setState状态改变，重新执行组件树，即重新运行关联组件的应用代码，构建新的VDOM或者fiber树，diff比对前后fiber树变化，打上变更tag，并按tag更新真实的dom，完成状态到UI到自动更新。

react16中执行一次状态更新（相比15多了scheduler调度器调度任务）：
scheduler接收到更新，先判断有没有其他高优先级更新需要执行，没有其他更新，则将状态变化1到2交给reconciler。

更主体实现是react中的reconciler和renderer工作。
Reconciler（协调器）接收到更新会做如下工作：
1. 调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM（16之后叫fiber树）
2. 如果是update而不是mount，将虚拟DOM和上次更新时的虚拟DOM对比
3. 通过对比找出本次更新中变化的虚拟DOM，将需要更新的fiber树打上update delete等标记，fiber树完全是在内存中操作的一个对象
4. 标记完成后将打了标记的fiber树交给renderer，通知Renderer调用宿主环境api，将变化的虚拟DOM渲染到页面上

Renderer（渲染器）接收到通知，将虚拟DOM映射到真实DOM通知浏览器执行绘制：根据标记后的fiber树执行真实DOM操作，js交出线权，交给渲染引擎绘制页面。

其中非常要注意rerender时，**调用函数组件、或class组件的render方法，将返回的JSX转化为虚拟DOM**这一步，react组件有更新时，深度遍历这棵树，进行递归更新，jsx构建是是自顶向下的进行递归更新的，也就是说，React 中假如 ChildComponent 里还有十层嵌套子元素，React 只能递归的把所有子组件都重新 render一遍（产出jsx构建虚拟dom），然后再通过diff算法决定要更新哪部分的视图，这个递归的过程叫做 reconciler。虽然说jsx的比对非常迅速，react刚出现时宣称的也是虚拟dom的比对非常迅速，减少真实dom的操作，但如果在大数据表格这种场景，多层级组件的无意义rerender。也是性能上的灾难。（因此，React 创造了Fiber，创造了异步渲染，其实本质上是弥补被自己搞砸了的性能）。

即使使用了RTK这样的全局状态管理，本质还是发布订阅模式通知对应组件rerender，其子组件即使没使用到父组件的属性，还是会rerender，这是react坚持不修改对象属性和比较式更新所决定的，如果要优化，需要对自组件进行shouldComponentUpdate或者PureComponent、React.memo等处理。

# 比较式响应和订阅式响应
react一直秉持的比较式响应，非常容易造成深层级的过多组件重渲染。
当一个props属性层层从A组件下钻传递到Z组件，也只有Z组件消费使用，但props属性修改时会造成A-Z所有组件的rerender，无法避免。
为了减少不必要rerender，react提供了useMemo useCallBack React.memo 甚至context也都被用来做react性能优化。
但这依然解决不了问题。React永远都达不到 fine-grained reactivity（细粒度响应）。

在react内部使用memoize尽量减少不必要的数据变动，但重新的jsx生成，React.createElement，还会造成Virtual DOM重新但无意义的比较，这些微不足道的消耗在组件层级过多，项目庞大时仍然会积累成不可忽视的性能消耗。

然而，这些overhead消耗，在Subscription reactivity订阅式响应压根不需要考虑，因为订阅式响应就是指哪打哪，无关数值的创建和比较压根不会发生。

在redux, mobx后，居然还能出现引起浪潮的Recoil, zustand, jotai状态管理框架，而他们毫无例外都是subscription-based reactivity（订阅式响应）。

