# SFC
vue最具识别度的设计，单文件组件：single file component
将script html style依据标签写在同一个文件里。

## 简化原理
```js
const app = Vue.createApp({
    data(){
        return {
            content: "dadada"
        }
    },
    template: `
        <div>
            {{content}}
            <button v-on:click="handleBtnClick"></button>
        <div>
    `,
    methods: {
        handleBtnClick(){
            this.content = this.content.split("").reverse().join("");
        }
    }
});
const vm = app.mount("#root");
```
到：
```js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)
const vm = app.mount('#app')
```
App.vue就是html js css统一文件的单文件组件。
createApp()接受两种形式的参数，一种是传入对象，包含data template methods等等属性，一种是单文件组件。
所以其实单文件组件的形式就是简化了createApp的传参。

## vue3兼容ts写法
```js
<template>
  <div class="container">
  ...
  </div>
</template>

<script lang="ts">
import { defineComponent, computed, onMounted, watch } from 'vue'
// static
import 'bootstrap/dist/css/bootstrap.min.css'
// vuex
import { useStore } from 'vuex'
import { GlobalDataProps } from './store'
// components
import GlobalHeader from './components/GlobalHeader.vue'
import Loader from './components/Loader.vue'
...

// defineComponent是为了支持ts vue3直接这么写composition api就行
export default defineComponent({
  name: 'App',
  components: {
    GlobalHeader,
    Loader
  },
  // 组件在js层级就是类的实例化：new Vue()；setup执行时机在所有生命周期之前，此时data method都没初始化好。
  // this也不指向当前的实例，因为初始化未完成，用了this也没什么用，所以不要和选项式api混用。
  setup() {
    // 在setup中使用数仓
    const store = useStore<GlobalDataProps>()
    // store中的数据是不能直接在setup中使用的 console出来可以看到state是灰色不可使用状态
    // v3中允许用computed这样的方式简便使用了
    const currentUser = computed(() => store.state.user)
    // loading error状态设计在根组件展示，由store内的state控制。
    const isLoading = computed(() => store.state.loading)
    const error = computed(() => store.state.error)
    // ref()和computed()返回的都是包装对象（value reference）。它只有一个属性.value
    // 包装对象的意义在于可以在函数之间以引用的方式传递任意类型值的容器 有点像react的useRef
    // 不同的是vue的包装对象同时还是响应式的数据源。有了这样的容器，我们就可以在封装了逻辑的组合函数中将状态以引用的方式传回给组件。组件负责展示（追踪依赖），组合函数负责管理状态（触发更新）
    // 包装对象也可以包装非原始值类型的对象，如数组等
    // 如果依然像创建一个没有包装的响应式对象。可以使用reactive API（和2.x的Vue.observable()等同）
    // 注意到在使用时虽然包装对象取它的值应该用.value访问，但是我们可以在模版中省略.value，它会自动展开。
    // 当包装对象被暴露给模版渲染上下文，或者被嵌套在另一个响应式对象中时，它会被自动展开成它内部的值。当一个包装对象被作为另一个响应式对象的属性引用的时候也会被自动展开 详见尤的知乎RFC。

    // 侦听属性 侦听error.value.status 如果发生改变则运行处理函数
    watch(() => error.value.status, () => {
      const { status, message } = error.value
      if (status && message) {
        // 请求返回错误时弹出错误信息
        createMessage(message, 'error')
      }
    })
    return {
      currentUser,
      isLoading,
      error
    }
  }
})
</script>

<style>

</style>

```
在 setup 函数中。所有 ES 模块导出都被认为是暴露给上下文的值，并包含在 setup() 返回对象中，setup函数导出的变量可以直接在template中使用。


## `<script setup>`
[官网介绍](https://v3.cn.vuejs.org/api/sfc-script-setup.html#%25E5%259F%25BA%25E6%259C%25AC%25E8%25AF%25AD%25E6%25B3%2595)

vue3出现一个语法糖，使用方式极其简单，仅需要在 script 标签加上 setup 关键字即可，`<script setup>`，
变量和函数等可以直接在template中使用。
该语法糖script内，所有 ES 模块导出都被认为是暴露给上下文的值，并包含在 setup() 返回对象中。相对于之前的写法，使用后，语法也变得更简单。
> 在添加了setup的script标签中，我们不必声明和方法，这种写法会自动将所有顶级变量、函数，均会自动暴露给模板（template）使用
> 这里强调一句 “暴露给模板，跟暴露给外部不是一回事”

```js
<script setup>
// variable
const msg = 'Hello!'

// functions
function log() {
  console.log(msg)
}
</script>

<template>
  <button @click="log">{{ msg }}</button>
</template>
```
属性和方法无需返回，直接使用！
这可能是带来的较大便利之一，在以往的写法中，定义数据和方法，都需要在结尾 return 出去，才能在模板中使用。在 script setup 中，定义的属性和方法无需返回，可以直接使用！示例：
```js
<template>
  <div>
   	<p>My name is {{name}}</p>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const name = ref('Sam')
</script>
```
该setup功能是新的组件选项。它是组件内部暴露出所有的属性和方法的统一API。
使用后意味着，script标签内的内容相当于原本组件声明中setup()的函数体，不过也有一定的区别。
使用 script setup 语法糖，组件只需引入不用注册，属性和方法也不用返回，也不用写setup函数，也不用写export default ，甚至是自定义指令也可以在我们的template中自动获得。

### 调用时机
创建组件实例，然后初始化 props ，紧接着就调用setup 函数。从生命周期钩子的视角来看，它会在 beforeCreate 钩子之前被调用.

### setup 参数

1. 「props」。第一个参数接受一个响应式的props，这个props指向的是外部的props。如果你没有定义props选项，setup中的第一个参数将为undifined。props和vue2.x并无什么不同,仍然遵循以前的原则； 不要在子组件中修改props；如果你尝试修改，将会给你警告甚至报错。不要解构props。解构的props会失去响应性。

2. 「context」。 第二个参数提供了一个上下文对象，从原来 2.x 中 this 选择性地暴露了一些 property。

```js
<script setup="props, context" lang="ts">
 context.attrs
 context.slots
 context.emit 
<script>
```
像这样，只要在setup处声明即可自动导入，同时也支持解构语法：
```js
<script setup="props, { emit }" lang="ts">
 
<script>
```

### 组件自动注册
在 script setup 中，引入的组件可以直接使用，无需再通过components进行注册，并且无法指定当前组件的名字，它会自动以文件名为名，也就是不用再写name属性了。示例：
```js
<template>
    <Child />
</template>

<script setup>
import Child from './Child.vue'
</script>
```

### 核心api使用

#### 使用 props
通过defineProps指定当前 props 类型，获得上下文的props对象。示例：
```js
<script setup>
  import { defineProps } from 'vue'

  const props = defineProps({
    title: String,
  })
</script>
```

#### 使用 emits
使用defineEmit定义当前组件含有的事件，并通过返回的上下文去执行 emit。示例：
```js
<script setup>
  import { defineEmits } from 'vue'

  const emit = defineEmits(['change', 'delete'])
</script>
```

#### 父子组件通信
defineProps 用来接收父组件传来的 props ; defineEmits 用来声明触发的事件。
```js
//父组件
<template>
  <my-son foo="🚀🚀🚀🚀🚀🚀" @childClick="childClick" />
</template>

<script lang="ts" setup>
import MySon from "./MySon.vue";

let childClick = (e: any):void => {
  console.log('from son：',e);  //🚀🚀🚀🚀🚀🚀
};
</script>


//子组件
<template>
  <span @click="sonToFather">信息:{{ props.foo }}</span>
</template>

<script lang="ts" setup>
import { defineEmits, defineProps} from "vue";

const emit = defineEmits(["childClick"]);     // 声明触发事件 childClick
const props = defineProps({ foo: String });   // 获取props

const sonToFather = () =>{
    emit('childClick' , props.foo)
}
</script>

```

子组件通过 defineProps 接收父组件传过来的数据，子组件通过 defineEmits 定义事件发送信息给父组件
增强的props类型定义：
```js
const props = defineProps<{
  foo: string
  bar?: number
}>()

const emit = defineEmit<(e: 'update' | 'delete', id: number) => void>()
```
不过注意，采用这种方法将无法使用props默认值。


#### 定义响应变量ref、函数、计算属性computed、监听watchEffect
```js
<script setup lang="ts"> 
import { ref,computed,watchEffect } from 'vue';

const count = ref(0); //不用 return ，直接在 templete 中使用

const addCount=()=>{ //定义函数，使用同上 
    count.value++; 
} 

//定义计算属性，使用同上
const howCount=computed(()=>"现在count值为："+count.value);

//定义监听，使用同上 //...some code else 
watchEffect(()=>console.log(count.value)); 
</script>
```
watchEffect：
用于有副作用的操作，会自动收集依赖。

和watch区别：
无需区分deep，immediate，只要依赖的数据发生变化，就会调用

#### reactive
此时name只会在初次创建的时候进行赋值，如果中间想要改变name的值，那么需要借助composition   api 中的reactive。
```js
<script setup lang="ts">
import { reactive, onUnmounted } from 'vue'

const state = reactive({
    counter: 0
})
// 定时器 每秒都会更新数据
const timer = setInterval(() => {
    state.counter++
}, 1000);

onUnmounted(() => {
    clearInterval(timer);
})
</script>
<template>
    <div>{{state.counter}}</div>
</template>
```
使用ref也能达到我们预期的'counter',并且在模板中,vue进行了处理，我们可以直接使用counter而不用写counter.value.

ref和reactive的关系:
ref是一个{value:'xxxx'}的结构，value是一个reactive对象

#### ref 暴露变量到模板
曾经的提案中，如果需要暴露变量到模板，需要在变量前加入export声明：
`export const count = ref(0)`

不过在新版的提案中，无需export声明，编译器会自动寻找模板中使用的变量，只需像下面这样简单的声明，即可在模板中使用该变量
```js
<script setup lang="ts">
import { ref } from 'vue'

const counter = ref(0);//不用 return ，直接在 templete 中使用

const timer = setInterval(() => {
    counter.value++
}, 1000)

onUnmounted(() => {
    clearInterval(timer);
})
</script>
<template>
    <div>{{counter}}</div>
</template>
```


#### 生命周期方法
因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。
可以通过在生命周期钩子前面加上 “on” 来访问组件的生命周期钩子。
[生命周期对照表](https://v3.cn.vuejs.org/guide/composition-api-lifecycle-hooks.html)

```js
<script setup lang="ts"> 
import { onMounted } from 'vue';

onMounted(() => { console.log('mounted!'); });

</script>
```


#### 获取 slots 和 attrs
可以通过useContext从上下文中获取 slots 和 attrs。不过提案在正式通过后，废除了这个语法，被拆分成了useAttrs和useSlots。

useAttrs：见名知意，这是用来获取 attrs 数据，但是这和 vue2 不同，里面包含了 class、属性、方法。
```
<template>
    <component v-bind='attrs'></component>
</template>
<srcipt setup lang='ts'>
   const attrs = useAttrs();
<script>
```

useSlots: 顾名思义，获取插槽数据。
使用示例：
```js
// 旧
<script setup>
  import { useContext } from 'vue'
  // 注：useContext API 被弃用，取而代之的是更加细分的 api。
  const { slots, attrs } = useContext()
</script>

// 新
<script setup>
  import { useAttrs, useSlots } from 'vue'

  const attrs = useAttrs()
  const slots = useSlots()
</script>
```

#### defineExpose API
传统的写法，我们可以在父组件中，通过 ref 实例的方式去访问子组件的内容，但在 script setup 中，该方法就不能用了，setup 相当于是一个闭包，除了内部的 template模板，谁都不能访问内部的数据和方法。
如果需要对外暴露 setup 中的数据和方法，需要使用 defineExpose API。示例：
```js
<script setup>
	import { defineExpose } from 'vue'
	const a = 1
	const b = 2
	defineExpose({
	    a,
	    b
	})
</script>
```
注意：目前发现defineExpose暴露出去的属性以及方法都是 unknown 类型。

#### 其他 Hook Api
useCSSModule：CSS Modules 是一种 CSS 的模块化和组合系统。vue-loader 集成 CSS Modules，可以作为模拟 scoped CSS。允许在单个文件组件的setup中访问CSS模块。此 api 本人用的比较少，不过多做介绍。
useCssVars: 此 api 暂时资料比较少。介绍v-bind in styles时提到过。
useTransitionState: 此 api 暂时资料比较少。
useSSRContext: 此 api 暂时资料比较少。


#### 定义组件其他配置
配置项的缺失，有时候我们需要更改组件选项，在setup中我们目前是无法做到的。我们需要在上方再引入一个 script，在上方写入对应的 export即可，需要单开一个 script。
`<script setup>` 可以和普通的 `<script> `一起使用。普通的 `<script> `在有这些需要的情况下或许会被使用到：

无法在 `<script setup>` 声明的选项，例如 inheritAttrs 或通过插件启用的自定义的选项。
声明命名导出。
运行副作用或者创建只需要执行一次的对象。

在script setup 外使用export default，其内容会被处理后放入原组件声明字段。

```js
<script>
// 普通 `<script>`, 在模块范围下执行(只执行一次)
runSideEffectOnce()

// 声明额外的选项
  export default {
    name: "MyComponent",
    inheritAttrs: false,
    customOptions: {}
  }
</script>
<script setup>
    import HelloWorld from '../components/HelloWorld.vue'
    // 在 setup() 作用域中执行 (对每个实例皆如此)
    // your code
</script>
<template>
  <div>
    <HelloWorld msg="Vue3 + TypeScript + Vite"/>
  </div>
</template>
```

注意：Vue 3 SFC 一般会自动从组件的文件名推断出组件的 name。在大多数情况下，不需要明确的 name 声明。唯一需要的情况是当你需要 `<keep-alive>` 包含或排除或直接检查组件的选项时，你需要这个名字。

#### 关于 TS 与 ESLint 的不完美
与@typescript-eslint/no-unused-vars规则不兼容，此规则含义为定义了，未进行使用。该规则其实影响不大，关闭即可。

与导入的类型声明不兼容，当你通过解构的方式去导入类型，setup sugar 会进行自动导出。这时候，你就会收到 TS 的一条报错：此为类型，但被当作值使用。解决办法：类型导出使用export default导出或者引入时使用import * as xx来进行引入，也可以使用 import type { test } from "./test";解决。

#### 语法糖实现
vue文件代码
```js
<template>
  <div>{{ msg }}</div>
</template>
<script setup>
  const msg = 'Hello!'
</script>

```

编译后的js代码：
```js
export default {
  setup() {
    const msg = 'Hello!'

    return function render() {
      // has access to everything inside setup() scope
      // 在函数 setup 作用域，函数 render 能访问 setup 的一切，
      return h('div', msg)
    }
  }
}
```
注意到，即使普通变量也能作为模版被置入 template 中被编译，当然有些人认为这不合适，不够分离。


#### 问题 
但是所有代码都写在setup函数中，很快代码就无法维护，react新版的hook写法也存在这个问题，其实很难找到一个最佳实践，目前两个框架同质化开始加深，感觉都变得开始过度设计。
为了解决这个问题其实还是要拆分逻辑，用hook抽离。一个SFC的setup中写所有的逻辑代码肯定是不行的。把逻辑抽离成单独的hooks，组件的script setup里就会十分干净。
也可以将功能拆分为不同的小模块，每个小模块用个reactive包起来。

从options api切换到composition api最大的问题就是没有强制的代码分区，如果书写的人没有很好的代码习惯，那么后续的人将会看的十分难受。目前这么解决：

自我代码分区并且尽量抽离方法（写好注释），分区如下：

1.相关引入
2.响应式数据、props、emit 定义
3.生命周期以及 watch 书写
4.方法定义
5.方法、属性暴露

组件抽离：将页面拆成两个文件夹，一个为 views，一个为 components。views 和 components 文件夹下有各自的文件。views 文件夹中为页面入口，掌管数据，而 components 则为页面中一些组件抽离。如果是公共组件，再抽离到 components 文件夹下其他位置。
