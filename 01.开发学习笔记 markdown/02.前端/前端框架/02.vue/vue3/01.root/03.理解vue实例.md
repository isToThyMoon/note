---
title: 理解vue实例
categories:
  - 01.开发学习笔记 markdown
  - 08.前端框架
  - 04.vue
  - root
---

# 3.0新写法

```js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)
const vm = app.mount('#app')
```

createApp表示创建一个Vue应用实例（application instance），
传递给 createApp 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。
应用实例暴露的大多数方法都会返回该同一实例，允许链式：

```js
Vue.createApp({})
  .component('SearchInput', SearchInputComponent) // 创建注册全局组件
  .directive('focus', FocusDirective) // 创建全局指令
  .use(LocalePlugin)
```

与大多数应用方法不同的是，mount 不返回应用本身。相反，它返回的是根组件实例。
虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的缩写) 这个变量名表示组件实例。
vue是以数据驱动的编程方式，数据和视图的绑定是vm来维护的。
vm.$data你就可以获得这些数据。
尽管你可以在一个根组件实例上写你所有的页面代码，但实际上我们的应用是被组织成一个嵌套的、可重用的组件树。

每个组件都有自己的组件实例vm。根组件与其他组件没什么不同。


# 为什么修改成这样的写法？
解决全局配置污染问题。

开发者在使用 Vue 2.x 时所谓的 app 不过是一个用 new Vue()创建的 Vue 实例罢了（不过如此）。由同一个 Vue 构造函数创建的 Vue 实例都会共享来自构造函数的全局配置。这样造成的问题就是容易污染。

为了规避这些问题，Vue 3 引入了应用实例（application instance）的概念。

调用 createApp 会返回一个 应用实例。

应用实例会暴露一个当前全局 API 的子集。在这个重构工作中，Vue 团队秉承的经验法则是：任何会在全局范围内影响 Vue 行为的 API 都会被迁移至应用实例中去。

其他不会在全局影响 Vue 行为的 api 都已改造为具名导出的构建方式（named exports），就像之前尤雨溪在直播里说的那样：为了支持 TreeShaking。

在使用 createApp(VueInstance) 得到一个应用实例后，这个应用实例就可以用来把整个 Vue根实例挂载到页面上了：

```js
const app = Vue.createApp({
    data(){
        return {
            content: "dadada"
        }
    },
    template: `
        <div>
            {{content}}
            <button v-on:click="handleBtnClick"></button>
        <div>
    `,
    methods: {
        handleBtnClick(){
            this.content = this.content.split("").reverse().join("");
        }
    }
});
const vm = app.mount("#root");
```

```js
app.component('trump-sucks', {
  data: () => ({ position: 'America president', }),
  template: `<h1>Trump is the worst ${position}</h1>`;
});

app.directive('focus', {
  inserted: el => {
    console.log('聚焦！');
    el.focus();
  },
});
```
至此，所有在 app所包含的组件树内创建的实例才会共享 trump-sucks 这个组件和 focus 这个指令，而 Vue 构造函数并没有被污染。

## 拓展：多个应用实例的配置共享
上文提到的“不是所有开发者都想要的全局配置共享”，
如果你想实现多个实例的全局配置共享
在 Vue 3 中可以通过工厂函数的方式实现：

```js
import { createApp } from 'vue'
import Foo from './Foo.vue'
import Bar from './Bar.vue'

const createMyApp = options => {
  const app = createApp(options)
  app.directive('focus' /* ... */)

  return app;
}

createMyApp(Foo).mount('#foo')
createMyApp(Bar).mount('#bar')
```
现在，Foo 和 Bar 实例及其后代中都可以使用 focus 指令。

这样就能实现多个应用实例的配置共享了。

# 2.0写法
`var vm = new Vue({})` 通过Vue这个类新建Vue实例，接管html中一部分dom的渲染。

```js
<div id="root">
	<div v-on:click="handleClick">
		{{message}}
	</div>
</div>

<script>
	var vm = new Vue({
        el: '#root',
        data:{
            message:'hello world'
        },
        methods: {
            handleClick: function(){
                
            }
        }
	})
</script>
```

vm是 或者说每个组件 都是Vue这个构造函数的实例。
每个Vue实例都会代理其data对象里所有的属性。
Vue实例暴露了一些有用的实例属性与方法
为与代理属性区分，添加了前缀$

1 . data会代理其对象里的所有属性.
2 . 只有data里的属性是响应式的，即通信是双向的.
3 . Vue被实例化后，再创建的属性，将不会触发视图更新.

不同于react的all in js，

vue采用更易于传统开发者思维接受的开发方式，就是html和js混合的模板语法。

这里创建了vue实例vm，绑定了id为root的dom，这里vue就接管了这部分dom的渲染，vue就能够识别这个dom标签下的vue式语法，如v-on等等。下面我们在这个dom内的语法就和传统html css不一样了。

一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册（全局）组件很简单：
也可以用字面量创建局部组件 在其他组件中注册后使用。

```js
Vue.component('todo-item',{
	template:'<div></div>'
})
```

vue的后台把它编译成了一个vue实例。

一个vue项目就是由很多的vue组件（实例）构成的。

我们可以通过控制台vm.$data等获取到实例的创建后的属性。实例属性，实例方法。



# 为什么我们可以访问data中声明的属性？
https://my.oschina.net/cc4zj/blog/4497987

```js
var app = new Vue({
    el: '#app',
    data: {
        foo: 'dadada'
    },

    computed: {
        bar: function () {
            // this 指向vm实例
            return this.foo
        }
    }
})
```

data选项中声明了属性foo，我们就可以通过app.foo,或者在created，mounted， methods中定义的方法里通过 this.foo来访问这个属性。

这里计算属性出现了this 且官网说明这里的this是指向vm这个实例的。 
而这实例下居然直接挂载了data声明的属性foo 为什么呢？

这么理解
new Vue() 时接受的是一个配置的对象，el data computed methods等等都是Vue来声明对象内容的关键字，
他们并不是实例的直接属性。
源码内部通过bind事先绑定了this的指向到实例对象。

一般来说data现在的值是一个返回一个对象的函数，源码内部会对它进行处理，最后通过defineProperty把data内容复制到实例上。要注意的是，其实复制到实例后我们获取这个属性是通过getter setter方法来获取的。

它为了方便使用者理解，
也就是data声明了（vm这个实例对象）数据属性。computed声明计算属性。methods声明的就是它的方法
