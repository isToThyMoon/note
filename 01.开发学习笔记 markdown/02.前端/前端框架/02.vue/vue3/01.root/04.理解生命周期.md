

生命周期是一个通用词汇，具体到 Vue 组件，是指它从被初始化开始，直到最后被销毁，经历的一系列的过程。而我们重点关注的是，Vue 在这一系列过程中经历了哪些重要的变化。

# init时期：
在_init() 方法执行完毕后实例的创建就完成了，接下来会执行一系列的方法：

```js
initLifecycle(vm)
initEvents(vm)
initRender(vm)
callHook(vm, 'beforeCreate')
initInjections(vm) // resolve injections before data/props
initState(vm)
initProvide(vm) // resolve provide after data/props
callHook(vm, 'created')
```

这些方法我们在 Vue 实例一节中有简单涉及到。这里我们重点关注一下 callHook(vm, 'beforeCreate) 和 callHook(vm, 'created')。首先看一下 callHook() 方法的定义：


```js
export function callHook (vm: Component, hook: string) {
  const handlers = vm.$options[hook]
  if (handlers) {
    for (let i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info)
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook)
  }
}
```

可以看到它在执行的时候会取 vm.$options 上对应的 hook 方法，然后将这些方法一一进行调用。例如当 callHook(vm, 'beforeCreate) 被调用时，会去寻找 $options.beforeCreate() 方法，并调用它。上文说过，我们调用 new Vue() 时传递的参数会成为 $options 的一部分，因此 $options.beforeCreate() 就是我们在使用 Vue 的时候传入的：

```js
new Vue({
    // ...,
    beforeCreate(){

    },
    // ...,
});
```
同理，callHook(vm, 'created) 也就是调用我们传入的 created() 方法。

> 为什么明明我们使用 Vue 时 created() 传的是一个方法，这里却当成一个数组来处理？这是因为 Vue 实例初始化的时候会通过 mergeOptions() 方法对传入的 $options 进行处理，在这个处理过程中，会调用 mergeHook() 方法（位于 core/util/options.js 中），将生命周期方法变为一个数组。



# 挂载时期
在这一系列方法调用完之后，最后调用 vm.$mount()，即将实例挂载到真实的 DOM 上。这个方法实际上就是位于 core/instance/lifecycle.js 的 mountComponent 方法。


```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  // 省略一大段对render的判断

  callHook(vm, 'beforeMount')

  let updateComponent
  updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }

  // 定义Watcher
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true)

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

这段代码首先调用了 beforeMount() 方法，然后设置了一个 Watcher，这个 Watcher 会调用 updateComponent() 方法，即执行组件的挂载，在挂载前还会执行 beforeUpdate()。挂载完之后执行 mounted() 方法。

> 具体的挂载和渲染过程，这里暂不解析，因此这里先略过 updateComponent() 方法的具体细节。

当组件被挂载到页面上后，就成为了用户可以看见和互动的页面元素，在接下来的时间中，组件都要保持已挂载的状态，直到它被销毁。


# 销毁
当调用 $destroy 方法时，Vue 实例就会被销毁，此时会有一系列的销毁工作要完成，同时也会调用 beforeDestroy() 和 destroyed() 生命周期方法。

```js
Vue.prototype.$destroy = function () {
    const vm: Component = this
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy')
    vm._isBeingDestroyed = true
    // remove self from parent
    const parent = vm.$parent
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm)
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown()
    }
    let i = vm._watchers.length
    while (i--) {
      vm._watchers[i].teardown()
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--
    }
    // call the last hook...
    vm._isDestroyed = true
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null)
    // fire destroyed hook
    callHook(vm, 'destroyed')
    // turn off all instance listeners.
    vm.$off()
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null
    }
  }
```