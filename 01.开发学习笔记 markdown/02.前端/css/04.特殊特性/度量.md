
# MouseEvent
MouseEvent.clientX 是目标点距离浏览器可视范围的X轴坐标
MouseEvent.clientY 是目标点距离浏览器可视范围的Y轴坐标

MouseEvent.pageX 是目标点距离document最左上角的X轴坐标（针对滚动）：相对于整个文档的x（水平）坐标以像素为单位的只读属性。这个属性将基于文档的边缘，考虑任何页面的水平方向上的滚动。
MouseEvent.pageY 是目标点距离document最左上角的Y轴坐标（针对滚动）

# 页面元素的度量

## offsetxxx（offsetWidth包含content padding border 滚动条）相对非static父级的offset
偏移量计算，那么理所应当有一个偏移参照，定位父级offsetParent；
偏移量计算参照当前元素最近的经过定位的父级元素（非static），如果没有会一直上溯到body

offsetHeight offsetWidth 元素垂直水平方向上的占用空间 包括content padding border 滚动条

offsetTop offsetLeft 元素上外、左外边框距离包含该元素的offsetParent的上内、左内边框的距离

看起来类似style.top，
但offsetTop返回数字，只读，
style.top返回字符串px，可读写。若css未指定过top，返回空字符串。

[注意]firefox浏览器有兼容性问题

要知道某个元素在页面上的偏移量，将这个元素的offsetLeft和offsetTop与其offsetParent的相同属性相加，并加上offsetParent的相应方向的边框，如此循环直到根元素，就可以得到元素到页面的偏移量：
```js
function getElementLeft(ele){
    var actualLeft  = ele.offsetLeft;
    var parent = ele.offsetParent;
    while (parent != null){
        actualLeft = actualLeft + parent.offsetLeft + parent.clientLeft;
        parent = parent.offsetParent;
    }
    return actualLeft + 'px';
}
function getElementTop(ele){
    var actualTop  = ele.offsetTop;
    var parent = ele.offsetParent;
    while (parent != null){
        actualTop = actualTop + parent.offsetTop + parent.clientTop;
        parent = parent.offsetParent;
    }
    return actualTop + 'px';
}
```

## clientxxx（元素content加padding区域的属性）
clientHeight clientWidth 不包含border的 内容区域加padding的占用空间 不包含滚动条

clientLeft ClientTop 返回border相应的宽度 border width
clientLeft 但如果文字方向从右往左排列，且存在垂直滚动条，border width+scrollbar width
ClientTop 上边框宽度

## scrollxxx
Ele.scrollHeight...

scrollWidth scrollHeight有滚动的元素实际宽高 不可写
scrollLeft scrollTop 被隐藏在内容区域（视窗）左、上的长度，实际相对可视范围（父级元素）已滚动距离。是可读写的，但是改写属性造成滚动是没有平滑效果的，采用window.scroll()代替。

## getBoundingClientRect()
Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。
如果是标准盒子模型（content box），元素的尺寸等于width/height + padding + borderWidth的总和。
如果box-sizing: border-box，元素的的尺寸等于 width/height。

拥有left, top, right, bottom, x, y, width, 和 height这几个以像素为单位的只读属性number用于描述整个边框。
除了width 和 height 以外的属性是相对于视图窗口的左上角来计算的。

-------

# window, document和body的属性
window上挂载有document 和body
window.document.documentElement是根元素html
window.document.documentElement作为根元素html包含是head元素和body元素（一般来说 标准情况下）

## window里的尺寸
window.screen.width / window.screen.height 读取到的始终是屏幕的逻辑分辨率，不管浏览器尺寸如何拖动改变，即使是分屏浏览，在不同屏幕下console出来的window.screen.width都是该屏幕当前的逻辑分辨率。

window.innerWidth; window.innerHeight才是包含滚动条的浏览器内部可视窗口的宽高。但注意也是在逻辑分辨率下随着浏览器拉动改变大小获得的。

Document.documentElement 是一个会返回文档对象（ document ）的根元素的只读属性（如HTML 文档的 <html> 元素）。一般就是html元素。

在设置html的width和height都为100%情况下：
document.documentElement.clientWidth; document.documentElement.clientHeight 获取content加padding宽高，（不包含border 滚动条，虽然一般也没有给html加border的）
document.documentElement.offsetWidth; document.documentElement.offsetHight 获取html元素尺寸（包含border 滚动条）的宽高。

## 滚动相关
标准模式下（文档头有doctype申明），浏览器默认滚动条属于html元素。那么在IE, Firefox和Opera中，获取滚动距离需要用document.documentElement.scrollTop。body的scrollLeft属性总是返回0。
怪异模式（quirks mode）下，浏览器滚动条属于body，在IE, Firefox, Opera, Chrome和Safari中，通过document.body.scrollTop获取滚动距离。html的scrollLeft等属性总是返回0。
因为所谓的scrollTop是有滚动的元素相对于其父级元素作为视窗的滚动偏移量。html元素作为document.documentElement它的父级就是window视窗了。

统一下兼容写法，获取页面Y轴的滚动距离：
`var scrollY = document.documentElement.scrollTop || document.body.scrollTop;`

window对象的scrollX属性也总是可以返回滚动的长度，不管doctype是什么类型，Firefox, Chrome和Safari都支持该属性。
window.scrollX 文档从左边开始滚动过的像素值；
window.scrollY 文档从顶部开始滚动过的像素值；
window对象的pageXOffset属性也总是可以返回滚动的长度，不管doctype是什么类型的，所有浏览器都支持这个属性，除了IE8及其更低版本的IE浏览器。（兼容性对于老浏览器略好于scrollX，如果需要更好的跨浏览器兼容性，请使用 window.pageXOffset 和 window.pageYOffset 代替 window.scrollX 和 window.scrollY。）

window.pageYOffset; pageYOffset is an alias for scrollY
There is slightly better support for pageYOffset than for scrollY in older browsers, but if you're not concerned about browsers more than a handful of years old, you can use either one.

window下的pageXYOffset和scrollX scrollY取的还是window内部documentElement作为scroll元素的scrollTop scrollLeft等值。

### js操作页面滚动
需要做点击tab 页面滚动到相应区块，可以使用window.scroll({top: '页面y轴坐标像素', behavior: 'smooth'})这个api。
关键是如何获取这个top值。
利用document selector来获取指定的元素很简单。如果该元素父级未设置非static定位，那么取该元素的offsetTop就是该元素的顶部距离滚动页面的相对y轴坐标像素。
但是只要该元素父级有一个被定位，该元素的offsetTop就被锁死相对于该父级，滚动就失效了。

想到利用距离视窗像素加上已滚动值。





