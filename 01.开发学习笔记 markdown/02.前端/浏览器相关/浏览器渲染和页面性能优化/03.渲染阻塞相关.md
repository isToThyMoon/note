
从js和css解析得出的几个阻塞相关结论：

1. 浏览器从网络进程请求html文件字节流交给渲染进程，由渲染引擎开始解析构建dom，渲染进程也会开启一个预解析线程来分析页面需要资源文件并让网络进程提前下载。除非文件过大，一般资源请求不需要开发者做什么优化。当 HTML 解析器被脚本阻塞时，解析器虽然会停止构建 DOM，但仍然会辨识该脚本后面的资源，并进行预加载。且由于以下两点。

2. js引擎和渲染引擎互斥，当解析到script标签时，无论script是否下载完成，渲染线程会被挂起，等待js线程执行代码结束。

3. css资源构建cssom树阻塞一切。cssom阻塞渲染，cssom阻塞script的执行。

1.CSS 被默认被视为阻塞渲染的资源，因此浏览器将在 CSSOM 构建完毕前不会渲染任何已处理的内容。
2.JavaScript 不仅可以读取和修改 DOM 属性，还可以读取和修改 CSSOM 属性，因此CSS解析与script的执行互斥，js执行会等待cssom构建完毕。

render树的构建依赖dom树和cssom树，dom树是请求html文件返回字节流就开始最早构建的，预解析到css资源和js资源提前并发下载。遇到script需要js线程执行js，但js有操作dom和读取修改css的可能，所以js执行时渲染线程一定要挂起，但注意到在js执行前cssom树一定要解析完毕，也就是说js执行肯定会等待css资源下载完毕且构建cssom树完毕。

css资源阻塞js执行，进而阻塞后续整个渲染绘制。即使没有js资源，render树的构建也要依赖dom树和cssom树，所以cssom树阻塞一切。

4. 渲染引擎渲染页面的策略是分步渲染。

以script标签为各部分dom的分隔，各部分的dom元素构建dom树和cssom树，合并成渲染树，
也就是说一段dom1之后有script1，script1之后是dom2等等，会先构建dom1的渲染树，但不会走立即下面的4.5步骤，
因为有script标签，它有修改dom和样式的可能性，而浏览器在加载script并执行完之前是不知道的，
所以js引擎（js线程里）一定会阻塞渲染引擎（渲染线程里），
这时渲染线程会先挂起，等待这段script1被js线程加载执行完毕后工作（但是它不会等待script2的执行完再绘制，即使script2也修改了dom1，这是一种浏览器一种分布渲染的策略，确保用户不会等太久，不然你一个超大的html文件，很多个的script执行，用户必须要等到所有script执行完再看到最终页面是不合理的。），执行以下4.5步骤绘制到屏幕。
注意此时script1下面的dom2不要说4.5步骤还没开始，它还没解析dom，连123步骤都没开始。
要等dom1绘制完毕后才会继续解析dom2，构建dom树cssom树，合并成渲染树，然后会同样判断dom2下有没有script阻塞绘制，
没有的话就会立即layout计算并绘制到屏幕。
有的话重复以上步骤。
这样可以防止某段script的js高耗时操作，导致整个页面都没有任何绘制。尽量让用户早看到完整的页面。



正是由于这些原因，script 标签的位置很重要我们在实际开发中应该尽量坚持以下两个原则：
1.在引入顺序上，CSS 资源先于 JavaScript 资源。
2.JavaScript 应尽量少的去影响 DOM 的构建（放在文档末尾）。

# 研究下阻塞

## 加载（下载）资源带来的阻塞

加载是浏览器从网络中请求资源（比如图片、样式文件、静态脚本等），将资源进行相应的处理。

与上述说的两个线程不同，对资源进行加载的网络线程不会和js引擎和渲染引擎两个线程互斥。
例如图片资源就可以并行下载，下载的最大并行数量与浏览器的配置有关系。（这里还有一个知识点，下载的最大并行数指的是从一个主机上下载的最大并行数，如果从多个主机下载资源，这个数量会翻倍x主机数量，但是由于对DNS的解析也是一个性能优化的点，不宜设置多个下载主机增加DNS解析负担，故而一般策略是：不应设置超过4个主机，最好只设置2个主机）。

不会互斥意味着：资源的加载可以和UI渲染、重排，事件响应，或者JavaScript代码的执行的并发进行。

实际上，`<script>`标签资源是并发下载，同步执行。

但是例外的就是，如果浏览器解析DOM时需要下载的脚本资源过大非常耗时，js线程一直等待js资源下载完成，进而阻塞了渲染线程的恢复解析，导致渲染速度变慢。

为了解决这个问题，我们依然是将`<script>`标签放到最后。但如果脚本执行时间也非常耗时，页面依然是没有绘制的。

故而我们需要无阻塞加载脚本的技术。 defer async 动态脚本。


## 执行脚本带来的阻塞

由于：脚本执行和渲染DOM的并发可能会引发严重的冲突, 所以：JavaScript引擎和渲染引擎所在的两个线程被设计为互斥的！

这就意味着：在执行`<script>`中内容时，浏览器会切换到JavaScript引擎所在的线程，此时渲染引擎所在的线程会阻塞，故其后元素的解析和渲染会暂停。这时候如果脚本执行时间太长的话，不仅后面的元素会一直看不到，对DOM的解析工作也会一直完不成。用户会陷入焦急的等待中。

其实不仅script后面的dom解析不了，由于上述基于js可能会修改dom的考虑，script上面已经解析的dom也不会立马绘制，因为script可能会修改它们，所以在script加载执行完毕后，其上的已解析dom才会绘制。

解决这个问题的一个经典思路，就是：

把`<script>`放到紧跟`</body>`之前的位置。这样就不会影响需要放到页面上的UI元素的解析了。这样的好处就是，用户能尽快看到页面上的UI元素，而防止出现了浏览器白屏等现象。

这个方法有好处，但仅仅是防止script内部操作在执行时操作到script下方未解析完成的dom，
至于防止白屏问题。这种方法其实以讹传讹并未解决，看下面的例子：

```html
  <div id="test">dadada</div>
  <script>
    let a;
    for (let index = 0; index < 2000000000; index++) {
      a = index;
    }
    console.log('a', a)
  </script>

  <script>
    let b;
    for (let index = 0; index < 2000000000; index++) {
      b = index;
    }
    document.querySelector('#test').innerHTML = 'dududu'
    console.log('b', b)
  </script>

  <div id="testT">dididi</div>

  <script>
    let c;
    for (let index = 0; index < 2000000000; index++) {
      c = index;
    }
    document.querySelector('#testT').innerHTML = 'dododo'
    console.log('c', c)
  </script>
```

以上代码可看出js引擎和渲染引擎的切换逻辑。
有dom1 高耗时任务1 高耗时任务2（修改dom1） dom2 高耗时任务3（修改dom2）

假设耗时任务都是3秒
执行时有以下表现：
页面白屏
3秒 js引擎执行完毕任务1 打印a变量 仍然白屏中
3秒 js引擎执行完毕任务2 打印b变量 随后屏幕白屏结束 渲染引擎绘制显示修改后的dom1:dududu（如果任务2中没有修改dom代码，此时会在打印b变量后显示未修改的dom1 dadada）
3秒 js引擎执行完毕任务3 打印c变量 随后渲染引擎绘制增加显示修改后的dom2:dododo（如果任务3中没有修改dom代码，此时会在打印c变量后显示未修改的dom2 dididi）

所以js引擎确实会阻塞渲染引擎，
而渲染引擎解析完dom也不会立马就渲染到实际页面上，预计是有机制间隔交替执行。目前来看是dom1的实际渲染是在dom1与顺序相隔最近的dom2之间的js全部执行完在绘制到页面。

**所以说把script放在body的最后其实并不能解决阻塞问题，如果这个script执行时间很长，script之上的所有dom仍然不会早于script加载并执行完毕前绘制。**

可以说：js引擎运行script阻塞在它之上dom的绘制。运行完毕后立即绘制。然后解析下一段dom，运行下一段dom之下的script，然后绘制该dom。。。


一个具体渲染流程的特例：

```js
const Ele = document.createElement('div')
Ele.style.height = '500px';
Ele.style.width = '500px';
Ele.style.background = 'black';
document.querySelector<HTMLElement>('.demo-class')?.appendChild(Ele);
console.log('height dom',document.querySelector<HTMLElement>('.demo-class')?.offsetHeight)
console.log('height dom',document.querySelector<HTMLElement>('.demo-class div')?.style.background)

while(true){
    console.log('true')
}
```

以上代码，虽然js执行了一个死循环，一直不会让出js引擎让渲染引擎工作，所以页面不会出现代码修改dom的结果，但是console出来的高度和颜色都是修改过的500px和black。
所以js修改了dom树和cssom树，虽然不会立即渲染绘制，但读取时是已经生效了的，只是还没有执行渲染引擎合并渲染树，发送到显存显示出实际结果。

CSS不会阻塞DOM树的解析，但会阻塞JS的执行，最终CSS（CSSOM）会影响影响render树的生成（dom树 + cssom树 = render树）
而JavaScript 会阻止后续DOM树的解析。

## 外部样式表的阻塞问题
CSS 加载会造成阻塞吗？

首先外部样式表不会阻塞文档dom树的解析。在浏览器渲染流程当中我们可以看出，DOM 和 CSSOM 通常是并行构建的，所以 CSS 加载不会阻塞 DOM 的解析，然而由于 Render Tree 是依赖于 DOM Tree 和 CSSOM Tree 的，所以它必须等待到 CSSOM Tree 构建完成，也就是 CSS 资源加载完成（或者 CSS 资源加载失败）后，才能开始渲染，因此 CSS 加载会阻塞 DOM 的渲染树构建，影响最终的绘制。

style-sheets 不会修改 DOM 树，没有理由为了解析 style-sheets 而阻塞文档解析（即 style-sheets 不会阻塞文档解析）。但如果在解析文档过程中有脚本需要访问样式信息时，为了保证访问样式信息的正确性。Firefox 会阻塞所有脚本直到 style-sheets 下载解析完为止。而 WebKit 只在访问的样式属性没有被加载解析时，才会阻塞脚本。
即 style-sheet 不会直接阻塞文档解析，它只阻塞 script 的解析执行，才导致 style-sheet 间接阻塞文档解析。
当然，因为渲染树必须依赖dom树和cssdom树，可以说css的加载也会阻塞渲染。





