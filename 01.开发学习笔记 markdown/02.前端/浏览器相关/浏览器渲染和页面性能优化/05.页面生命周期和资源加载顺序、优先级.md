# 页面事件的生命周期：
> 页面事件的生命周期：
> DOMContentLoaded：DOM 树解析完毕，完成之后才会触发 DOMContentLoaded，此时 GPU 还没开始根据 CSS 树开始绘画，我们可以在这个阶段使用 JS 去访问元素。当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
> async 和 defer 的脚本可能还没有执行。
> 图片及其他资源文件可能还在下载中。
> load 事件在页面所有资源被加载完毕后触发，通常我们不会用到这个事件，因为我们不需要等那么久。window.load 只会执行第一次赋值的函数，无论是函数形式赋值还是标签内赋值 <body onload="alert('d');">
> beforeunload 在用户即将离开页面时触发，它返回一个字符串，浏览器会向用户展示并询问这个字符串以确定是否离开。
> unload 在用户已经离开时触发，我们在这个阶段仅可以做一些没有延迟的操作，由于种种限制，很少被使用。
> document.readyState 表征页面的加载状态，可以在 readystatechange 中追踪页面的变化状态：
> - loading —— 页面正在加载中。
> - interactive —— 页面解析完毕，时间上和 DOMContentLoaded 同时发生，不过顺序在它之前。
> - complete —— 页面上的资源都已加载完毕，时间上和 window.onload 同时发生，不过顺序在他之前。

# 最佳实践
简单来说，DomContentLoaded事件在页面dom构建完成后触发（注意是dom而不是cssom或者两者合成的渲染树）

如果js需要在dom构建完成后运行，要么放在head中并代码包装监听DomContentLoaded事件后运行，要么放在body最后正文的底部确保DOM准备就绪（其实没完全结束，只要确保js再下方没有它需要操作的dom）。

第三方脚本最好放在body底部，这样如果第三方挂掉也不会影响body之前文档构建。

但是通过将脚本放在底部，会将DOMReady事件延迟了浏览器在请求该脚本之前解析文档和处理头元素所需的时间（200-500ms） 。主要是在首页加载时（假设可以从那里缓存它）。而如果您将其放在头部。准备工作可能要快得多。因此，考虑到HTML5，如果脚本必须在DOM准备就绪时修改布局，那么现在最好在头中使用“异步”或“延迟”脚本。

对于外部脚本（Google Analytics（分析），第三方营销跟踪器等），请将其放置在</body>代码之前。
对于影响页面布局的脚本，请放在最前面。
对于依赖“ dom ready”的脚本（如jquery），请考虑放置在</body>前面，除非您出于极端的原因将脚本放在头部。



第三方脚本或无需过早运行的脚本 采用head中async实现



preload和prefetch

`<link rel="prefetch" as="script" href="//s1.hdslb.com/bfs/static/player/main/video.869b2194.js?v=20200820">`

`<link rel="preload" as="script" href="//s1.hdslb.com/bfs/static/player/main/video.869b2194.js?v=20200820">`


# css和script在head和body位置组合的几种典型
1.head中script在前css在后，解析dom，预扫描
    按优先级下载
    解析js 阻塞dom构建
    解析css 解析dom

2.head中css在前 script在后， css加载解析完成 js才会执行（css和js可以同步下载，css阻塞的是js的执行，别搞错了） js可能操作css属性所以一定会等待css加载解析完成。

3.css在head script在body尾部：
    css和dom越早完成加载解析，css加载完成后（css解析时间极短，可以无视），在遇到body中第一个script时如果script还未加载完成（可能在下载中），会提前做一次FCP。这时候的js确实阻塞了dom的解析，如果你在js资源下面还有dom，在这次FCP中是不会展现的。但是这个提前FCP的机制就是让已经尽可能全的cssom和dom进行渲染，让用户看到已经基本完全的页面（下面其实是脚本。）
    浏览器会在body中第一个script前的所有css就绪后（准确说应该是head中的所有资源），开始进行一次提前渲染。
    如果在body尾的script后还有css，因为js阻塞dom解析，虽然这个css正常下载，但是浏览器的提前FCP不会等待这个css文件就绪。所以一些非首屏必需的css可以放到body尾js后面来降低它的执行优先级。（其实没必要，下载优先级还是正常的，在下载完成后浏览器又会发生一次重绘甚至重排。 提前加载不是很重要的资源可以采用preload和prefetch）
    如果head中资源非常慢，body尾前第一个脚本加载非常快，那么没有触发提前FCP，等待head中的资源加载完毕后FCP。这里是执行优先级的问题：body尾前第一脚本下载完成非常快，但是执行顺序还是要等head中css资源加载解析完成--head中js资源同步下载，然后解析完成，然后轮到解析body内容，发现这里有一个script，触发FCP。其实和之前的道理是一样的。只是head中的优先级非常高，它是顺序前置位。
    如果想这样触发FCP来优化首屏加载。应尽量减少header中资源的数量和体积。（或者亚马逊式优化，所有资源提前到head（这样可以非常快开启资源下载？）但是采用async和defer preload和prefetch）
    
    
# 默认优先级
## head中：
head中的css highest
head中的script high
    async: low

link rel="preload" 设置as类型 浏览器必定去预加载相应资源 获取但3秒内未被当前页面使用会被控制台警示
    字体资源preload 必须使用crossorigin='crossorgin'属性，如果没有，浏览器将忽略预加载的字体，并发起一个新请求。因为浏览器使用匿名请求加载字体。字体preload net从highest调整为high
    
## 关键路径css和js资源（初始渲染前必须加载的资源。建议嵌入到html中）：

## script
head中的script net:high 

据该脚本在文档中的位置是在浏览器展示的第一张preload图片之前还是之后，又可分为两类。在之前的 ( 标记 early** ) 它会被定为medium优先级，在之后的 ( 标记 late** ) 会被设置为 low 优先级。

script link rel="modulepreload" 优先级high
script async defer  优先级low
script crossorigin   优先级low

## css
正常情况 net highest
css link 加上media="print" "all" 优先级降为lowest
## font

## img
浏览器计算 位于view中的img:net medium (实际似乎是high)
不在view的img：lowest，
当布局完成后被发现位于view中了，会获得优先级提升medium，但是当布局完成时已经在请求中的图片不会更改优先级。

## preload
使用as来限定资源属性，获得与该资源类型相同的优先级。
未指定as属性 优先级和XHR一致

如果是preload的script且在此之前加载了一张图片 就认为这个script是在页面偏底部的，优先级调为medium。
资源在一张非preload的图片前认为是early 其后认为是late late的script优先级会偏低。

preload不同于prefetch，在早期浏览器，script资源是阻塞加载的，当页面遇到一个script，那么要等这个script下载和执行完了，才会继续解析剩下的 DOM 结构，也就是说script是串行加载的，并且会堵塞页面其它资源的加载，这样会导致页面整体的加载速度很慢，所以早在 2008 年的时候浏览器出了一个推测加载(speculative preload)策略，即遇到script的时候，DOM 会停止构建，但是会继续去搜索页面需要加载的资源，如看下后续的 HTML 有没有img/script标签，先进行预加载，而不用等到构建 DOM 的时候才去加载。这样大大提高了页面整体的加载速度。

TODO: 这里的preload是指推测加载，跟<link rel="preload">貌似不一样？


# 其他规则

每个域每次最多同时加载 6 个资源（仅在 http/1.1 时）

在优先级在 Net:Medium 以下的为delayable，即可推迟的，而大于等于 Medium 的为non-delayable的。

还有一种是layout-blocking的请求：
The priority level above which resources are considered layout-blocking if the html_body has not started. 指还没有解析到body标签且优先级在 Medium 之上的请求，比如body之前的 CSS 请求。

Non-delayable的、High-priority的请求(>= Medium)、同步请求和非 http(s) 的请求能够立刻加载
只要有一个layout-blocking的资源在加载，最多只能加载一个delayable的资源，这个就解释了为什么0.png能够先加载
只有当layout-blocking和High-priority的资源加载完成了，才能开始加载delayable的资源，这个就解释了为什么要等 CSS 加载完了才能加载其它的 js 和图片
同时加载的delayable资源同一个域只能有 6 个，同一个client即同一个页面最多只能有 10 个，否则要进行排队
注意这里说的开始加载，并不是说能够开始请求建立连接了。源码里面叫in flight，在飞行中，而不是叫in request之类的，能够进行in flight的请求是指那些不用queue的请求，