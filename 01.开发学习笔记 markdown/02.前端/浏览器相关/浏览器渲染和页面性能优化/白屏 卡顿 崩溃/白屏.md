

# 白屏问题分析
首先定义什么是白屏，一般来说和first paint time和first meaningful paint有关，从url请求开始，到第一次出现有意义画面（字符或元素）前那段空白的时间一般就是白屏。

首屏加载前的网络延迟或者传输数据过大，导致静态资源js css等加载时间过长，甚至失败（一般是react vue这样spa框架的bundle.js），阻塞页面dom构建，导致白屏。
js加载耗时，阻塞页面dom
js代码执行异常报错导致页面代码崩溃，以后的代码不执行，导致相关dom操作未执行（react挂载dom）导致页面不可用白屏。
dom本身渲染构建时间过长
解决：
减少请求次数和大小
减少首屏dom层级


一个白屏例子：
react项目，html中html标签内首个元素是两个script标签，标签内js语法错误。
结尾body前给一个错误链接的script。
dev环境会把react相关bundle.js注入到head标签中
打开网页，两个script报错error会首先弹出到控制台。
react注入的js逻辑会正常走完
走到错误链接script,请求一直pending中，也无法执行这个script，所以走不到构建render树渲染引擎绘制页面这一步，页面一直白屏。
一段时间后，这个script由pending状态变成failed，页面绘制出react作出的页面（包括写在react内的那些console才在控制台显示。）
如果react代码内出现null.a这样的严重错误，后面的代码也都不会执行，页面白屏很正常。

# 1、资源失效导致白屏
或许会有人认为，将静态资源扔到 CDN 上后就一劳永逸了。然而现实世界中，网络环境十分复杂，相同主机在不同线路、不同地区、不同时间段的可用性和访问质量是不同的，所以使用 CDN 不是解决这个问题的银弹，但是同时使用多个 CDN 或许是当前阶段比较通用的方案。

用户网络环境复杂，运营商劫持，国外访问CDN无效等等，这种情况下会导致白屏。

有通用的策略，也有针对webpack打包的针对性方案。不过这些方案总结来说，还是要实现2个大的功能：
1.识别资源加载失败
2.重新加载失败的资源

# 2、代码执行异常
js语法不当如1.使用了es6的语法（如 let ），但是本身代码没有做es5的自动适配。2.引入了三方外部插件，外部插件语法存在兼容性问题

读取 undefined null 的属性，null.a;
对普通对象进行函数调用，const o = {}; o();
将 null undefined 传递给 Object.keys，Object.keys(null);
JSON 反序列化接受到非法值，JSON.parse({});

这些Uncaught SyntaxError出现后，同一个script下以后的代码都不会执行了。（不同script标签下的代码还是会执行）

# 监控资源加载失败
1. 监控页面主元素是否渲染：
主要可以通过关键节点是否渲染来监控，如body子元素，root节点下是否挂载。
或者mutationObserver这个api来监控页面dom变化。

2. 判断是否为ErrorBoundaries兜底组件：
错误边界是 React 组件，它可以 在子组件树的任何位置捕获 JavaScript 错误，记录这些错误，并显示一个备用 UI ，而不是使整个组件树崩溃。
自 React 16 开始，任何未被错误边界捕获的错误将会卸载整个 React 组件树。

所以使用React 兜底组件可以避免白屏，兜底组件可以在整个H5统一使用同一个 class="error-boundary"的标识。
当判断有 class="error-boundary" 时也作为白屏进行上报，但在字段上报上需要做特殊标识，以区别正在的白屏。

3. 没有主元素也没有兜底组件时，可以使用 elementsFromPoint api 判断屏幕中的 9（17） 个点最上层元素是否都是白屏元素（根元素、容器元素）
```
// 监听页面白屏
export function blankScreen() {
    // 页面加载完毕
    function onload(callback) {
        if (document.readyState === 'complete') {
            callback();
        } else {
            window.addEventListener('load', callback);
        }
    }
    // 定义属于白屏元素的白屏点
    let wrapperElements = ['html', 'body', '#container', '.content'];
    // 白屏点个数
    let emptyPoints = 0;
    // 选中dom点的名称
    function getSelector(element) {
        if (element.id) {
            return "#" + element.id;
        } else if (element.className) {// a b c => .a.b.c
            return "." + element.className.split(' ').filter(item => !!item).join('.');
        } else {
            return element.nodeName.toLowerCase();
        }
    }
    // 是否是白屏点判断
    function isWrapper(element) {
        let selector = getSelector(element);
        if (wrapperElements.indexOf(selector) != -1) {
            emptyPoints++;
        }
    }
    // 页面加载完毕初始化
    onload(function () {
        for (let i = 1; i <= 9; i++) {
            let xElements = document.elementsFromPoint(
                window.innerWidth * i / 10, window.innerHeight / 2);
            let yElements = document.elementsFromPoint(
                window.innerWidth / 2, window.innerHeight * i / 10);
            isWrapper(xElements[0]);
            isWrapper(yElements[0]);
        }
        // 总共9个点超过7个点算作白屏
        if (emptyPoints >= 7) {
            let centerElements = document.elementsFromPoint(
                window.innerWidth / 2, window.innerHeight / 2
            );
            console.log('页面白屏',{
                kind: 'stability',
                type: 'blank',
                emptyPoints,
                screen: window.screen.width + "X" + window.screen.height,
                viewPoint: window.innerWidth + "X" + window.innerHeight,
                selector: getSelector(centerElements[0])
            });
        }
    });
}
```

## 判断时机和监控方式

1. 触发onerror时
大多数情况下出现白屏都是因为代码执行异常所导致，那我们可以在代码异常的监控中来判断是否白屏。
```
// JS错误
window.onerror = function (message, source, lineno, colno, error): void {
    checkWhiteScreen()            
}
// Promise错误
window.addEventListener('unhandledrejection', function (event) {
    checkWhiteScreen()       
})

*   message：错误信息（字符串）。可用于HTML onerror=""处理程序中的event。
*   source：发生错误的脚本URL（字符串）
*   lineno：发生错误的行号（数字）
*   colno：发生错误的列号（数字）
*   error：Error对象
```

也可以在script 上添加onerror属性触发加载失败回调捕捉异常。
借助构建工具 ( 如 webpack 的 script-ext-html-webpack-plugin 插件) ，我们可以轻易地完成对所有 script 标签自动化注入 onerror 标签属性。
```
new ScriptExtHtmlWebpackPlugin({
    custom: {
      test: /\.js$/,
      attribute: 'onerror',
      value: 'onError(this)'
    }
 })
```

或者在window监听error，注意这些监听代码要在所有script之前。
```
window.addEventListener('error', function(event) { ... })

当资源（如img或script）加载失败，加载资源的元素会触发一个Event接口的error事件，并执行该元素上的onerror()处理函数。这些error事件不会向上冒泡到window，但可以在捕获阶段被捕获
因此如果要全局监听资源加载错误，需要在捕获阶段捕获事件
//图片加载失败使用默认图片，依旧加载失败超过三次使用base64图片
window.addEventListener('error',function(e){
    let target = e.target, // 当前dom节点
        tagName = target.tagName,
        count = Number(target.dataset.count ) || 0, // 以失败的次数，默认为0
        max= 3; // 总失败次数，此时设定为3
    // 当前异常是由图片加载异常引起的
    if( tagName.toUpperCase() === 'IMG' ){
        if(count >= max){
            target.src = 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD//AK3/ALYH+5hX6FV5N4Y/5GHwx/vyf+iJa9ZrysPhoYVShDZu/potDmwWFhhIzhT2bv6aLQ//Z';
        }else{
            target.dataset.count = count + 1;
            target.src = '//xxx/default.jpg';
        }
    }
},true)
```
利用addEventListener在捕获阶段获得错误，通过判断e不是ErrorEvent来判断是资源加载错误。但是这个错误不能判断资源是404还是网络问题，都统一返回一个error。如果需要知道具体的问题，还需要通过ajax请求一次这个出错的资源，才能知道具体问题（是404、域名解析不了、服务不可用、还是加载超时等）

window.onerror是一个全局变量，默认值为null。当有js运行时错误触发时，window会触发error事件，并执行window.onerror()。onerror可以接受多个参数。

监听js运行时错误事件，会比window.onerror先触发，与onerror的功能大体类似，不过事件回调函数传参只有一个保存所有错误信息的参数，不能阻止默认事件处理函数的执行，但可以全局捕获资源加载异常的错误。


2. 定时3秒后进行检查
有时JS代码并没有报错，但是因接口数据没有活动到，前端也没有设置默认数据时，也会出现白屏，此时没有onerror触发，可以通过设置定时器触发白屏检测。
```
const timer = setTimeout(() => {
    clearTimeout(timer)
    checkWhiteScreen()    
}, 3000)
```
当以上两种时机触发时，就可以去执行判断白屏的逻辑，当发现判断白屏的三个条件都成立，这判定为白屏，就可进行上报。


# 计算白屏时间
通常认为浏览器开始渲染 <body> 标签或者解析完 <head> 标签的时刻就是页面白屏结束的时间点。

可使用 Performance API 时
白屏时间 = firstPaint - performance.timing.navigationStart;

不可使用 Performance API 时
白屏时间 = firstPaint - pageStartTime;




## 重新加载失败的资源

### 加载失败时，刷新页面 (reload）

当资源加载失败时，刷新页面可能是最简单直接的尝试恢复方式。当监控到资源加载失败时，我们通过 location.reload(true) 强制浏览器刷新重新加载资源（全部重载页面，不太好），并且为了防止出现一直刷新的情况，结合了 SessionStorage 限制自动刷新次数。

### 针对加载失败的文件进行重加载
css资源和js资源都是通过dom标签加载的，所以实现方案上可以统一，流程都是识别所有的dom，然后把对应链接里的CDN域名提高为新的域名，再把得到的新链接生成dom重新插入到页面中，利用浏览器的并行加载，顺序执行重新执行一遍这些资源。（如果出现部分js资源失败，部分成功。重新加载全部资源，可能会导致某些js执行出错，如果这些js文件不支持多次执行的话。我们这里不对这种情况做讨论，指考虑统一失败的情况，加载所有资源都使用了相同的CDN，且这些js都支持多次重复执行。）

替换域名动态重加载。然而，失败资源重加载成功后，页面原有的加载顺序可能发生变化，最终执行顺序发现变化也将导致执行异常。
在不需要考虑兼容性的情况下，资源加载失败时通过 document.write 写入新的 script 标签，可以阻塞后续 script 脚本的执行，直到新标签加载并执行完毕，从而保证原来的顺序。
于是我们需要增加 “管理 JS 执行顺序” 的逻辑。使 JS 文件加载完成后，先检查所依赖的文件是否都加载完成，再执行业务逻辑。当存在加载失败时，则会等待文件加载完成后再执行，从而保证正常执行。

手动管理模块文件之间的依赖和执行时机存在着较大的维护成本。而实际上现代的模块打包工具，如 webpack ，已经天然的处理好这个问题。通过分析构建后的代码可以发现，构建生成的代码不仅支持模块间的依赖管理，也支持了上述的等待加载完成后再统一执行的逻辑。
```
// 检查是否都加载完成，如是，则开始执行业务逻辑
function checkDeferredModules() {
    // ...
    if(fulfilled) {
        // 所有都加载，开始执行
        result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
    }
}
```

然而，在默认情况下，业务代码的执行不会判断配置的 external 模块是否存在。所以当 external 文件未加载完成或加载失败时，使用对应模块将会导致报错。
所以我们需要在业务逻辑执行前，保证所依赖的 external 都加载完成。最终通过开发 wait-external-webpack-plugin webpack 插件，在构建时分析所依赖的 external，并注入监控代码，等待所有依赖的文件都加载完成后再统一顺序执行。
