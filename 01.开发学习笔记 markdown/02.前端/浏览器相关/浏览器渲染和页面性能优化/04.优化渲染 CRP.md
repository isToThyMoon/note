
# 如何优化 CRP
CRP，即关键渲染路径（Critical Rendering Path），它是浏览器将 HTML/CSS/JavaScript 转换为在屏幕上呈现的像素内容所经历的一系列步骤，也就是我们上面说的浏览器渲染流程，为了尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：

* 关键资源的数量，可能阻止网页首次渲染的资源
* 关键路径长度，获取所有关键资源所需的往返次数或总时间
* 关键字节，实现网页首次渲染所需的总字节数，等同于所有关键资源传送文件大小的总和

## 优化 DOM
* 删除不必要的代码和注释包括空格，尽量做到最小化文件
* 可以利用 GZIP 压缩文件
* 结合 HTTP 缓存文件

## 优化 CSSOM
缩小、压缩以及缓存同样重要，对于 CSSOM 我们前面重点提过了它会阻止页面呈现，因此我们可以从这方面考虑去优化，步骤如下：

* 减少关键 CSS 元素数量
* 当我们声明样式表时，请密切关注媒体查询的类型，它们极大地影响了 CRP 的性能

## 优化 JavaScript
当浏览器遇到 <script> 标记时，会阻止解析器继续操作，直到 CSSOM 构建完毕，JavaScript 才会运行并继续完成 DOM 构建过程，所以我们可以考虑以下方式

* Async，当我们在 <script> 标记中添加 Async 属性以后，浏览器遇到这个标记时会继续解析 DOM，同时脚本也不会被 CSSOM 阻止，即不会阻止 CRP
* Defer，与 Async 的区别在于，脚本需要等到文档解析后（DOMContentLoaded 事件前）执行，而 Async 允许脚本在文档解析时位于后台运行（两者下载的过程不会阻塞 DOM，但执行会）
* 当我们的脚本不会修改 DOM 或 CSSOM 时推荐使用 Async
* 预加载（preload && prefetch）
* DNS 预解析（dns-prefetch）

## 总结
* 分析并用 关键资源数 关键字节数 关键路径长度 来描述我们的 CRP
* 最小化关键资源数，消除它们（内联）、推迟它们的下载（Defer）或者使它们异步解析（Async）等等
* 优化关键字节数（缩小、压缩）来减少下载时间
* 优化加载剩余关键资源的顺序，让关键资源（CSS）尽早下载以减少 CRP 长度

更多相关内容可以参考 [前端性能优化之关键路径渲染优化](https://github.com/fi3ework/blog/issues/16)


# 其他优化 

包括浏览器自身的一些优化：

## 首屏加载
Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。 （在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求。）
需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。
后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建DOM，构建布局树，绘制页面。


## requestAnimationFrame提升动画流畅度
页面里的动画效果大多是通过JavaScript触发的。有些是直接修改DOM元素样式属性而产生的，有些则是由数据计算而产生的，比如搜索或排序。错误的执行时机和太长的时间消耗，是常见的导致JavaScript性能低下的原因。

使用requestAnimationFrame优化
如果你想在动画刚刚发生的那一刻就运行一段JavaScript。那么能保证这个运行时机的，就是requestAnimationFrame。

//
function updateScreen(time) {
  // 你要干的
}

requestAnimationFrame(updateScreen);
如果你的js代码是要改变样式，制作动画效果，那么requestAnimationFrame能保证你的代码在浏览器下一帧中触发，让你的动画流畅起来。

## 耗时长的JavaScript代码使用Web Workers
JavaScript代码是运行在浏览器的主线程上的。与此同时，浏览器的主线程还负责样式计算、布局，甚至绘制（多数情况下）的工作。可以想象，如果JavaScript代码运行时间过长，就会阻塞主线程上其他的渲染工作，很可能就会导致帧丢失。

因此，你需要认真规划一下你的JavaScript程序的运行时机和运行耗时。比如，如果你要在一个动画（比如页面滚动）执行过程中运行JavaScript程序，那么理想情况是把这段JavaScript程序的运行耗时控制在3-4毫秒以内。如果长于这个时间，那么就有帧丢失的风险。另一方面，在浏览器空闲的时候，你可以有更多时间来运行JavaScript程序。

大多数情况下，你可以把纯计算工作放到Web Workers中做（如果这些计算工作不会涉及DOM元素的存取）。一般来说，JavaScript中的数据处理工作，比如排序或搜索，一般都适合这种处理方式。

```js
var dataSortWorker = new Worker("sort-worker.js");
dataSortWorker.postMesssage(dataToSort);

// 现在主线程是空闲的可以用来干其他事

dataSortWorker.addEventListener('message', function(e) {
   var sortedData = e.data;
   // 一些操作，如更新页面中的数据
});
```

## 划分DOM更新，再多个frame中完成
由于Web Workers无法访问DOM元素。如果你的JavaScript代码需要存取DOM元素，也就是说必须在主线程上运行，那么可以考虑批处理的方式：把任务细分为若干个小任务，每个小任务耗时很少，各自放在一个requestAnimationFrame中回调运行。

```js
var taskList = breakBigTaskIntoMicroTasks(monsterTaskList);
requestAnimationFrame(processTaskList);

function processTaskList(taskStartTime) {
  var taskFinishTime;

  do {
   	var nextTask = taskList.pop();

    processTask(nextTask);

    // 获取本次任务的执行结束时间
    taskFinishTime = window.performance.now();
    // 如果这一帧中任务执行超过3ms，就将任务队列中的任务扔到下一帧中
  } while (taskFinishTime - taskStartTime < 3);

  if (taskList.length > 0)
    requestAnimationFrame(processTaskList);

}
```